/*! For license information please see hls.js.LICENSE.txt */ ! function Xy(Yy) {
    const Jy = this;
    var e, t;
    e = this, t = function() {
        "use strict";
        var P, e = e => e && e.Math === Math && e,
            l = e("object" == typeof globalThis && globalThis) || e("object" == typeof window && window) || e("object" == typeof Jy && Jy) || e("object" == typeof global && global) || Function("return this")();
        class d {
            constructor() {
                this.keySize = null, this.ksRows = null, this.keySchedule = null, this.invKeySchedule = null, this.rcon = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54], this.subMix = [new Uint32Array(256), new Uint32Array(256), new Uint32Array(256), new Uint32Array(256)], this.invSubMix = [new Uint32Array(256), new Uint32Array(256), new Uint32Array(256), new Uint32Array(256)], this.sBox = new Uint32Array(256), this.invSBox = new Uint32Array(256), this.key = new Uint32Array(0), this.initTable()
            }
            uint8ArrayToUint32Array_(e) {
                const t = new DataView(e),
                    i = Math.floor(t.byteLength / 4),
                    r = new Uint32Array(i);
                for (let e = 0; e < i; e++) r[e] = t.getUint32(4 * e);
                return r
            }
            initTable() {
                const e = this["sBox"],
                    t = this["invSBox"],
                    i = this["subMix"],
                    r = i[0],
                    n = i[1],
                    s = i[2],
                    a = i[3],
                    o = this["invSubMix"],
                    l = o[0],
                    d = o[1],
                    u = o[2],
                    c = o[3],
                    h = new Uint32Array(256);
                let p = 0,
                    f = 0,
                    m = 0;
                for (m = 0; m < 256; m++) h[m] = m < 128 ? m << 1 : m << 1 ^ 283;
                for (m = 0; m < 256; m++) {
                    var g = (g = f ^ f << 1 ^ f << 2 ^ f << 3 ^ f << 4) >>> 8 ^ 255 & g ^ 99;
                    e[p] = g, t[g] = p;
                    const o = h[p],
                        m = h[o],
                        v = h[m];
                    var y = 257 * h[g] ^ 16843008 * g;
                    r[p] = y << 24 | y >>> 8, n[p] = y << 16 | y >>> 16, s[p] = y << 8 | y >>> 24, a[p] = y, y = 16843009 * v ^ 65537 * m ^ 257 * o ^ 16843008 * p, l[g] = y << 24 | y >>> 8, d[g] = y << 16 | y >>> 16, u[g] = y << 8 | y >>> 24, c[g] = y, p ? (p = o ^ h[h[h[v ^ o]]], f ^= h[h[f]]) : p = f = 1
                }
            }
            expandKey(e) {
                var n = this.uint8ArrayToUint32Array_(e);
                let t = !0,
                    i = 0;
                for (; i < n.length && t;) t = n[i] === this.key[i], i++;
                if (!t) {
                    this.key = n;
                    var s = this.keySize = n.length;
                    if (4 !== s && 6 !== s && 8 !== s) throw new Error("Invalid aes key size=" + s);
                    var a = this.ksRows = 4 * (s + 6 + 1);
                    let e, t;
                    const o = this.keySchedule = new Uint32Array(a),
                        l = this.invKeySchedule = new Uint32Array(a),
                        d = this.sBox,
                        u = this["rcon"],
                        c = this["invSubMix"],
                        h = c[0],
                        p = c[1],
                        f = c[2],
                        m = c[3];
                    let i, r;
                    for (e = 0; e < a; e++) e < s ? i = o[e] = n[e] : (r = i, e % s == 0 ? (r = r << 8 | r >>> 24, r = d[r >>> 24] << 24 | d[r >>> 16 & 255] << 16 | d[r >>> 8 & 255] << 8 | d[255 & r], r ^= u[e / s | 0] << 24) : 6 < s && e % s == 4 && (r = d[r >>> 24] << 24 | d[r >>> 16 & 255] << 16 | d[r >>> 8 & 255] << 8 | d[255 & r]), o[e] = i = (o[e - s] ^ r) >>> 0);
                    for (t = 0; t < a; t++) e = a - t, r = 3 & t ? o[e] : o[e - 4], l[t] = t < 4 || e <= 4 ? r : h[d[r >>> 24]] ^ p[d[r >>> 16 & 255]] ^ f[d[r >>> 8 & 255]] ^ m[d[255 & r]], l[t] = l[t] >>> 0
                }
            }
            networkToHostOrderSwap(e) {
                return e << 24 | (65280 & e) << 8 | (16711680 & e) >> 8 | e >>> 24
            }
            decrypt(e, t, i) {
                var r = this.keySize + 6,
                    n = this["invKeySchedule"],
                    s = this.invSBox,
                    a = this["invSubMix"],
                    o = a[0],
                    l = a[1],
                    d = a[2],
                    u = a[3],
                    i = this.uint8ArrayToUint32Array_(i);
                let c = i[0],
                    h = i[1],
                    p = i[2],
                    f = i[3];
                const m = new Int32Array(e),
                    g = new Int32Array(m.length);
                let y, v, S, b, T, E, I, w, A, O, k, C, D, M;
                const x = this.networkToHostOrderSwap;
                for (; t < m.length;) {
                    for (A = x(m[t]), O = x(m[t + 1]), k = x(m[t + 2]), C = x(m[t + 3]), T = A ^ n[0], E = C ^ n[1], I = k ^ n[2], w = O ^ n[3], D = 4, M = 1; M < r; M++) y = o[T >>> 24] ^ l[E >> 16 & 255] ^ d[I >> 8 & 255] ^ u[255 & w] ^ n[D], v = o[E >>> 24] ^ l[I >> 16 & 255] ^ d[w >> 8 & 255] ^ u[255 & T] ^ n[D + 1], S = o[I >>> 24] ^ l[w >> 16 & 255] ^ d[T >> 8 & 255] ^ u[255 & E] ^ n[D + 2], b = o[w >>> 24] ^ l[T >> 16 & 255] ^ d[E >> 8 & 255] ^ u[255 & I] ^ n[D + 3], T = y, E = v, I = S, w = b, D += 4;
                    y = s[T >>> 24] << 24 ^ s[E >> 16 & 255] << 16 ^ s[I >> 8 & 255] << 8 ^ s[255 & w] ^ n[D], v = s[E >>> 24] << 24 ^ s[I >> 16 & 255] << 16 ^ s[w >> 8 & 255] << 8 ^ s[255 & T] ^ n[D + 1], S = s[I >>> 24] << 24 ^ s[w >> 16 & 255] << 16 ^ s[T >> 8 & 255] << 8 ^ s[255 & E] ^ n[D + 2], b = s[w >>> 24] << 24 ^ s[T >> 16 & 255] << 16 ^ s[E >> 8 & 255] << 8 ^ s[255 & I] ^ n[D + 3], D += 3, g[t] = x(y ^ c), g[t + 1] = x(b ^ h), g[t + 2] = x(S ^ p), g[t + 3] = x(v ^ f), c = A, h = O, p = k, f = C, t += 4
                }
                return g.buffer
            }
            destroy() {
                this.key = void 0, this.keySize = void 0, this.ksRows = void 0, this.sBox = void 0, this.invSBox = void 0, this.subMix = void 0, this.invSubMix = void 0, this.keySchedule = void 0, this.invKeySchedule = void 0, this.rcon = void 0
            }
        }
        class i {
            constructor(e, t) {
                this.rpc = e, this.logger = t, this.decrypt = (r, n, s, a, o) => t => {
                    const i = l.crypto;
                    if (null != o && o.useJSCrypto || null == i || !i.subtle) {
                        const s = new d;
                        var e;
                        s.expandKey(r);
                        const i = s.decrypt(a, 0, n);
                        e = o.plainTextLength ? i.slice(0, o.plainTextLength) : function(e) {
                            var t = new Uint8Array(e),
                                i = t[e.byteLength - 1],
                                r = e.byteLength - 1;
                            let n = 0;
                            if (1 <= i && i <= 16)
                                for (let e = r; e > r - i && t[e] === i; e--) n++;
                            return e = n === i ? e.slice(0, r - i + 1) : e
                        }(i), t(e, void 0, [e])
                    } else i.subtle.importKey("raw", r, s, !1, ["decrypt"]).then(e => i.subtle.decrypt({
                        name: s,
                        iv: n
                    }, e, a)).then(e => {
                        t(e, void 0, [e])
                    }).catch(e => t(void 0, e))
                }, e.register("decrypt", this.decrypt)
            }
        }(vr = P = P || {}).MEDIA_ATTACHING = "hlsMediaAttaching", vr.MEDIA_ATTACHED = "hlsMediaAttached", vr.MEDIA_DETACHING = "hlsMediaDetaching", vr.MEDIA_DETACHED = "hlsMediaDetached", vr.BUFFER_CREATED = "hlsBufferCreated", vr.BUFFER_APPENDING = "hlsBufferAppending", vr.BUFFER_APPENDED = "hlsBufferAppended", vr.BUFFER_FLUSHED = "hlsBufferFlushed", vr.MANIFEST_LOADING = "hlsManifestLoading", vr.MANIFEST_LOADED = "hlsManifestLoaded", vr.MANIFEST_PARSED = "hlsManifestParsed", vr.LEVEL_SWITCHING = "hlsLevelSwitching", vr.LEVEL_SWITCHED = "hlsLevelSwitched", vr.LEVEL_LOADING = "hlsLevelLoading", vr.LEVEL_LOADED = "hlsLevelLoaded", vr.LEVEL_UPDATED = "hlsLevelUpdated", vr.LEVELS_CHANGED = "hlsLevelsChanged", vr.AUDIO_TRACKS_UPDATED = "hlsAudioTracksUpdated", vr.AUDIO_TRACK_SWITCH = "hlsAudioTrackSwitch", vr.AUDIO_TRACK_SWITCHED = "hlsAudioTrackSwitched", vr.AUDIO_TRACK_LOADED = "hlsAudioTrackLoaded", vr.SUBTITLE_TRACKS_UPDATED = "hlsSubtitleTracksUpdated", vr.SUBTITLE_TRACKS_CREATED = "hlsSubtitleTracksCreated", vr.SUBTITLE_TRACK_SWITCH = "hlsSubtitleTrackSwitch", vr.INLINE_STYLES_PARSED = "hlsInlineStylesParsed", vr.SESSION_DATA_COMPLETE = "hlsSessionDataComplete", vr.FRAG_LOADING = "hlsFragLoading", vr.FRAG_LOADED = "hlsFragLoaded", vr.FRAG_BUFFERED = "hlsFragBuffered", vr.FRAG_CHANGED = "hlsFragChanged", vr.INTERNAL_ERROR = "hlsInternalError", vr.ERROR = "hlsError", vr.DESTROYING = "hlsDestroying", vr.KEY_REQUEST_STARTED = "hlsKeyRequestStarted", vr.LICENSE_CHALLENGE_CREATED = "hlsLicenseChallengeCreated", vr.LICENSE_RELEASED = "hlsLicenseReleased", vr.KEY_LOADED = "hlsKeyLoaded", vr.UNRESOLVED_URI_LOADING = "hlsUnresolvedUriLoading", vr.DESIRED_RATE_CHANGED = "hlsDesiredRateChanged", vr.PLAYER_STATE_CHANGE = "hlsPlayerStateChange", vr.SEEKING = "hlsSeeking", vr.SEEKED = "hlsSeeked", vr.STALLED = "hlsStalled", vr.RESUME_FROM_STALL = "hlsResumeFromStall", vr.READY_FOR_NEXT_ITEM = "hlsReadyForNextItem", vr.ITEM_TRANSITIONED = "hlsItemTransitioned", vr.ITEM_EVICTED = "hlsItemEvicted", vr.DATERANGE_UPDATED = "hlsDaterangeUpdated";
        var v, x = P;
        (dl = v = v || {}).FRAG_PARSING_INIT_SEGMENT = "hlsFragParsingInitSegment", dl.FRAG_PARSING_DATA = "hlsFragParsingData", dl.FRAG_PARSED = "hlsFragParsed", dl.INIT_PTS_FOUND = "hlsInitPtsFound";
        class p extends Error {
            constructor(e, t, i, r, n) {
                super(r), this.type = e, this.details = t, this.fatal = i, this.reason = r, this.response = n, this.handled = !1
            }
        }
        class R extends p {
            constructor(e, t, i, r, n) {
                super(e, t, i, r, n), this.response = n
            }
        }
        const $ = {
                PlaylistNotReceived: {
                    code: -12884,
                    text: "Playlist not received"
                },
                CryptResponseReceivedSlowly: {
                    code: -16833,
                    text: "Crypt key received slowly"
                },
                LivePlaylistUpdateError: {
                    code: -12888,
                    text: "Live playlist not updated"
                },
                NoResponseFromMediaRequest: {
                    code: -12889,
                    text: "No response for fragment"
                },
                IncompatibleAsset: {
                    code: -12927,
                    text: "IncompatibleAsset"
                },
                CorruptStream: {
                    code: -16041,
                    text: "Corrupt fragment"
                },
                InternalError: {
                    code: -12645,
                    text: "InternalException"
                },
                CantSwitchInTime: {
                    code: -12644,
                    text: "CantSwitchInTime"
                },
                VideoDecoderBadDataErr: {
                    code: -12909,
                    text: "Buffer error"
                },
                InsufficientDataAvailable: {
                    code: -12928,
                    text: "Incomplete data"
                },
                AllocationFailed: {
                    code: -12862,
                    text: "AllocationFailed"
                },
                PlaylistErrorMissingEXTM3U: {
                    code: -12269,
                    text: "Response doesnt have #EXTM3U tag"
                },
                PlaylistErrorInvalidEntry: {
                    code: -12264,
                    text: "Invalid entry"
                },
                PlaylistErrorBadTargetDuration: {
                    code: -12271,
                    text: "Invalid targetduration"
                },
                NoValidAlternates: {
                    code: -12925,
                    text: "No valid alternates"
                },
                FormatError: {
                    code: -12642,
                    text: "Incorrect playlist format"
                },
                UnsupportedKeySystemError: {
                    code: -6e4,
                    text: "Unsupported Key System"
                },
                EmptyLoadSourceError: {
                    code: -60001,
                    text: "Empty loadSource url"
                },
                UndefinedItemIdError: {
                    code: -60002,
                    text: "Undefined itemId"
                },
                ManifestParseError: {
                    code: -60003,
                    text: "Manifest parse error"
                },
                DemuxWorkerError: {
                    code: -60004,
                    text: "Demux worker error"
                },
                DecryptWorkerError: {
                    code: -60005,
                    text: "Decrypt worker error"
                },
                OutOfRangeSeekError: {
                    code: -60006,
                    text: "Seeked out of playable range"
                },
                ExceptionInKeyLoadError: {
                    code: -60007,
                    text: "Exception in Key load"
                },
                FragmentAbortError: {
                    code: -60008,
                    text: "Fragment abort error"
                },
                ManifestTimeoutError: {
                    code: -60009,
                    text: "Manifest Timeout Error"
                },
                PlaylistTimeoutError: {
                    code: -60010,
                    text: "Playlist Timeout Error"
                },
                FragmentTimeoutError: {
                    code: -60011,
                    text: "Fragment Timeout Error"
                },
                IncompleteSessionData: {
                    code: -60012,
                    text: "Session data not complete after loading all items"
                },
                SessionDataLoadTimeout: {
                    code: -60013,
                    text: "Session data load timeout"
                },
                FailedDemuxerSanityCheck: {
                    code: -60014,
                    text: "Failed demuxer sanity check"
                },
                InvalidADTSSamplingIndex: {
                    code: -60015,
                    text: "Invalid ADTS sampling index"
                },
                DemuxerNotFound: {
                    code: -60016,
                    text: "No demux matching with content found"
                },
                InvalidAC3Magic: {
                    code: -60029,
                    text: "Invalid ac-3 magic"
                },
                InvalidInitTimestamp: {
                    code: -60017,
                    text: "Invalid initPTS or initDTS"
                },
                NoAVSamplesFound: {
                    code: -60018,
                    text: "no audio/video samples found"
                },
                NoTSSyncByteFound: {
                    code: -60019,
                    text: "TS packet did not start with 0x47"
                },
                PESDidNotStartWithADTS: {
                    code: -60020,
                    text: "AAC PES did not start with ADTS header"
                },
                NoADTSHeaderInPES: {
                    code: -60021,
                    text: "No ADTS header found in AAC PES"
                },
                InvalidDolbyAudioMagic: {
                    code: -60022,
                    text: "Invalid dolby audio magic"
                },
                FailedToAllocateVideoMdat: {
                    code: -60023,
                    text: "Fail allocating video mdat"
                },
                FailedToAllocateAudioMdat: {
                    code: -60024,
                    text: "Fail allocating audio mdat"
                },
                InsufficientEC3Data: {
                    code: -60025,
                    text: "Error parsing ec-3, not enough data"
                },
                InvalidEC3Magic: {
                    code: -60026,
                    text: "Invalid ec-3 magic"
                },
                ReservedStreamType: {
                    code: -60027,
                    text: "Reserved stream type"
                },
                InsufficientAC3Data: {
                    code: -60028,
                    text: "error parsing ac-3, not enough data"
                },
                InvalidAC3SamplingRateCode: {
                    code: -60030,
                    text: "Invalid ac-3 samplingRateCode"
                },
                PlaylistErrorInvalidEXTXDEFINE: {
                    code: -61e3,
                    text: "Encountered undefined/not imported EXT-X-DEFINE property"
                },
                PlaylistErrorMissingImportReference: {
                    code: -61001,
                    text: "IMPORT references variable not in master playlist and/or NAME"
                },
                PlaylistErrorInvalidSERVERURI: {
                    code: -61002,
                    text: "Encountered undefined/invalid SERVER-URI attribute for EXT-X-CONTENT-STEERING tag"
                },
                PlaylistErrorInvalidPATHWAYID: {
                    code: -61003,
                    text: "Encountered invalid PATHWAY-ID attribute for EXT-X-CONTENT-STEERING tag"
                },
                PlaylistErrorInvalidSCORE: {
                    code: -61004,
                    text: "Encountered negative/non-number SCORE property"
                },
                KeySystemFailedToUpdateSession: {
                    code: -62e3,
                    text: "KeySystem: Promise Rejected while updating session"
                },
                KeySystemFailedToGenerateLicenseRenewal: {
                    code: -62001,
                    text: "KeySystem: Failed to generate license renewal"
                },
                KeySystemFailedToGenerateLicenseRequest: {
                    code: -62002,
                    text: "KeySystem: Failed to generate license request"
                },
                KeySystemAbort: {
                    code: -62003,
                    text: "KeySystem: Aborted"
                },
                KeySystemUnexpectedStateTransition: {
                    code: -62004,
                    text: "KeySystem: Unexpected state transition"
                },
                KeySystemUnexpectedState: {
                    code: -62005,
                    text: "KeySystem: Unexpected state"
                },
                KeySystemCDMUnknownError: {
                    code: -62006,
                    text: "KeySystem: Unknown error from CDM"
                },
                KeySystemRequestTimedOut: {
                    code: -62007,
                    text: "Key request timed out"
                },
                KeySystemUnexpectedMETHOD: {
                    code: -62008,
                    text: "Unexpected METHOD attribute"
                },
                KeySystemUnmatchedString: {
                    code: -62009,
                    text: "KeySystem: string does not match"
                },
                KeySystemInternalError: {
                    code: -62010,
                    text: "KeySystem: internal-error"
                },
                KeySystemOutputRestricted: {
                    code: -62011,
                    text: "KeySystem: output-restricted"
                },
                KeySystemSetupError: {
                    code: -62012,
                    text: "KeySystem: setup error"
                },
                KeySystemFailedToInitialize: {
                    code: -62013,
                    text: "KeySystem: could not initialize"
                },
                KeySystemFailedToCreateSession: {
                    code: -62014,
                    text: "KeySystem: could not create session"
                },
                KeySystemUndefinedNavigator: {
                    code: -62015,
                    text: "KeySystem: navigator undefined"
                },
                KeySystemNoKeySystemsToTry: {
                    code: -62016,
                    text: "KeySystem: no key systems to try"
                },
                KeySystemNoConstructor: {
                    code: -62017,
                    text: "KeySystem: No constructor"
                },
                KeySystemNoKeySystemAccess: {
                    code: -62018,
                    text: "KeySystem: No KeySystemAccess"
                },
                KeySystemCertificateLoadError: {
                    code: -62019,
                    text: "KeySystem: Certificate Load Error"
                }
            },
            o = "networkError",
            L = "mediaError",
            s = "otherError",
            _ = "manifestParsingError",
            f = "manifestIncompatibleCodecsError",
            N = "levelLoadError",
            n = "bufferAppendError",
            r = "internalException";
        class V extends p {
            constructor(e, t, i) {
                super(s, r, e, t, i)
            }
        }
        class D extends p {
            constructor(e, t, i) {
                super(L, "fragParsingError", e, t, i)
            }
        }
        class F extends p {
            constructor(e, t, i, r) {
                super("muxError", "remuxAllocError", e, t, i), this.bytes = r
            }
        }

        function S(e) {
            return e.baseTime / e.timescale
        }

        function B(e, t) {
            return {
                baseTime: Math.floor(e * t),
                timescale: t
            }
        }

        function g(e, t) {
            return S(e) < S(t) ? e : t
        }

        function y(e, t) {
            return S(e) > S(t) ? e : t
        }

        function b(e, t) {
            return S(e) - S(t)
        }
        var t = void 0 !== l.Buffer ? require("events").EventEmitter : class {
            constructor() {
                this.eventMap = {}
            }
            _on(e, t, i = !1) {
                return null == this.eventMap[e] && (this.eventMap[e] = []), i ? this.eventMap[e].splice(0, 0, t) : this.eventMap[e].push(t), this
            }
            _off(e, t) {
                return null != this.eventMap[e] && (this.eventMap[e] = this.eventMap[e].filter(e => e.listener !== t.listener), 0 === this.eventMap[e].length && delete this.eventMap[e]), this
            }
            on(e, t) {
                return this._on(e, {
                    listener: t,
                    once: !1
                })
            }
            off(e, t) {
                return this._off(e, {
                    listener: t
                })
            }
            addListener(e, t) {
                return this.on(e, t)
            }
            once(e, t) {
                return this._on(e, {
                    listener: t,
                    once: !0
                })
            }
            removeListener(e, t) {
                return this.off(e, t)
            }
            removeAllListeners(e) {
                return delete this.eventMap[e], this
            }
            setMaxListeners(e) {
                return this
            }
            getMaxListeners() {
                return 1 / 0
            }
            listeners(e) {
                return null == this.eventMap[e] ? [] : this.eventMap[e].map(e => e.listener)
            }
            rawListeners(e) {
                return this.listeners(e)
            }
            emit(e, ...t) {
                if (null == this.eventMap[e]) return !1;
                let i = !1;
                for (const r of this.eventMap[e]) {
                    try {
                        r.listener.apply(this, t)
                    } catch (e) {}
                    i = !0
                }
                return i
            }
            listenerCount(e) {
                return null == this.eventMap[e] ? 0 : this.eventMap[e].length
            }
            prependListener(e, t) {
                return this._on(e, {
                    listener: t,
                    once: !1
                }, !0)
            }
            prependOnceListener(e, t) {
                return this._on(e, {
                    listener: t,
                    once: !0
                }, !0)
            }
            eventNames() {
                return Object.keys(this.eventMap)
            }
        };
        class a extends t {
            trigger(e, t) {
                this.emit(e, t)
            }
        }

        function E(e, t, i, r, n) {
            let s, a, o, l;
            const d = navigator.userAgent.toLowerCase(),
                u = [96e3, 88200, 64e3, 48e3, 44100, 32e3, 24e3, 22050, 16e3, 12e3, 11025, 8e3, 7350];
            s = 1 + ((192 & t[i + 2]) >>> 6);
            var c = (60 & t[i + 2]) >>> 2;
            if (!(u.length - 1 < c)) return o = (1 & t[i + 2]) << 2, o |= (192 & t[i + 3]) >>> 6, /firefox/i.test(d) ? 6 <= c ? (s = 5, l = new Array(4), a = c - 3) : (s = 2, l = new Array(2)) : -1 !== d.indexOf("android") ? (s = 2, l = new Array(2)) : (s = 5, l = new Array(4), a = r && (-1 !== r.indexOf("mp4a.40.29") || -1 !== r.indexOf("mp4a.40.5")) || !r && 6 <= c ? c - 3 : ((r && -1 !== r.indexOf("mp4a.40.2") || !r && 1 == o) && (s = 2, l = new Array(2)), c)), l[0] = s << 3, l[0] |= (14 & c) >> 1, l[1] |= (1 & c) << 7, l[1] |= o << 3, 5 === s && (l[1] |= (14 & a) >> 1, l[2] = (1 & a) << 7, l[2] |= 8, l[3] = 0), {
                esdsConfig: l,
                samplerate: u[c],
                channelCount: o,
                segmentCodec: "aac",
                codec: "mp4a.40." + s
            }; {
                const t = new D(!0, `invalid ADTS sampling index:${c}`, $.InvalidADTSSamplingIndex);
                e.trigger(x.INTERNAL_ERROR, t)
            }
        }
        class u {
            constructor(e, t, i, r, n) {
                this.observer = e, this.remuxer = t, this.config = i, this.typeSupported = r, this.logger = n
            }
            static probe(e, t) {
                throw new Error("Method not implemented")
            }
            resetTimeStamp(e) {}
            resetInitSegment(e, t, i, r) {}
            destroy() {}
        }
        class c extends u {
            constructor(e, t, i, r, n) {
                super(e, t, i, r, n), this.observer = e, this.remuxer = t, this.config = i, this.typeSupported = r, this.logger = n, this.esRemuxer = t
            }
        }
        class h {
            constructor(e, t, i) {
                this.observer = e, this.config = t, this.logger = i
            }
            resetInitSegment() {}
            resetTimeStamp(e) {}
            destroy() {}
        }
        let m, I;
        var w = {
                strToUtf8array: e => (m = m || new TextEncoder, m.encode(e)),
                utf8arrayToStr: e => (I = I || new TextDecoder("utf-8"), I.decode(e))
            },
            A = {
                strToUtf8array(e) {
                    e = l.Buffer.from(e, "utf-8");
                    return new Uint8Array(e.buffer, e.byteOffset, e.byteLength)
                },
                utf8arrayToStr: e => l.Buffer.from(e).toString("utf-8")
            };
        let O = {
            strToUtf8array(e) {
                const t = unescape(encodeURIComponent(e)),
                    i = new Uint8Array(t.length);
                for (let e = 0; e < t.length; e++) i[e] = t.charCodeAt(e);
                return i
            },
            utf8arrayToStr: e => String.fromCharCode.apply(null, Array.from(e))
        };
        "undefined" != typeof TextEncoder && "undefined" != typeof TextDecoder ? O = w : "function" == typeof(null === (fl = l.Buffer) || void 0 === fl ? void 0 : fl.from) && (O = A);
        const k = {
            name: "ID3"
        };
        class C {
            constructor(e, t) {
                this.logger = t, this._hasTimeStamp = !1, this._audioType = null, this._length = 0, this._frames = [];
                let i, r, n, s, a = 0;
                for (;;)
                    if (n = C.readUTF(e, a, 3), a += 3, "ID3" === n) {
                        this._minor = e[a++], this._revision = e[a++];
                        const t = e[a++];
                        if (128 & t && (this._unsynchronized = !0, this.logger.error(k, "id3 tag is unsynchronized")), 64 & t && (this._hasExtendedHeader = !0, this.logger.warn(k, "id3 tag has extended header")), i = C.readSynchSafeUint32(e.subarray(a, a + 4)), a += 4, r = a + i, this._hasExtendedHeader) {
                            const t = C.readSynchSafeUint32(e.subarray(a, a + 4));
                            this.logger.warn(k, `id3 tag has ${t}-byte extended header. usually 6 or 10 bytes`), a += t
                        }
                        2 < this.minor ? this._parseID3Frames(e, a, r) : this.logger.error(k, "[id3] doesn't support older than v2.3 tags"), a = r
                    } else {
                        if ("3DI" !== n) return a -= 3, void((s = a) && (this.hasTimeStamp || this.logger.warn(k, "ID3 tag found, but no timestamp"), this._length = s, this._payload = e.slice(0, s)));
                        a += 7
                    }
            }
            static isHeader(e, t) {
                return 73 === e[t] && 68 === e[t + 1] && 51 === e[t + 2] && e[t + 3] < 255 && e[t + 4] < 255 && e[t + 6] < 128 && e[t + 7] < 128 && e[t + 8] < 128 && e[t + 9] < 128
            }
            static readSynchSafeUint32(e) {
                return 2097152 * (127 & e[0]) + 16384 * (127 & e[1]) + 128 * (127 & e[2]) + (127 & e[3])
            }
            static readUTF(e, t, i) {
                let r = "",
                    n = t;
                for (var s = t + i; r += String.fromCharCode(e[n++]), n < s;);
                return r
            }
            isID3Frame(e, t) {
                return e[t + 4] < 128 && e[t + 5] < 128 && e[t + 6] < 128 && e[t + 7] < 128
            }
            decodeID3Frame(e) {
                return "TXXX" === e.type ? this.decodeTxxxFrame(e) : "WXXX" === e.type ? this.decodeWxxxFrame(e) : "PRIV" === e.type ? this.decodePrivFrame(e) : "T" === e.type[0] ? this.decodeTextFrame(e) : {
                    key: e.type,
                    data: e.data
                }
            }
            decodeTxxxFrame(e) {
                if (!(e.size < 2) && 3 === e.data[0]) {
                    var t = 1,
                        i = this.id3utf8ArrayToStr(e.data.subarray(1));
                    return t += i.length + 1, {
                        key: "TXXX",
                        description: i,
                        data: this.id3utf8ArrayToStr(e.data.subarray(t))
                    }
                }
            }
            decodeWxxxFrame(e) {
                if (!(e.size < 2) && 3 === e.data[0]) {
                    var t = 1,
                        i = this.id3utf8ArrayToStr(e.data.subarray(1));
                    return t += i.length + 1, {
                        key: "WXXX",
                        description: i,
                        data: O.utf8arrayToStr(e.data.subarray(t))
                    }
                }
            }
            decodeTextFrame(e) {
                if (!(e.size < 2) && 3 === e.data[0]) {
                    var t = e.data.subarray(1);
                    return {
                        key: e.type,
                        data: this.id3utf8ArrayToStr(t)
                    }
                }
            }
            decodePrivFrame(e) {
                if (!(e.size < 2)) {
                    var t = this.id3utf8ArrayToStr(e.data);
                    return {
                        key: "PRIV",
                        info: t,
                        data: e.data.slice(t.length + 1)
                    }
                }
            }
            _extractID3Frame(e, t, i, r, n) {
                var s = r + i;
                let a;
                return s <= n ? a = {
                    type: t,
                    data: e.slice(r, s)
                } : this.logger.error(k, `id3 frame ${t} size ${i} exceeded ${n}`), a
            }
            _parseID3Frames(e, t, i) {
                let r, n, s, a;
                for (; t + 8 <= i;) {
                    if (!this.isID3Frame(e, t)) return void this.logger.error(k, `[id3] illegal id3 frame @ offset ${t}. skip this id3 tag`);
                    if (r = C.readUTF(e, t, 4), t += 4, "" === r) return;
                    if (0 === (n = C.readSynchSafeUint32(e.subarray(t, t + 4)))) return;
                    t += 4, e[t++], e[t++], s = t;
                    var o = this._extractID3Frame(e, r, n, s, i);
                    if (o) {
                        const e = this.decodeID3Frame(o);
                        this._frames.push(e)
                    }
                    if ("PRIV" === r)
                        if (53 === n && "com.apple.streaming.transportStreamTimestamp" === C.readUTF(e, t, 44)) {
                            t += 44, t += 4;
                            const i = 1 & e[t++];
                            this._hasTimeStamp = !0, a = ((e[t++] << 23) + (e[t++] << 15) + (e[t++] << 7) + e[t++]) / 45, i && (a += 47721858.84), a = Math.round(a), this._timeStamp = a
                        } else 45 <= n && "com.apple.streaming.audioDescription" === C.readUTF(e, t, 36) ? (t += 37, this._audioType = C.readUTF(e, t, 4), t += 4, t += n - 41) : t += n;
                    else t += n
                }
            }
            id3utf8ArrayToStr(e) {
                let t, i, r = "",
                    n = 0;
                const s = e.length;
                for (; n < s;) {
                    const s = e[n++];
                    switch (s >> 4) {
                        case 0:
                            return r;
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                        case 6:
                        case 7:
                            r += String.fromCharCode(s);
                            break;
                        case 12:
                        case 13:
                            t = e[n++], r += String.fromCharCode((31 & s) << 6 | 63 & t);
                            break;
                        case 14:
                            t = e[n++], i = e[n++], r += String.fromCharCode((15 & s) << 12 | (63 & t) << 6 | (63 & i) << 0)
                    }
                }
            }
            get hasTimeStamp() {
                return this._hasTimeStamp
            }
            get timeStamp() {
                return this._timeStamp
            }
            get audioType() {
                return this._audioType
            }
            get length() {
                return this._length
            }
            get payload() {
                return this._payload
            }
            get frames() {
                return this._frames
            }
            get minor() {
                return this._minor
            }
            get revision() {
                return this._revision
            }
        }
        var M = C;
        const U = {
            name: "AACDemuxer"
        };
        class K extends c {
            resetInitSegment(e, t) {
                this.audioConfig = void 0, this.audioTrack = void 0, this.duration = t
            }
            static probe(e, t) {
                let i, r;
                for (i = new M(e, t).length, r = Math.min(e.length - 1, i + 100); i < r; i++)
                    if (255 === e[i] && 240 == (246 & e[i + 1])) return !0;
                return !1
            }
            append(e, t, i, r, n) {
                var s = new M(e, this.logger),
                    a = s.hasTimeStamp ? 90 * s.timeStamp : 9e4 * t;
                let o, l, d, u, c, h, p, f, m, g;
                for (s.length && (g = s.payload, s.frames.length && (m = s.frames), f = {
                        id3Samples: [{
                            pts: a,
                            dts: a,
                            data: g,
                            frames: m
                        }],
                        inputTimescale: 9e4
                    }), d = s.length, h = e.length; d < h - 1 && (255 !== e[d] || 240 != (246 & e[d + 1])); d++);
                if (!this.audioConfig && (this.audioConfig = E(this.observer, e, d, void 0, this.logger), !this.audioConfig)) throw "failed to parse adts config";
                if (!this.audioTrack) {
                    const e = {
                            id: 258,
                            inputTimescale: 9e4,
                            timescale: NaN,
                            duration: this.duration,
                            encrypted: !1,
                            keyTagInfo: n
                        },
                        t = {
                            len: 0,
                            sequenceNumber: 0,
                            esSamples: []
                        };
                    this.audioTrack = {
                        info: e,
                        parsingData: t,
                        type: "audio",
                        config: this.audioConfig
                    }
                }
                "zaac" !== s.audioType && "zach" !== s.audioType && "zacp" !== s.audioType || (this.audioTrack.info.encrypted = !0), l = 0;
                for (var y = 9216e4 / this.audioConfig.samplerate; d + 5 < h && (u = 1 & e[d + 1] ? 7 : 9, o = (3 & e[d + 3]) << 11 | e[d + 4] << 3 | (224 & e[d + 5]) >>> 5, o -= u, 0 < o && d + u + o <= h);)
                    for (c = a + l * y, p = {
                            unit: e.subarray(d + u, d + u + o),
                            pts: c,
                            dts: c,
                            keyTagInfo: n
                        }, this.audioTrack.parsingData.esSamples.push(p), this.audioTrack.parsingData.len += o, d += o + u, l++; d < h - 1; d++) {
                        if (M.isHeader(e, d)) {
                            const t = new M(e.subarray(d), this.logger);
                            if (0 < t.length) {
                                d += t.length;
                                const e = t.hasTimeStamp ? 90 * t.timeStamp : a;
                                f.id3Samples.push({
                                    pts: e,
                                    dts: e,
                                    data: t.payload,
                                    frames: t.frames
                                })
                            } else this.logger.error(U, `[id3] invalid length ${h}`)
                        }
                        if (255 === e[d] && 240 == (246 & e[d + 1])) break
                    }
                this.esRemuxer.remuxEsTracks(this.audioTrack, void 0, f, void 0, t, i, r, n)
            }
        }
        class q {
            bsReadAndUpdate(e, t, i) {
                e = this.readBits(e, t, i);
                return this.updateOffset(t, i), e
            }
            bsWriteAndUpdate(e, t, i, r) {
                r = this.writeBits(e, t, i, r);
                return this.updateOffset(t, i), r
            }
            bsSkip(e, t) {
                this.updateOffset(e, t)
            }
            readBits(i, r, n) {
                if (i && r) {
                    let t = r.byteOffset;
                    const s = r["usedBits"];
                    if (!(8 <= s || 32 < s + n)) {
                        let e;
                        const a = new Uint32Array(1),
                            o = new Uint32Array(1),
                            l = new Uint8Array(1);
                        if (!(8 <= s || 32 < n)) {
                            if (s) {
                                const r = 8 - s,
                                    a = n < r ? r - n : 0;
                                o[0] = 4278190080 >>> 32 - r, e = (i[t] & o[0]) >>> a, t += 1, n -= r
                            }
                            for (; 0 < n;) {
                                l[0] = i[t];
                                const r = Math.min(n, 8),
                                    s = 8 - r;
                                o[0] = 4278190080 >>> 24 + s << s, a[0] = (l[0] & o[0]) >> s, e = e ? e << r | a[0] : a[0], t += 1, n -= r
                            }
                            return e
                        }
                    }
                }
            }
            writeBits(t, i, r, n) {
                if (t && i) {
                    let e = i.byteOffset;
                    var i = i["usedBits"];
                    if (!(8 <= i || 32 < i + r)) {
                        const s = new Uint32Array(1),
                            a = new Uint32Array(1),
                            o = new Uint32Array(1),
                            l = new Uint8Array(1);
                        for (s[0] = n, i && (a[0] = s[0] << 32 - r, o[0] = 4278190080, l[0] = (a[0] & o[0]) >>> 24 + i, t[e] &= ~(o[0] >>> 24 + i), t[e] |= l[0], e += 1, r -= 8 - i); 0 < r;) {
                            a[0] = s[0] << 32 - r, o[0] = 4278190080, l[0] = (a[0] & o[0]) >>> 24;
                            const d = r < 0 ? 8 - r : 0;
                            t[e] &= ~(o[0] >>> 24 >>> d << d), t[e] |= l[0], r -= 8, e += 1
                        }
                        return 0
                    }
                }
            }
            updateOffset(e, t) {
                var i, r;
                !e || !t || 32 < e.usedBits + t || (i = e.usedBits % 8, r = Math.floor((i + t) / 8), t = (i + t) % 8, e.byteOffset += r, e.usedBits = t)
            }
        }

        function H(e, t) {
            return 1536 / e.samplerate * t
        }

        function j(e, t, i, r) {
            let n;
            if (i + 8 > t.length) return n = new D(!0, "error parsing ac-3, not enough data", $.InsufficientAC3Data), void e.trigger(x.INTERNAL_ERROR, n);
            if (11 !== t[i] || 119 !== t[i + 1]) return n = new D(!0, "invalid ac-3 magic", $.InvalidAC3Magic), void e.trigger(x.INTERNAL_ERROR, n);
            var s = t[i + 4] >> 6;
            if (3 <= s) return n = new D(!0, `invalid ac-3 samplingRateCode:${s}`, $.InvalidAC3SamplingRateCode), void e.trigger(x.INTERNAL_ERROR, n);
            var a = 63 & t[i + 4],
                o = t[i + 6] >> 5;
            let l = 0;
            2 == o ? l += 2 : (1 & o && 1 != o && (l += 2), 4 & o && (l += 2));
            var d = (t[i + 6] << 8 | t[i + 7]) >> 12 - l & 1,
                u = [2, 1, 2, 3, 3, 4, 4, 5][o] + d,
                e = t[i + 5] >> 3,
                i = 7 & t[i + 5];
            return {
                samplerate: W[s],
                channelCount: u,
                segmentCodec: "ac3",
                codec: "ac-3",
                extraData: s << 22 | e << 17 | i << 14 | o << 11 | d << 10 | a >> 1 << 5
            }
        }

        function Q(e, t, i) {
            let r;
            if (i + 8 > t.length) return r = new D(!0, "error parsing ac-3, not enough data", $.InsufficientAC3Data), void e.trigger(x.INTERNAL_ERROR, r);
            if (11 !== t[i] || 119 !== t[i + 1]) return r = new D(!0, "invalid ac-3 magic", $.InvalidAC3Magic), void e.trigger(x.INTERNAL_ERROR, r);
            var n = t[i + 4] >> 6;
            return 3 <= n ? (r = new D(!0, `invalid ac-3 samplingRateCode:${n}`, $.InvalidAC3SamplingRateCode), void e.trigger(x.INTERNAL_ERROR, r)) : (i = 63 & t[i + 4], 2 * G[3 * i + n])
        }
        const W = [48e3, 44100, 32e3],
            G = [64, 69, 96, 64, 70, 96, 80, 87, 120, 80, 88, 120, 96, 104, 144, 96, 105, 144, 112, 121, 168, 112, 122, 168, 128, 139, 192, 128, 140, 192, 160, 174, 240, 160, 175, 240, 192, 208, 288, 192, 209, 288, 224, 243, 336, 224, 244, 336, 256, 278, 384, 256, 279, 384, 320, 348, 480, 320, 349, 480, 384, 417, 576, 384, 418, 576, 448, 487, 672, 448, 488, 672, 512, 557, 768, 512, 558, 768, 640, 696, 960, 640, 697, 960, 768, 835, 1152, 768, 836, 1152, 896, 975, 1344, 896, 976, 1344, 1024, 1114, 1536, 1024, 1115, 1536, 1152, 1253, 1728, 1152, 1254, 1728, 1280, 1393, 1920, 1280, 1394, 1920];
        class z extends c {
            resetInitSegment(e, t) {
                this.audioConfig = void 0, this.audioTrack = void 0, this.duration = t
            }
            static probe(e, t) {
                var i = new M(e, t),
                    t = i.length;
                return !!(i.hasTimeStamp && 11 === e[t] && 119 === e[t + 1] && (new q).bsReadAndUpdate(e, {
                    byteOffset: t + 5,
                    usedBits: 0
                }, 5) < 16)
            }
            append(e, t, i, r, n) {
                var s = new M(e, this.logger),
                    a = 90 * s.timeStamp,
                    o = e.byteLength;
                let l = 0,
                    d = s.length;
                if (this.audioConfig || (this.audioConfig = j(this.observer, e, d, this.logger)), !this.audioConfig) throw "failed to parse ac3 config";
                if (!this.audioTrack) {
                    const e = {
                            id: 258,
                            inputTimescale: 9e4,
                            timescale: NaN,
                            duration: this.duration,
                            encrypted: !1,
                            keyTagInfo: n
                        },
                        t = {
                            len: 0,
                            sequenceNumber: 0,
                            esSamples: []
                        };
                    this.audioTrack = {
                        info: e,
                        parsingData: t,
                        type: "audio",
                        config: this.audioConfig
                    }
                }
                var u = H(this.audioConfig, this.audioTrack.info.inputTimescale);
                for ("zac3" === s.audioType && (this.audioTrack.info.encrypted = !0); d < o;) {
                    if (M.isHeader(e, d) && (d += new M(e.subarray(d), this.logger).length), 11 !== e[d] || 119 !== e[d + 1]) {
                        const e = new D(!0, "invalid ac-3 magic", $.InvalidAC3Magic);
                        return void this.observer.trigger(x.INTERNAL_ERROR, e)
                    }
                    const t = Q(this.observer, e, d),
                        i = a + l * u,
                        r = {
                            unit: e.subarray(d, d + t),
                            pts: i,
                            dts: i,
                            keyTagInfo: n
                        };
                    this.audioTrack.parsingData.esSamples.push(r), this.audioTrack.parsingData.len += t, d += t, l++
                }
                this.esRemuxer.remuxEsTracks(this.audioTrack, void 0, {
                    id3Samples: [{
                        pts: a,
                        dts: a,
                        data: s.payload,
                        frames: s.frames
                    }],
                    inputTimescale: this.audioTrack.info.inputTimescale
                }, void 0, t, i, r, n)
            }
        }
        var X = function(t, i, r, n) {
                const s = new q;
                let a, o = !1,
                    l = 0;
                for (; r < i.length;) {
                    if (r + 8 > i.length) return a = new D(!0, "error parsing ec-3, not enough data", $.InsufficientEC3Data), void t.trigger(x.INTERNAL_ERROR, a);
                    let e = 0;
                    if (M.isHeader(i, r) && (e = new M(i.subarray(r), n).length || 0, r += e), 11 !== i[r] || 119 !== i[r + 1]) return a = new D(!0, "invalid ec-3 magic", $.InvalidEC3Magic), void t.trigger(x.INTERNAL_ERROR, a);
                    var d = {
                            byteOffset: r + 2,
                            usedBits: 0
                        },
                        u = s.bsReadAndUpdate(i, d, 2),
                        c = s.bsReadAndUpdate(i, d, 3);
                    if (0 === u || 2 === u)
                        if (!0 === o) {
                            if (0 === c) break
                        } else o = !0;
                    else if (1 !== u) return a = new D(!0, "reserved stream type", $.ReservedStreamType), void t.trigger(x.INTERNAL_ERROR, a);
                    d = 2 * (s.bsReadAndUpdate(i, d, 11) + 1);
                    r += d, l += d + (e || 0)
                }
                return l
            },
            Y = function(t, i, r, n) {
                const s = {
                        frmsiz: 0,
                        fscod: 0,
                        numblkscod: 0,
                        acmod: 0,
                        lfeon: 0,
                        bsid: 0,
                        strmtyp: 0,
                        substreamid: 0,
                        chanmape: 0,
                        chanmap: 0,
                        mixdef: 0,
                        mixdeflen: 0,
                        bsmod: 0
                    },
                    a = {
                        fscod: 0,
                        acmod: 0,
                        lfeon: 0,
                        bsid: 0,
                        bsmod: 0,
                        chan_loc: 0,
                        data_rate: 0,
                        num_ind_sub: 0,
                        num_dep_sub: [],
                        complexity_index_type_a: 0
                    },
                    o = new q;
                let l, d = !1,
                    u = 0;
                for (; r < i.length;) {
                    if (r + 8 > i.length) return l = new D(!0, "error parsing ec-3, not enough data", $.InsufficientEC3Data), void t.trigger(x.INTERNAL_ERROR, l);
                    let e = 0;
                    if (M.isHeader(i, r) && (e = new M(i.subarray(r), n).length || 0, r += e), 11 !== i[r] || 119 !== i[r + 1]) return l = new D(!0, "invalid ec-3 magic", $.InvalidEC3Magic), void t.trigger(x.INTERNAL_ERROR, l);
                    const h = {
                        byteOffset: r + 2,
                        usedBits: 0
                    };
                    if (s.strmtyp = o.bsReadAndUpdate(i, h, 2), s.substreamid = o.bsReadAndUpdate(i, h, 3), 0 === s.strmtyp || 2 === s.strmtyp) {
                        if (!0 === d) {
                            if (0 === s.substreamid) break
                        } else d = !0;
                        a.num_ind_sub++, a.num_dep_sub.push(0)
                    } else {
                        if (1 !== s.strmtyp) return l = new D(!0, "reserved stream type", $.ReservedStreamType), void t.trigger(x.INTERNAL_ERROR, l);
                        a.num_dep_sub[a.num_ind_sub - 1]++
                    }
                    if (s.frmsiz = o.bsReadAndUpdate(i, h, 11), s.fscod = o.bsReadAndUpdate(i, h, 2), 3 === s.fscod ? (o.bsSkip(h, 2), s.numblkscod = 3) : s.numblkscod = o.bsReadAndUpdate(i, h, 2), s.acmod = o.bsReadAndUpdate(i, h, 3), s.lfeon = o.bsReadAndUpdate(i, h, 1), s.bsid = o.bsReadAndUpdate(i, h, 5), o.bsSkip(h, 5), o.bsReadAndUpdate(i, h, 1) && o.bsSkip(h, 8), 0 === s.acmod && (o.bsSkip(h, 5), o.bsReadAndUpdate(i, h, 1) && o.bsSkip(h, 8)), 1 === s.strmtyp && (s.chanmape = o.bsReadAndUpdate(i, h, 1), s.chanmape && (s.chanmap = o.bsReadAndUpdate(i, h, 16))), o.bsReadAndUpdate(i, h, 1) && (2 < s.acmod && o.bsSkip(h, 2), 1 & s.acmod && 2 < s.acmod && o.bsSkip(h, 6), 4 & s.acmod && o.bsSkip(h, 6), s.lfeon && o.bsReadAndUpdate(i, h, 1) && o.bsSkip(h, 5), 0 === s.strmtyp)) {
                        if (o.bsReadAndUpdate(i, h, 1) && o.bsSkip(h, 6), 0 === s.acmod && o.bsReadAndUpdate(i, h, 1) && o.bsSkip(h, 6), o.bsReadAndUpdate(i, h, 1) && o.bsSkip(h, 6), s.mixdef = o.bsReadAndUpdate(i, h, 2), 1 === s.mixdef) o.bsSkip(h, 5);
                        else if (2 === s.mixdef) o.bsSkip(h, 12);
                        else if (3 === s.mixdef) {
                            s.mixdeflen = o.bsReadAndUpdate(i, h, 5), o.bsReadAndUpdate(i, h, 1) && (o.bsSkip(h, 5), o.bsReadAndUpdate(i, h, 1) && o.bsSkip(h, 4), o.bsReadAndUpdate(i, h, 1) && o.bsSkip(h, 4), o.bsReadAndUpdate(i, h, 1) && o.bsSkip(h, 4), o.bsReadAndUpdate(i, h, 1) && o.bsSkip(h, 4), o.bsReadAndUpdate(i, h, 1) && o.bsSkip(h, 4), o.bsReadAndUpdate(i, h, 1) && o.bsSkip(h, 4), o.bsReadAndUpdate(i, h, 1) && o.bsSkip(h, 4), o.bsReadAndUpdate(i, h, 1) && (o.bsReadAndUpdate(i, h, 1) && o.bsSkip(h, 4), o.bsReadAndUpdate(i, h, 1) && o.bsSkip(h, 4))), o.bsReadAndUpdate(i, h, 1) && (o.bsSkip(h, 5), o.bsReadAndUpdate(i, h, 1) && (o.bsSkip(h, 7), o.bsReadAndUpdate(i, h, 1) && o.bsSkip(h, 8)));
                            const t = s.mixdeflen + 2 + (h.usedBits ? 1 : 0);
                            h.byteOffset += t
                        }
                        if (s.acmod < 2 && (o.bsReadAndUpdate(i, h, 1) && o.bsSkip(h, 14), 0 === s.acmod && o.bsReadAndUpdate(i, h, 1) && o.bsSkip(h, 14)), o.bsReadAndUpdate(i, h, 1))
                            if (0 === s.numblkscod) o.bsSkip(h, 5);
                            else
                                for (let e = 0; e < s.numblkscod; e++) o.bsReadAndUpdate(i, h, 1) && o.bsSkip(h, 5)
                    }
                    if (s.bsmod = 0, o.bsReadAndUpdate(i, h, 1) && (s.bsmod = o.bsReadAndUpdate(i, h, 3), o.bsSkip(h, 2), 2 === s.acmod && o.bsSkip(h, 4), 6 <= s.acmod && o.bsSkip(h, 2), o.bsReadAndUpdate(i, h, 1) && o.bsSkip(h, 8), 0 === s.acmod && o.bsReadAndUpdate(i, h, 1) && o.bsSkip(h, 8), s.fscod < 3 && o.bsSkip(h, 1)), 0 === s.strmtyp && 3 !== s.numblkscod && o.bsSkip(h, 1), 2 !== s.strmtyp || (3 === s.numblkscod ? 1 : o.bsReadAndUpdate(i, h, 1)) && o.bsReadAndUpdate(i, h, 6), o.bsReadAndUpdate(i, h, 1)) {
                        const t = o.bsReadAndUpdate(i, h, 6);
                        if (0 === s.strmtyp && 0 === s.substreamid && 1 === t) {
                            const t = o.bsReadAndUpdate(i, h, 7),
                                r = o.bsReadAndUpdate(i, h, 1),
                                n = o.bsReadAndUpdate(i, h, 8);
                            0 === t && 1 === r && 1 <= n && n <= 16 && (a.complexity_index_type_a = n)
                        }
                    }
                    if (s.chanmape) a.chan_loc |= s.chanmap;
                    else {
                        const t = [40960, 16384, 40960, 57344, 41472, 57856, 47104, 63488];
                        a.chan_loc |= t[s.acmod]
                    }
                    0 === s.strmtyp && (a.fscod = s.fscod, a.bsid = s.bsid, a.bsmod = s.bsmod, a.acmod = s.acmod, a.lfeon = s.lfeon), a.chan_loc |= s.lfeon ? 1 : 0;
                    const p = 2 * (s.frmsiz + 1);
                    r += p, u += p + (e || 0)
                }
                let c = 0;
                for (let e = 0; e < 16; e++) a.chan_loc & 1 << e && c++;
                a.lfeon && c++;
                let h = 10 + 3 * a.num_ind_sub;
                const p = [48e3, 44100, 32e3][a.fscod];
                a.data_rate = p / 1536 * u * 8, h = 10 + 3 * a.num_ind_sub;
                for (let e = 0; e < a.num_ind_sub; e++) 0 < a.num_dep_sub[e] && h++;
                0 < a.complexity_index_type_a && (h += 2);
                var f = new Uint8Array(h),
                    m = {
                        byteOffset: 0,
                        usedBits: 0
                    };
                o.bsWriteAndUpdate(f, m, 32, h), o.bsWriteAndUpdate(f, m, 32, 1684366131), o.bsWriteAndUpdate(f, m, 13, a.data_rate), o.bsWriteAndUpdate(f, m, 3, a.num_ind_sub);
                for (let e = 0; e < a.num_ind_sub; e++) o.bsWriteAndUpdate(f, m, 2, a.fscod), o.bsWriteAndUpdate(f, m, 5, a.bsid), o.bsWriteAndUpdate(f, m, 1, 0), o.bsWriteAndUpdate(f, m, 1, 0 === e ? 0 : 1), o.bsWriteAndUpdate(f, m, 3, a.bsmod), o.bsWriteAndUpdate(f, m, 3, a.acmod), o.bsWriteAndUpdate(f, m, 1, a.lfeon), o.bsWriteAndUpdate(f, m, 3, 0), o.bsWriteAndUpdate(f, m, 4, a.num_dep_sub[e]), 0 < a.num_dep_sub[e] ? o.bsWriteAndUpdate(f, m, 9, a.chan_loc) : o.bsWriteAndUpdate(f, m, 1, 0);
                return 0 < a.complexity_index_type_a && (o.bsWriteAndUpdate(f, m, 7, 0), o.bsWriteAndUpdate(f, m, 1, 1), o.bsWriteAndUpdate(f, m, 8, a.complexity_index_type_a)), {
                    samplerate: p,
                    channelCount: c,
                    segmentCodec: "ec3",
                    codec: "ec-3",
                    extraDataBytes: f
                }
            };
        class J extends c {
            resetInitSegment(e, t) {
                this.audioConfig = void 0, this.audioTrack = void 0, this.duration = t
            }
            static probe(e, t) {
                var i = new M(e, t),
                    t = i.length;
                return !(!i.hasTimeStamp || 11 !== e[t] || 119 !== e[t + 1] || 16 !== (new q).bsReadAndUpdate(e, {
                    byteOffset: t + 5,
                    usedBits: 0
                }, 5))
            }
            append(e, t, i, r, n) {
                var s = new M(e, this.logger),
                    a = 90 * s.timeStamp,
                    o = e.length;
                let l = 0,
                    d = s.length;
                if (this.audioConfig || (this.audioConfig = Y(this.observer, e, d, this.logger)), !this.audioConfig) throw "failed to parse ec-3 config";
                if (!this.audioTrack) {
                    const e = {
                            id: 258,
                            inputTimescale: 9e4,
                            timescale: NaN,
                            duration: this.duration,
                            encrypted: !1,
                            keyTagInfo: n
                        },
                        t = {
                            len: 0,
                            sequenceNumber: 0,
                            esSamples: []
                        };
                    this.audioTrack = {
                        info: e,
                        parsingData: t,
                        type: "audio",
                        config: this.audioConfig
                    }
                }
                var u = H(this.audioConfig, this.audioTrack.info.inputTimescale);
                for ("zec3" === s.audioType && (this.audioTrack.info.encrypted = !0); d < o;) {
                    const t = X(this.observer, e, d, this.logger),
                        i = a + l * u,
                        r = {
                            unit: e.subarray(d, d + t),
                            pts: i,
                            dts: i,
                            keyTagInfo: n
                        };
                    this.audioTrack.parsingData.esSamples.push(r), this.audioTrack.parsingData.len += t, d += t, l++
                }
                this.esRemuxer.remuxEsTracks(this.audioTrack, void 0, {
                    id3Samples: [{
                        pts: a,
                        dts: a,
                        data: s.payload,
                        frames: s.frames
                    }],
                    inputTimescale: this.audioTrack.info.inputTimescale
                }, void 0, t, i, r, n)
            }
        }
        const Z = {
            BitratesMap: [32, 64, 96, 128, 160, 192, 224, 256, 288, 320, 352, 384, 416, 448, 32, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 384, 32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 32, 48, 56, 64, 80, 96, 112, 128, 144, 160, 176, 192, 224, 256, 8, 16, 24, 32, 40, 48, 56, 64, 80, 96, 112, 128, 144, 160],
            SamplingRateMap: [44100, 48e3, 32e3, 22050, 24e3, 16e3, 11025, 12e3, 8e3],
            SamplesCoefficients: [
                [0, 72, 144, 12],
                [0, 0, 0, 0],
                [0, 72, 144, 12],
                [0, 144, 144, 12]
            ],
            BytesInSlot: [0, 1, 1, 4],
            onFrame: function(e, t, i, r, n, s, a) {
                r = a + s * (10368e4 / r);
                e.esSamples.push({
                    unit: t,
                    pts: r,
                    dts: r
                }), e.len += t.length
            },
            onNoise: function(e, t) {
                t.warn("mpeg audio has noise: " + e.length + " bytes")
            },
            parseFrames: function(e, t, i, r, n, s, a) {
                if (r < i + 2) return -1;
                if (255 === t[i] || 224 == (224 & t[i + 1])) {
                    if (r < i + 24) return -1;
                    const a = t[i + 1] >> 3 & 3,
                        c = t[i + 1] >> 1 & 3,
                        h = t[i + 2] >> 4 & 15,
                        p = t[i + 2] >> 2 & 3,
                        f = !!(2 & t[i + 2]);
                    if (1 != a && 0 != h && 15 != h && 3 != p) {
                        var o = 1e3 * [32, 64, 96, 128, 160, 192, 224, 256, 288, 320, 352, 384, 416, 448, 32, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 384, 32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 32, 48, 56, 64, 80, 96, 112, 128, 144, 160, 176, 192, 224, 256, 8, 16, 24, 32, 40, 48, 56, 64, 80, 96, 112, 128, 144, 160][14 * (3 == a ? 3 - c : 3 == c ? 3 : 4) + h - 1],
                            l = [44100, 48e3, 32e3, 22050, 24e3, 16e3, 11025, 12e3, 8e3][3 * (3 == a ? 0 : 2 == a ? 1 : 2) + p],
                            d = f ? 1 : 0,
                            u = t[i + 3] >> 6 == 3 ? 1 : 2,
                            d = 3 == c ? (3 == a ? 12 : 6) * o / l + d << 2 : (3 == a ? 144 : 72) * o / l + d | 0;
                        return r < i + d ? -1 : (Z.onFrame(e, t.subarray(i, i + d), o, l, u, n, s), d)
                    }
                }
                let c = i + 2;
                for (; c < r;) {
                    if (255 === t[c - 1] && 224 == (224 & t[c])) return Z.onNoise(t.subarray(i, c - 1), a), c - i - 1;
                    c++
                }
                return -1
            },
            parse: function(e, t, i, r, n) {
                var s = t.length;
                let a, o = 0;
                for (; i < s && 0 < (a = Z.parseFrames(e, t, i, s, o++, r, n));) i += a
            },
            getAudioConfig: function(e, t) {
                var i = e[t + 1] >> 3 & 3,
                    r = e[t + 1] >> 1 & 3,
                    n = e[t + 2] >> 4 & 15,
                    s = e[t + 2] >> 2 & 3,
                    a = e[t + 2] >> 1 & 1;
                if (1 != i && 0 != n && 15 != n && 3 != s) {
                    var o = 3 == i ? 3 - r : 3 == r ? 3 : 4,
                        o = 1e3 * Z.BitratesMap[14 * o + n - 1],
                        n = 3 == i ? 0 : 2 == i ? 1 : 2,
                        s = Z.SamplingRateMap[3 * n + s],
                        t = e[t + 3] >> 6 == 3 ? 1 : 2,
                        i = Z.SamplesCoefficients[i][r],
                        r = Z.BytesInSlot[r];
                    return {
                        segmentCodec: "mp3",
                        codec: "mp3",
                        samplerate: s,
                        channelCount: t,
                        frameLength: parseInt(i * o / s + a, 10) * r
                    }
                }
            },
            isHeaderPattern: function(e, t) {
                return 255 === e[t] && 224 == (224 & e[t + 1]) && 0 != (6 & e[t + 1])
            },
            probe: function(t, i) {
                if (i + 1 < t.length && Z.isHeaderPattern(t, i)) {
                    var r = Z.getAudioConfig(t, i);
                    let e = 4;
                    r && r.frameLength && (e = r.frameLength);
                    i = i + e;
                    if (i === t.length || i + 1 < t.length && Z.isHeaderPattern(t, i)) return !0
                }
                return !1
            }
        };
        var ee = Z;
        const te = {
            name: "MP3Demuxer"
        };
        class ie extends c {
            resetInitSegment(e, t) {
                this.audioConfig = void 0, this.audioTrack = void 0, this.duration = t
            }
            static probe(e, t) {
                var i = new M(e, t);
                let r, n;
                if (i.hasTimeStamp)
                    for (r = i.length, n = Math.min(e.length - 1, r + 100); r < n; r++)
                        if (ee.probe(e, r)) return t.warn(te, "MPEG Audio sync word found !"), !0;
                return !1
            }
            append(e, t, i, r, n) {
                var s = new M(e, this.logger),
                    a = 90 * s.timeStamp;
                if (this.audioConfig || (this.audioConfig = ee.getAudioConfig(e, s.length)), !this.audioConfig) throw "unable to parse mp3 header";
                if (!this.audioTrack) {
                    const e = {
                            id: 258,
                            inputTimescale: 9e4,
                            timescale: NaN,
                            duration: this.duration,
                            encrypted: !1,
                            keyTagInfo: n
                        },
                        t = {
                            len: 0,
                            sequenceNumber: 0,
                            esSamples: []
                        };
                    this.audioTrack = {
                        info: e,
                        parsingData: t,
                        type: "audio",
                        config: this.audioConfig
                    }
                }
                ee.parse(this.audioTrack.parsingData, e, s.length, a, this.logger), this.esRemuxer.remuxEsTracks(this.audioTrack, void 0, {
                    id3Samples: [{
                        pts: a,
                        dts: a,
                        data: s.payload,
                        frames: s.frames
                    }],
                    inputTimescale: 9e4
                }, void 0, t, i, r)
            }
        }

        function re(e, t) {
            if ("mp4a.40.2" === e) {
                if (1 === t) return new Uint8Array([0, 200, 0, 128, 35, 128]);
                if (2 === t) return new Uint8Array([33, 0, 73, 144, 2, 25, 0, 35, 128]);
                if (3 === t) return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 142]);
                if (4 === t) return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 128, 44, 128, 8, 2, 56]);
                if (5 === t) return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 130, 48, 4, 153, 0, 33, 144, 2, 56]);
                if (6 === t) return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 130, 48, 4, 153, 0, 33, 144, 2, 0, 178, 0, 32, 8, 224])
            } else {
                if (1 === t) return new Uint8Array([1, 64, 34, 128, 163, 78, 230, 128, 186, 8, 0, 0, 0, 28, 6, 241, 193, 10, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 94]);
                if (2 === t) return new Uint8Array([1, 64, 34, 128, 163, 94, 230, 128, 186, 8, 0, 0, 0, 0, 149, 0, 6, 241, 161, 10, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 94]);
                if (3 === t) return new Uint8Array([1, 64, 34, 128, 163, 94, 230, 128, 186, 8, 0, 0, 0, 0, 149, 0, 6, 241, 161, 10, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 94])
            }
            return null
        }

        function ne(e) {
            return "number" == typeof e && isFinite(e)
        }

        function se(e, t) {
            return ne(e) ? e.toFixed(t) : `${e}`
        }

        function ae(e, i = 3) {
            return JSON.stringify(e, (e, t) => !isNaN(t) && null != t && t.toFixed ? Number(null == t ? void 0 : t.toFixed(i)) : t)
        }
        let oe = !0;

        function le(e) {
            return oe ? "<redacted>" : e
        }

        function de(e) {
            if (!e) return e;
            if ("object" != typeof e) return e; {
                if (Array.isArray(e)) return e.map(de);
                const r = {};
                for (var [t, i] of Object.entries(e)) r[t] = de(i);
                return r
            }
        }

        function ue(e) {
            const t = [...e];
            for (let e = 0; e < t.length; e++) t[e] = Object.assign({}, t[e]), t[e].url = le(t[e].url), t[e].attrs && (t[e].attrs = Object.assign({}, t[e].attrs), t[e].attrs.URI = le(t[e].attrs.URI));
            return t
        }

        function ce(e) {
            const t = [...e];
            for (let e = 0; e < t.length; e++) t[e] = Object.assign({}, t[e]), t[e].url = le(t[e].url);
            return t
        }
        const he = Math.pow(2, 32) - 1;
        class pe {
            static init() {
                let e;
                for (e in pe.types = {
                        avc1: [],
                        avcC: [],
                        btrt: [],
                        dinf: [],
                        dref: [],
                        esds: [],
                        free: [],
                        ftyp: [],
                        hdlr: [],
                        mdat: [],
                        mdhd: [],
                        mdia: [],
                        mfhd: [],
                        minf: [],
                        moof: [],
                        moov: [],
                        mp4a: [],
                        ".mp3": [],
                        dac3: [],
                        "ac-3": [],
                        dec3: [],
                        "ec-3": [],
                        mvex: [],
                        mvhd: [],
                        pasp: [],
                        sdtp: [],
                        stbl: [],
                        stco: [],
                        stsc: [],
                        stsd: [],
                        stsz: [],
                        stts: [],
                        tfdt: [],
                        tfhd: [],
                        traf: [],
                        trak: [],
                        trun: [],
                        trex: [],
                        tkhd: [],
                        vmhd: [],
                        smhd: [],
                        uuid: [],
                        encv: [],
                        enca: [],
                        frma: [],
                        schm: [],
                        schi: [],
                        senc: [],
                        saio: [],
                        saiz: [],
                        sinf: [],
                        tenc: [],
                        sbgp: [],
                        seig: [],
                        sgpd: [],
                        pssh: []
                    }, pe.types) pe.types.hasOwnProperty(e) && (pe.types[e] = [e.charCodeAt(0), e.charCodeAt(1), e.charCodeAt(2), e.charCodeAt(3)]);
                var t = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 118, 105, 100, 101, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 86, 105, 100, 101, 111, 72, 97, 110, 100, 108, 101, 114, 0]),
                    i = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 115, 111, 117, 110, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 83, 111, 117, 110, 100, 72, 97, 110, 100, 108, 101, 114, 0]);
                pe.HDLR_TYPES = {
                    video: t,
                    audio: i
                };
                var r = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 12, 117, 114, 108, 32, 0, 0, 0, 1]),
                    n = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0]);
                pe.STTS = pe.STSC = pe.STCO = n, pe.STSZ = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]), pe.VMHD = new Uint8Array([0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0]), pe.SMHD = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0]), pe.STSD = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1]);
                t = new Uint8Array([105, 115, 111, 109]), i = new Uint8Array([97, 118, 99, 49]), n = new Uint8Array([0, 0, 0, 1]);
                pe.FTYP = pe.box(pe.types.ftyp, t, n, t, i), pe.DINF = pe.box(pe.types.dinf, pe.box(pe.types.dref, r))
            }
            static set16(e, t, i) {
                return t[i] = e >> 8 & 255, t[i + 1] = 255 & e, i + 2
            }
            static set32(e, t, i) {
                return t[i] = e >> 24 & 255, t[i + 1] = e >> 16 & 255, t[i + 2] = e >> 8 & 255, t[i + 3] = 255 & e, i + 4
            }
            static box(e) {
                var t = Array.prototype.slice.call(arguments, 1);
                let i = 8,
                    r = t.length;
                for (var n = r; r--;) i += t[r].byteLength;
                const s = new Uint8Array(i);
                for (s[0] = i >> 24 & 255, s[1] = i >> 16 & 255, s[2] = i >> 8 & 255, s[3] = 255 & i, s.set(e, 4), r = 0, i = 8; r < n; r++) s.set(t[r], i), i += t[r].byteLength;
                return s
            }
            static hdlr(e) {
                return pe.box(pe.types.hdlr, pe.HDLR_TYPES[e])
            }
            static mdat(e) {
                return pe.box(pe.types.mdat, e)
            }
            static mdhd(e, t) {
                t *= e;
                var i = Math.floor(t / (1 + he)),
                    t = Math.floor(t % (1 + he));
                return pe.box(pe.types.mdhd, new Uint8Array([1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 3, e >> 24 & 255, e >> 16 & 255, e >> 8 & 255, 255 & e, i >> 24, i >> 16 & 255, i >> 8 & 255, 255 & i, t >> 24, t >> 16 & 255, t >> 8 & 255, 255 & t, 85, 196, 0, 0]))
            }
            static mdia(e) {
                var t = pe.mdhd(e.info.timescale, e.info.duration),
                    i = pe.hdlr(e.type),
                    e = pe.minf(e);
                return pe.box(pe.types.mdia, t, i, e)
            }
            static mfhd(e) {
                return pe.box(pe.types.mfhd, new Uint8Array([0, 0, 0, 0, e >> 24, e >> 16 & 255, e >> 8 & 255, 255 & e]))
            }
            static minf(e) {
                return "audio" === e.type ? pe.box(pe.types.minf, pe.box(pe.types.smhd, pe.SMHD), pe.DINF, pe.stbl(e)) : pe.box(pe.types.minf, pe.box(pe.types.vmhd, pe.VMHD), pe.DINF, pe.stbl(e))
            }
            static moof(e, t) {
                pe.types || pe.init();
                e = pe.traf(t, e);
                return pe.box(pe.types.moof, pe.mfhd(t.sequenceNumber), e)
            }
            static moov(e) {
                let t = e.length;
                const i = [];
                for (; t--;) i[t] = pe.trak(e[t]);
                return pe.box.apply(null, [pe.types.moov, pe.mvhd(e[0].info.timescale, e[0].info.duration)].concat(i).concat(pe.mvex(e)))
            }
            static mvex(e) {
                let t = e.length;
                const i = [];
                for (; t--;) i[t] = pe.trex(e[t]);
                return pe.box(pe.types.mvex, ...i)
            }
            static mvhd(e, t) {
                t *= e;
                var i = Math.floor(t / (1 + he)),
                    t = Math.floor(t % (1 + he)),
                    t = new Uint8Array([1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 3, e >> 24 & 255, e >> 16 & 255, e >> 8 & 255, 255 & e, i >> 24, i >> 16 & 255, i >> 8 & 255, 255 & i, t >> 24, t >> 16 & 255, t >> 8 & 255, 255 & t, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 255, 255, 255]);
                return pe.box(pe.types.mvhd, t)
            }
            static sdtp(e) {
                const t = e.samples || [],
                    i = new Uint8Array(4 + t.length);
                let r, n;
                for (n = 0; n < t.length; n++) r = t[n].flags, i[n + 4] = r.dependsOn << 4 | r.isDependedOn << 2 | r.hasRedundancy;
                return pe.box(pe.types.sdtp, i)
            }
            static stbl(e) {
                var t = pe.stsd(e),
                    i = pe.box(pe.types.stts, pe.STTS),
                    r = pe.box(pe.types.stsc, pe.STSC),
                    n = pe.box(pe.types.stsz, pe.STSZ),
                    e = pe.box(pe.types.stco, pe.STCO);
                return pe.box(pe.types.stbl, t, i, r, n, e)
            }
            static avc1(e) {
                let t, i, r, n = [],
                    s = [];
                var a = e.info.encrypted ? pe.types.encv : pe.types.avc1;
                for (t = 0; t < e.config.sps.length; t++) i = e.config.sps[t], r = i.byteLength, n.push(r >>> 8 & 255), n.push(255 & r), n = n.concat(Array.prototype.slice.call(i));
                for (t = 0; t < e.config.pps.length; t++) i = e.config.pps[t], r = i.byteLength, s.push(r >>> 8 & 255), s.push(255 & r), s = s.concat(Array.prototype.slice.call(i));
                var o = pe.box(pe.types.avcC, new Uint8Array([1, n[3], n[4], n[5], 255, 224 | e.config.sps.length].concat(n).concat([e.config.pps.length]).concat(s))),
                    l = e.config.width,
                    d = e.config.height,
                    u = e.config.pixelRatio[0],
                    c = e.config.pixelRatio[1],
                    h = e.info.encrypted && e.info.keyTagInfo ? pe.sinf(e.info.keyTagInfo, e.type, pe.types.avc1) : new Uint8Array;
                return pe.box(a, new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, l >> 8 & 255, 255 & l, d >> 8 & 255, 255 & d, 0, 72, 0, 0, 0, 72, 0, 0, 0, 0, 0, 0, 0, 1, 18, 100, 97, 105, 108, 121, 109, 111, 116, 105, 111, 110, 47, 104, 108, 115, 46, 106, 115, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 17, 17]), o, h, pe.box(pe.types.btrt, new Uint8Array([0, 28, 156, 128, 0, 45, 198, 192, 0, 45, 198, 192])), pe.box(pe.types.pasp, new Uint8Array([u >> 24, u >> 16 & 255, u >> 8 & 255, 255 & u, c >> 24, c >> 16 & 255, c >> 8 & 255, 255 & c])))
            }
            static esds(e) {
                var t = e.esdsConfig.length;
                return new Uint8Array([0, 0, 0, 0, 3, 23 + t, 0, 1, 0, 4, 15 + t, 64, 21, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5].concat([t]).concat(e.esdsConfig).concat([6, 1, 2]))
            }
            static audioStsd(e) {
                var t = e.samplerate;
                return new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, e.channelCount, 0, 16, 0, 0, 0, 0, t >> 8 & 255, 255 & t, 0, 0])
            }
            static dac3(e) {
                e = e.extraData;
                return new Uint8Array([e >> 16 & 255, e >> 8 & 255, 255 & e])
            }
            static dec3(e) {
                return e.extraDataBytes
            }
            static mp4a(e, t) {
                let i = pe.types.mp4a,
                    r = null;
                r = e.encrypted && e.keyTagInfo ? (i = pe.types.enca, pe.sinf(e.keyTagInfo, "audio", pe.types.mp4a)) : new Uint8Array;
                e = pe.audioStsd(t), t = pe.box(pe.types.esds, pe.esds(t));
                return pe.box(i, e, t, r)
            }
            static mp3(e) {
                return pe.box(pe.types[".mp3"], pe.audioStsd(e))
            }
            static ac3(e, t) {
                let i = pe.types["ac-3"],
                    r = null;
                return r = e.encrypted && e.keyTagInfo ? (i = pe.types.enca, pe.sinf(e.keyTagInfo, "audio", pe.types["ac-3"])) : new Uint8Array, pe.box(i, pe.audioStsd(t), pe.box(pe.types.dac3, pe.dac3(t)), r)
            }
            static ec3(e, t) {
                let i = pe.types["ec-3"],
                    r = null;
                return r = e.encrypted && e.keyTagInfo ? (i = pe.types.enca, pe.sinf(e.keyTagInfo, "audio", pe.types["ec-3"])) : new Uint8Array, pe.box(i, pe.audioStsd(t), pe.box(pe.types.dec3, pe.dec3(t)), r)
            }
            static stsd(e) {
                if ("audio" !== e.type) return pe.box(pe.types.stsd, pe.STSD, pe.avc1(e));
                if ("mp3" === e.config.segmentCodec && "mp3" === e.config.codec) return pe.box(pe.types.stsd, pe.STSD, pe.mp3(e.config));
                if ("ac3" === e.config.segmentCodec) return pe.box(pe.types.stsd, pe.STSD, pe.ac3(e.info, e.config));
                if ("ec3" === e.config.segmentCodec) return pe.box(pe.types.stsd, pe.STSD, pe.ec3(e.info, e.config));
                if ("aac" === e.config.segmentCodec) return pe.box(pe.types.stsd, pe.STSD, pe.mp4a(e.info, e.config));
                throw `unknown segmentCodec ${e.config.segmentCodec}`
            }
            static tkhd(e) {
                var t = e.info.id,
                    i = e.info.duration * e.info.timescale,
                    r = Math.floor(i / (1 + he)),
                    i = Math.floor(i % (1 + he));
                let n = 0,
                    s = 0;
                return "video" === e.type && (n = e.config.width, s = e.config.height), pe.box(pe.types.tkhd, new Uint8Array([1, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 3, t >> 24 & 255, t >> 16 & 255, t >> 8 & 255, 255 & t, 0, 0, 0, 0, r >> 24, r >> 16 & 255, r >> 8 & 255, 255 & r, i >> 24, i >> 16 & 255, i >> 8 & 255, 255 & i, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, n >> 8 & 255, 255 & n, 0, 0, s >> 8 & 255, 255 & s, 0, 0]))
            }
            static traf(e, t) {
                var i = pe.senc(e),
                    r = pe.sdtp(e),
                    n = i.boxData,
                    s = n.length ? pe.saio(76) : new Uint8Array,
                    a = n.length ? pe.saiz(i.defaultSampleInfoSize, i.sampleInfoSizes) : new Uint8Array,
                    o = pe.sbgp(e),
                    l = pe.sgpd(e),
                    d = e.id,
                    i = Math.floor(t / (1 + he)),
                    t = Math.floor(t % (1 + he));
                return pe.box(pe.types.traf, pe.box(pe.types.tfhd, new Uint8Array([0, 2, 0, 0, d >> 24, d >> 16 & 255, d >> 8 & 255, 255 & d])), pe.box(pe.types.tfdt, new Uint8Array([1, 0, 0, 0, i >> 24, i >> 16 & 255, i >> 8 & 255, 255 & i, t >> 24, t >> 16 & 255, t >> 8 & 255, 255 & t])), n, s, a, o, l, pe.trun(e, r.length + n.length + o.length + l.length + s.length + a.length + 16 + 20 + 8 + 16 + 8 + 8), r)
            }
            static trak(e) {
                if ("trakData" in e) return e.trakData;
                e.info.duration = e.info.duration || 4294967295;
                var t = pe.types.trak,
                    i = pe.tkhd(e),
                    e = pe.mdia(e);
                return pe.box(t, i, e)
            }
            static trex(e) {
                e = e.info.id;
                return pe.box(pe.types.trex, new Uint8Array([0, 0, 0, 0, e >> 24, e >> 16 & 255, e >> 8 & 255, 255 & e, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1]))
            }
            static trun(e, t) {
                const i = e.samples || [],
                    r = i.length,
                    n = 12 + 16 * r,
                    s = new Uint8Array(n);
                let a, o, l, d, u, c;
                for (t += 8 + n, s.set([0, 0, 15, 1, r >>> 24 & 255, r >>> 16 & 255, r >>> 8 & 255, 255 & r, t >>> 24 & 255, t >>> 16 & 255, t >>> 8 & 255, 255 & t], 0), a = 0; a < r; a++) l = (o = i[a]).duration, d = o.size, u = o.flags, c = o.cts, s.set([l >>> 24 & 255, l >>> 16 & 255, l >>> 8 & 255, 255 & l, d >>> 24 & 255, d >>> 16 & 255, d >>> 8 & 255, 255 & d, u.isLeading << 2 | u.dependsOn, u.isDependedOn << 6 | u.hasRedundancy << 4 | u.paddingValue << 1 | u.isNonSync, 61440 & u.degradPrio, 15 & u.degradPrio, c >>> 24 & 255, c >>> 16 & 255, c >>> 8 & 255, 255 & c], 12 + 16 * a);
                return pe.box(pe.types.trun, s)
            }
            static initSegment(e) {
                pe.types || pe.init();
                const t = pe.moov(e),
                    i = new Uint8Array(pe.FTYP.byteLength + t.byteLength);
                return i.set(pe.FTYP), i.set(t, pe.FTYP.byteLength), i
            }
            static saio(e) {
                e = e + 4 + 4;
                return pe.box(pe.types.saio, new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1, e >> 24 & 255, e >> 16 & 255, e >> 8 & 255, 255 & e]))
            }
            static saiz(e, t) {
                ne(e) || (e = 0);
                var i = t.length,
                    t = 0 === e ? new Uint8Array(t) : new Uint8Array;
                return pe.box(pe.types.saiz, new Uint8Array([0, 0, 0, 0, e, i >> 24 & 255, i >> 16 & 255, i >> 8 & 255, 255 & i]), t)
            }
            static senc(e) {
                const t = e.samples || [],
                    i = t.length;
                let r = 0,
                    n = NaN,
                    s = !0;
                const a = [];
                if (!e.encrypted || i <= 0) return {
                    boxData: new Uint8Array,
                    sampleInfoSizes: a,
                    defaultSampleInfoSize: 0
                };
                e = e.defaultPerSampleIVSize || 0;
                for (const d of t) d.subsamples && (r += d.subsamples.length);
                if (r <= 0) return {
                    boxData: new Uint8Array,
                    sampleInfoSizes: a,
                    defaultSampleInfoSize: 0
                };
                const o = new Uint8Array(2 * i + i * e + 6 * r + 4);
                let l = this.set32(i, o, 0);
                for (const d of t) {
                    const t = d.subsamples || [];
                    let e = 2;
                    d.iv && (o.set(d.iv, l), l += d.iv.byteLength, e += d.iv.byteLength), l = this.set16(t.length, o, l);
                    for (const d of t) l = this.set16(d[0], o, l), l = this.set32(d[1], o, l), e += 6;
                    a.push(e), ne(n) || (n = e), s = s && n === e, n = e
                }
                return {
                    boxData: pe.box(pe.types.senc, new Uint8Array([0, 0, 0, 2]), o),
                    defaultSampleInfoSize: s ? n : 0,
                    sampleInfoSizes: a
                }
            }
            static sinf(e, t, i) {
                return pe.box(pe.types.sinf, pe.frma(i), pe.schm(), pe.schi(e, t))
            }
            static frma(e) {
                return pe.box(pe.types.frma, new Uint8Array(e))
            }
            static schm() {
                return pe.box(pe.types.schm, new Uint8Array([0, 0, 0, 0, 99, 98, 99, 115, 0, 1, 0, 0]))
            }
            static schi(e, t) {
                return pe.box(pe.types.schi, pe.tenc(e, t))
            }
            static tenc(e, t) {
                let i = 0;
                "video" === t && (i = 25);
                const r = new Uint8Array(17);
                if (r[0] = 16, e.iv && 16 === e.iv.byteLength && r.set(e.iv, 1), !e.keyId) throw "tenc: no key id found in decryptdata";
                return pe.box(pe.types.tenc, new Uint8Array([1, 0, 0, 0, 0, i, 1, 0]), e.keyId, r)
            }
            static sbgp(e) {
                if (!e.encrypted || 0 === e.samples.length || !e.samples[0].keyTagInfo) return new Uint8Array;
                e = e.samples.length;
                return pe.box(pe.types.sbgp, new Uint8Array([0, 0, 0, 0]), new Uint8Array(pe.types.seig), new Uint8Array([0, 0, 0, 1, e >> 24 & 255, e >> 16 & 255, e >> 8 & 255, 255 & e, 0, 1, 0, 1]))
            }
            static sgpd(e) {
                if (!e.encrypted || 0 === e.samples.length || !e.samples[0].keyTagInfo) return new Uint8Array;
                var t = e.samples[0].keyTagInfo;
                let i = 0;
                "video" === e.type && (i = 25);
                const r = new Uint8Array(17);
                if (r[0] = 16, t.iv && r.set(t.iv, 1), !t.keyId) throw "sgpd: no keyid in decryptdata";
                return pe.box(pe.types.sgpd, new Uint8Array([1, 0, 0, 0]), new Uint8Array(pe.types.seig), new Uint8Array([0, 0, 0, 37, 0, 0, 0, 1]), new Uint8Array([0, i, 1, 0]), t.keyId, r)
            }
            static pssh(e, t, i) {
                if (pe.types || pe.init(), !e) throw new TypeError("Bad system id");
                if (16 !== e.byteLength) throw new RangeError("Invalid system id");
                let r, n, s;
                if (t) {
                    r = 1, n = new Uint8Array(16 * t.length);
                    for (let e = 0; e < t.length; e++) {
                        const i = t[e];
                        if (16 !== i.byteLength) throw new RangeError("Invalid key");
                        n.set(i, 16 * e)
                    }
                } else r = 0, n = new Uint8Array;
                0 < r ? (s = new Uint8Array(4), 0 < t.length && new DataView(s.buffer).setUint32(0, t.length, !1)) : s = new Uint8Array;
                var a = new Uint8Array(4);
                return i && 0 < i.byteLength && new DataView(a.buffer).setUint32(0, i.byteLength, !1), pe.box(pe.types.pssh, new Uint8Array([r, 0, 0, 0]), e, s, n, a, i || new Uint8Array)
            }
        }
        var fe, me, ge = pe;
        (vi = fe = fe || {})[vi.SDR = 0] = "SDR", vi[vi.HDR = 1] = "HDR", vi[vi.HDR10 = 2] = "HDR10", vi[vi.DolbyVision = 3] = "DolbyVision", vi[vi.HLG = 4] = "HLG", (bi = me = me || {})[bi.H264 = 16] = "H264", bi[bi.HEVC = 64] = "HEVC", bi[bi.VP09 = 65] = "VP09";
        const ye = new Set(["ac-3", "mp4a.a5", "mp4a.A5"]),
            ve = new Set(["ec-3", "mp4a.a6", "mp4a.A6"]),
            Se = {
                aac: 1024,
                mp3: 1024,
                ac3: 1536,
                ec3: 1536
            },
            be = {
                isAC3: e => Boolean(e && ye.has(e)),
                isEC3: e => Boolean(e && ve.has(e)),
                isDolbyAtmos(e, t) {
                    const i = t.split("/");
                    return Boolean(be.isEC3(e) && 1 < i.length && i[1].split(",").find(e => "JOC" === e))
                },
                isAAC(e) {
                    return Boolean(e && ("aac" === e || null !== (e = e.match(/^mp4a\.40\.(.*)/)) && "34" !== e[1]))
                },
                isMP3(e) {
                    return Boolean(e && ("mp3" === e || null !== (e = e.match(/^mp4a\.40\.(.*)/)) && "34" === e[1]))
                },
                isAVC: e => Boolean(e && e.match(/^avc[13]\.(.*)/)),
                isXHEAAC: function(e) {
                    return Boolean("mp4a.40.42" === e)
                },
                isALAC: function(e) {
                    return Boolean("alac" === e)
                },
                isFLAC: function(e) {
                    return Boolean("fLaC" === e)
                },
                isHEVC: e => Boolean(e && e.match(/^(hev|hvc)1\..*/)),
                isDolby: e => Boolean(e && e.match(/^dv(h1|he|a1|av)\..*/)),
                isVP09: e => Boolean(e && e.match(/^vp09\..*/)),
                isCompatibleCodecString(e, t) {
                    const i = e.split(","),
                        r = t.split(","),
                        n = i.filter(e => be.isVideoCodec(e)),
                        s = r.filter(e => be.isVideoCodec(e)),
                        a = i.filter(e => be.isAudioCodec(e)),
                        o = r.filter(e => be.isAudioCodec(e)),
                        l = 0 === n.length && 0 === s.length || n.length === s.length && be.isCompatibleVideoCodec(n[0], s[0]),
                        d = 0 === a.length && 0 === o.length || a.length === o.length && be.isCompatibleAudioCodec(a[0], o[0]);
                    return l && d
                },
                isVideoCodec: e => be.isAVC(e) || be.isDolby(e) || be.isHEVC(e) || be.isVP09(e),
                isAudioCodec: e => be.isAC3(e) || be.isEC3(e) || be.isAAC(e) || be.isMP3(e),
                isCompatibleVideoCodec: (e, t) => Boolean(e && t && (e === t || be.isDolby(e) && be.isDolby(t) || be.isHEVC(e) && be.isHEVC(t) || be.isAVC(e) && be.isAVC(t) || be.isVP09(e) && be.isVP09(t))),
                isCompatibleAudioCodec: (e, t) => Boolean(e && t && (e === t || be.isAAC(e) && be.isAAC(t) || be.isAC3(e) && be.isAC3(t) || be.isEC3(e) && be.isEC3(t) || be.isMP3(e) && be.isMP3(t))),
                getSegmentCodec(e) {
                    let t;
                    if (be.isAAC(e)) t = "aac";
                    else if (be.isAC3(e)) t = "ac3";
                    else if (be.isEC3(e)) t = "ec3";
                    else {
                        if ("mp3" !== e) throw new Error(`invalid audio config, codec ${e}`);
                        t = "mp3"
                    }
                    return t
                },
                getChannelCount(e) {
                    if (!e) return 0;
                    e = e.split("/"), e = parseInt(e[0]);
                    return ne(e) ? e : 0
                },
                avc1toavcoti(e) {
                    var t;
                    const i = e.split(".");
                    let r;
                    return 2 < i.length ? (r = i.shift() + ".", r += parseInt(null !== (t = i.shift()) && void 0 !== t ? t : "").toString(16), r += ("000" + parseInt(null !== (t = i.shift()) && void 0 !== t ? t : "").toString(16)).substr(-4)) : r = e, r
                },
                getDynamicRangeType(e, t) {
                    let i = fe.SDR;
                    return "PQ" === e && be.isDolby(t) ? i = fe.DolbyVision : "PQ" === e && (be.isHEVC(t) || be.isVP09(t)) ? i = fe.HDR10 : "HLG" !== e || -1 === t.indexOf("hvc1") && !be.isVP09(t) || (i = fe.HLG), i
                },
                getCompressionType(e) {
                    let t = me.H264;
                    return be.isHEVC(e) || be.isDolby(e) ? t = me.HEVC : be.isVP09(e) && (t = me.VP09), t
                },
                isHigherCodecByFamily(e, t) {
                    if (!e) return !0;
                    const i = e.split("."),
                        r = t.split(".");
                    if (i[0] !== r[0]) throw new Error(`mismatch in codec family current/new: ${i[0]}/${r[0]}`);
                    switch (i[0]) {
                        case "avc1":
                        case "avc3":
                            return r[1] > i[1];
                        case "vp09":
                            return e < t;
                        case "hvc1":
                        case "hev1":
                            var n = "H" === i[3].substring(0, 1) ? 1 : 0,
                                s = i[3].substring(1),
                                a = "H" === r[3].substring(0, 1) ? 1 : 0,
                                o = r[3].substring(1);
                            return r[1] > i[1] || r[2] > i[2] || n < a || s < o;
                        case "dvh1":
                            return r[1] > i[1] || r[2] > i[2]
                    }
                }
            };
        class Te {
            static getTrack(e, t, i, r, n) {
                let s;
                switch (be.getSegmentCodec(i)) {
                    case "aac":
                        var a;
                        (a = E(e, 1 === r ? new Uint8Array([255, 241, 92, 64, 1, 127, 252]) : new Uint8Array([255, 241, 92, 128, 1, 191, 252]), 0, i)) && (s = {
                            type: "audio",
                            info: {
                                id: t,
                                timescale: a.samplerate,
                                duration: 0,
                                encrypted: !1,
                                keyTagInfo: void 0
                            },
                            config: a
                        });
                        break;
                    case "ac3":
                    case "ec3": {
                        const i = j(e, new Uint8Array([11, 119, 69, 17, 128, 64, 47, 132]), 0);
                        i && (s = {
                            type: "audio",
                            info: {
                                id: t,
                                timescale: i.samplerate,
                                duration: 0,
                                encrypted: !1,
                                keyTagInfo: void 0
                            },
                            config: i
                        })
                    }
                }
                return s
            }
            static getSample(e, t) {
                let i;
                switch (e) {
                    case "mp4a.40.2":
                    case "mp4a.40.5":
                        i = 1 === t ? new Uint8Array([0, 208, 0, 7]) : new Uint8Array([33, 0, 3, 64, 104, 28]);
                        break;
                    case "ac-3":
                    case "ec-3":
                        i = new Uint8Array([11, 119, 69, 17, 128, 64, 47, 132, 41, 3, 253, 214, 124, 253, 243, 215, 233, 95, 185, 123, 78, 20, 40, 106, 97, 190, 74, 253, 43, 218, 208, 140, 191, 176, 144, 120, 214, 181, 44, 124, 129, 251, 91, 109, 187, 109, 198, 225, 43, 172, 116, 140, 176, 123, 38, 144, 211, 247, 225, 64, 29, 53, 175, 96, 16, 57, 121, 87, 78, 203, 81, 37, 7, 72, 228, 132, 37, 169, 38, 231, 97, 229, 247, 194, 208, 8, 12, 83, 74, 139, 137, 17, 22, 26, 221, 203, 107, 113, 94, 93, 75, 33, 208, 247, 146, 105, 39, 143, 6, 36, 1, 227, 108, 70, 11, 180, 152, 218, 182, 218, 209, 59, 85, 104, 201, 70, 37, 82, 219, 68, 55, 225, 144, 99, 149, 0, 119, 26, 14, 69, 164, 241, 204, 222, 81, 177, 142, 80, 20, 100, 97, 143, 101, 221, 140, 113, 31, 208, 124, 25, 64, 29, 49, 77, 140, 30, 155, 74, 214, 204, 138, 229, 109, 172, 95, 130, 70, 230, 134, 88, 59, 179, 212, 155, 232, 0, 0, 0, 0, 0, 173, 234])
                }
                return i
            }
            static getSegment(e, i, r, n) {
                if (e) {
                    var s = e.info["timescale"],
                        a = e.config["segmentCodec"],
                        o = Te.getSample(e.config.codec, e.config.channelCount);
                    if (o) {
                        const l = [],
                            d = {
                                id: e.info.id,
                                sequenceNumber: i,
                                type: "audio",
                                encrypted: !1,
                                samples: l,
                                defaultPerSampleIVSize: 0
                            },
                            u = Se[a],
                            c = Math.ceil(n * s / u),
                            h = {
                                baseTime: Math.round(c * u + r),
                                timescale: s
                            };
                        let t = 0;
                        const p = c * o.byteLength + 8,
                            f = new Uint8Array(p);
                        f[0] = p >> 24 & 255, f[1] = p >> 16 & 255, f[2] = p >> 8 & 255, f[3] = 255 & p, ge.types || ge.init(), f.set(ge.types.mdat, 4), t += 8;
                        for (let e = 0; e < c; e++) l.push({
                            duration: u,
                            size: o.byteLength,
                            cts: 0,
                            flags: {
                                isLeading: 0,
                                isDependedOn: 0,
                                hasRedundancy: 0,
                                degradPrio: 0,
                                dependsOn: 1,
                                isNonSync: 0,
                                paddingValue: 0
                            }
                        }), f.set(o, t), t += o.byteLength;
                        const m = ge.moof(r, d),
                            g = new Uint8Array(m.byteLength + f.byteLength);
                        return g.set(m), g.set(f, m.byteLength), {
                            silentFragData: g,
                            endTs: h
                        }
                    }
                }
            }
        }
        class Ee extends h {
            constructor(e, t, i, r, n) {
                super(e, t, n), this.typeSupported = i, this.isVideoContiguous = !1, this.logger = n.child({
                    name: "EsRemuxer"
                });
                const s = navigator.userAgent;
                this.isSafari = r && -1 < r.indexOf("Apple") && s && !s.match("CriOS")
            }
            resetTimeStamp(e) {
                this._initPTS = this._initDTS = e
            }
            resetInitSegment() {
                this.currentInitTrack = void 0, this._silentAudioTrack = void 0
            }
            remuxEsTracks(r, n, s, a, o, l, d, u, c, h) {
                let p;
                l || (this.isVideoContiguous = !1);
                c = void 0 === c ? o : c;
                if (!this.currentInitTrack) {
                    if (r && r.config.codec && (this._audioTrackInfo = {
                            id: r.info.id,
                            codec: r.config.codec,
                            channelCount: r.config.channelCount
                        }), n && h && this._audioTrackInfo) {
                        const r = Te.getTrack(this.observer, this._audioTrackInfo.id, this._audioTrackInfo.codec, this._audioTrackInfo.channelCount, this.logger);
                        if (r) {
                            this._silentAudioTrack = Object.assign(Object.assign({}, r), {
                                info: Object.assign(Object.assign({}, r.info), {
                                    inputTimescale: 9e4
                                }),
                                parsingData: {
                                    len: 0,
                                    sequenceNumber: 0,
                                    esSamples: []
                                }
                            });
                            const s = this._initPTS + Math.round(c * this._silentAudioTrack.info.timescale);
                            p = Te.getSegment(this._silentAudioTrack, n.parsingData.sequenceNumber, s, h), n.parsingData.sequenceNumber++
                        }
                    } else this._silentAudioTrack = void 0;
                    this.updateInitPTSDTS(n, r, o), this.generateIS(this._silentAudioTrack || r, n)
                }
                if (this.currentInitTrack) {
                    const f = n && n.parsingData.esSamples.length,
                        m = this.isVideoContiguous;
                    let t, i, e;
                    if (n && h && this._silentAudioTrack && !p) {
                        const r = this._initPTS + Math.round((c + this.config.audioPrimingDelay) * this._silentAudioTrack.info.timescale);
                        p = Te.getSegment(this._silentAudioTrack, n.parsingData.sequenceNumber, r, h)
                    }
                    if (r && r.parsingData.esSamples.length) {
                        if (ne(r.info.timescale) || (this.logger.warn("regenerate InitSegment as audio detected"), this.updateInitPTSDTS(n, r, o), this.generateIS(r, n)), t = this.remuxAudio(r, c, l, d, u), f) {
                            let e;
                            t && (e = S(t.endPTS) - S(t.startPTS)), ne(n.info.timescale) || (this.logger.warn("regenerate InitSegment as video detected"), this.updateInitPTSDTS(n, r, o), this.generateIS(r, n)), i = this.remuxVideo(n, c, m, e, h)
                        }
                    } else f && (i = this.remuxVideo(n, c, m, void 0, h)), i && r && r.config.codec && (t = this.remuxEmptyAudio(r, c, l, d, i, u));
                    p ? e = {
                        data1: i.data1,
                        data2: p.silentFragData,
                        startDTS: i.startDTS,
                        startPTS: i.startPTS,
                        endDTS: y(i.endDTS, p.endTs),
                        endPTS: y(i.endPTS, p.endTs),
                        type: "audiovideo",
                        track: this.currentInitTrack
                    } : i && t ? e = {
                        data1: i.data1,
                        data2: t.data1,
                        startDTS: g(i.startDTS, t.startDTS),
                        startPTS: g(i.startPTS, t.startPTS),
                        endDTS: y(i.endDTS, t.endDTS),
                        endPTS: y(i.endPTS, t.endPTS),
                        type: "audiovideo",
                        track: this.currentInitTrack,
                        dropped: i.dropped,
                        framesWithoutIDR: i.framesWithoutIDR,
                        firstKeyframePts: i.firstKeyframePts
                    } : i ? e = {
                        data1: i.data1,
                        startDTS: i.startDTS,
                        startPTS: i.startPTS,
                        endDTS: i.endDTS,
                        endPTS: i.endPTS,
                        type: "video",
                        track: this.currentInitTrack,
                        dropped: i.dropped,
                        framesWithoutIDR: i.framesWithoutIDR,
                        firstKeyframePts: i.firstKeyframePts
                    } : t ? e = {
                        data1: t.data1,
                        startDTS: t.startDTS,
                        startPTS: t.startPTS,
                        endDTS: t.endDTS,
                        endPTS: t.endPTS,
                        type: "audio",
                        track: this.currentInitTrack
                    } : this.logger.error("Missing video and audio data"), a && a.captionSamples.length && this.remuxText(a, e), null !== (a = null == s ? void 0 : s.id3Samples) && void 0 !== a && a.length && this.remuxID3(s, e), this.observer.trigger(v.FRAG_PARSING_DATA, e)
                } else this.logger.error("failed to generate IS");
                this.observer.trigger(v.FRAG_PARSED)
            }
            updateInitPTSDTS(e, t, i) {
                let r = 1 / 0,
                    n = 1 / 0;
                var s = e ? e.parsingData.esSamples : [],
                    a = t ? t.parsingData.esSamples : [];
                if (!ne(this._initPTS)) {
                    if (t && a.length && (r = n = a[0].pts - t.info.inputTimescale * i), e && s.length) {
                        const t = e.info.inputTimescale;
                        e.info.timescale = t, r = Math.min(r, s.reduce((e, t) => {
                            var i = t.pts - e;
                            return i < -4294967296 ? Ie(e, t.pts) : 0 < i ? e : t.pts
                        }, s[0].pts) - t * i), n = Math.min(n, s[0].dts - t * i), this.observer.trigger(v.INIT_PTS_FOUND, {
                            initPTS: B(r, t)
                        })
                    }
                    if (ne(r) && ne(n)) this._initPTS = r, this._initDTS = n;
                    else {
                        const e = new D(!1, "invalid initPTS or initDTS", $.InvalidInitTimestamp);
                        this.observer.trigger(x.INTERNAL_ERROR, e)
                    }
                }
            }
            generateIS(e, t) {
                const i = t ? t.parsingData.esSamples : [],
                    r = this.typeSupported;
                let n, s = "audio/mp4";
                if (e && t && i.length) {
                    const i = t.info.inputTimescale;
                    t.info.timescale = i, e.info.timescale = e.config.samplerate;
                    const r = pe.initSegment([t, e]);
                    n = {
                        type: "audiovideo",
                        container: "video/mp4",
                        codec: `${t.config.codec},${e.config.codec}`,
                        initSegment: r
                    }
                } else if (e) {
                    "mp3" === (e.info.timescale = e.config.samplerate, e.config.segmentCodec) && (r.mpeg ? (s = "audio/mpeg", e.config.codec = "") : r.mp3 && (e.config.codec = "mp3"));
                    const t = "mp3" === e.config.segmentCodec && r.mpeg ? new Uint8Array : pe.initSegment([e]);
                    n = {
                        type: "audio",
                        container: s,
                        codec: e.config.codec,
                        initSegment: t
                    }
                } else if (t && i.length) {
                    const e = t.info.inputTimescale;
                    t.info.timescale = e;
                    const i = pe.initSegment([t]);
                    n = {
                        type: "video",
                        container: "video/mp4",
                        codec: t.config.codec,
                        initSegment: i
                    }
                }
                if (n) {
                    this.currentInitTrack = n;
                    const e = {
                        track: n
                    };
                    this.observer.trigger(v.FRAG_PARSING_INIT_SEGMENT, e)
                } else {
                    const e = new D(!1, "no audio/video samples found", $.NoAVSamplesFound);
                    this.observer.trigger(x.INTERNAL_ERROR, e)
                }
            }
            remuxVideo(n, e, s, a, o) {
                let l, d, u, c, h, t, p = 8,
                    i = n.parsingData.dropped;
                const r = !s && this.config.forceKeyFrameOnDiscontinuity,
                    f = n.parsingData.esSamples,
                    m = n.info.inputTimescale,
                    g = [],
                    y = n.info.encrypted;
                let v, S;
                v = s ? this.nextAvcDts : Ie(f[0].dts, f[0].pts), f.forEach(function(e) {
                    e.pts = Ie(e.pts, v), e.dts = Ie(e.dts, v)
                }), f.sort(function(e, t) {
                    var i = e.dts - t.dts,
                        r = e.pts - t.pts;
                    return i || r || e.id - t.id
                });
                var b = f.findIndex(e => e.key);
                f[b] && (S = f[b].pts), r && (0 < b ? (this.logger.warn(`Dropped ${b} out of ${f.length} video samples due to a missing keyframe`), f.splice(0, b), i += b) : -1 === b && (this.logger.warn(`No keyframe found out of ${f.length} video samples`), i += f.length));
                var T = f[0],
                    E = f[f.length - 1],
                    I = f.reduce((e, t) => Math.max(Math.min(e, t.pts - t.dts), -18e3), 0);
                if (I < 0) {
                    this.logger.warn(`PTS < DTS detected in video samples, shifting DTS by ${Math.round(I/90)} ms to overcome this issue`);
                    for (let e = 0; e < f.length; e++) f[e].dts += I
                }
                var w = this.isSafari;
                if (l = Math.round((E.dts - T.dts) / (f.length - 1)), c = Math.max(T.dts, 0), u = Math.max(T.pts, 0), ne(o) && (c = e * m, u = e * m), s) {
                    const n = c - v,
                        M = n > l,
                        s = n < -1;
                    (M || s) && (M ? this.logger.warn(`AVC: ${n}/90000 hole between fragments detected`) : this.logger.warn(`AVC: ${n}/90000 overlapping between fragments detected`))
                }
                let A = 0,
                    O = 0;
                var k = f.length;
                for (let e = 0; e < k; e++) {
                    const M = f[e],
                        s = M.units,
                        a = s.length;
                    let t = 0;
                    for (let e = 0; e < a; e++) t += s[e].data.length;
                    O += t, A += a, M.length = t, M.dts = w ? c + e * l : Math.max(M.dts, c), M.pts = Math.max(M.pts, M.dts)
                }
                t = Math.max(E.dts, 0), h = Math.max(E.pts, 0, t), ne(o) && (t = e * m, h = e * m);
                e = O + 4 * A + 8;
                try {
                    d = new Uint8Array(e)
                } catch (n) {
                    const M = new F(!1, `fail allocating video mdat ${e}`, $.FailedToAllocateVideoMdat, e);
                    return void this.observer.trigger(x.INTERNAL_ERROR, M)
                }
                const C = new DataView(d.buffer);
                C.setUint32(0, e), d.set(pe.types.mdat, 4);
                for (let t = 0; t < k; t++) {
                    const M = f[t],
                        s = M.units;
                    let e, i = 0;
                    const x = [];
                    let r = 0;
                    for (let e = 0, t = s.length; e < t; e++) {
                        const M = s[e],
                            a = M.data,
                            o = M.data.byteLength;
                        if (C.setUint32(p, o), p += 4, d.set(a, p), p += o, i += 4 + o, y)
                            if (o <= 48 || 1 !== M.type && 5 !== M.type) r += 4 + o;
                            else {
                                let e = o - 32;
                                e % 16 == 0 && (e -= 16), x.push([r + 36, e]), r = o - 32 - e
                            }
                    }
                    if (0 < r && x.push([r, 0]), w) e = Math.max(0, l * Math.round((M.pts - M.dts) / l));
                    else {
                        if (t < k - 1) l = f[t + 1].dts - M.dts;
                        else {
                            const s = this.config,
                                o = M.dts - f[0 < t ? t - 1 : t].dts;
                            if (s.stretchShortVideoTrack) {
                                const n = s.maxBufferHole,
                                    d = s.maxSeekHole,
                                    c = Math.floor(Math.min(n, d) * m),
                                    h = (a ? u + a * m : this.nextAudioPts) - M.pts;
                                h > c ? (l = h - o, l < 0 && (l = o)) : l = o
                            } else l = o
                        }
                        e = Math.round(M.pts - M.dts)
                    }
                    ne(o) && (e = 0, l = o * m), g.push({
                        size: i,
                        duration: l,
                        cts: e,
                        flags: {
                            isLeading: 0,
                            isDependedOn: 0,
                            hasRedundancy: 0,
                            degradPrio: 0,
                            dependsOn: M.key ? 2 : 1,
                            isNonSync: M.key ? 0 : 1,
                            paddingValue: 0
                        },
                        keyTagInfo: M.keyTagInfo,
                        subsamples: x
                    })
                }
                if (this.nextAvcDts = t + l, this.isVideoContiguous = !0, g.length && -1 < navigator.userAgent.toLowerCase().indexOf("chrome")) {
                    const n = g[0].flags;
                    n.dependsOn = 2, n.isNonSync = 0
                }
                e = {
                    sequenceNumber: n.parsingData.sequenceNumber++,
                    id: n.info.id,
                    type: n.type,
                    encrypted: n.info.encrypted,
                    samples: g,
                    defaultPerSampleIVSize: 0
                }, e = pe.moof(c + this.config.audioPrimingDelay * m, e);
                n.parsingData.esSamples = [];
                const D = new Uint8Array(e.byteLength + d.byteLength);
                return D.set(e), D.set(d, e.byteLength), {
                    data1: D,
                    startPTS: B(u / m, m),
                    endPTS: B((h + l) / m, m),
                    startDTS: B(c / m, m),
                    endDTS: B(this.nextAvcDts / m, m),
                    type: "video",
                    dropped: i,
                    framesWithoutIDR: b,
                    firstKeyframePts: B(S / m, m)
                }
            }
            remuxAudio(r, i, n, e, s) {
                const a = r.info.inputTimescale,
                    o = a / r.info.timescale,
                    l = ("aac" === r.config.segmentCodec ? 1024 : "mp3" === r.config.segmentCodec ? 1152 : 1536) * o,
                    d = "mp3" === r.config.segmentCodec && this.typeSupported.mpeg,
                    u = [],
                    c = r.info.encrypted,
                    t = this._initPTS + i * a;
                let h, p, f, m, g, y, v, S, b, T, E, I, w, A, O = d ? 0 : 8;
                const k = new q,
                    C = r.parsingData.esSamples;
                if (A = this.nextAudioPts, (n = n || C.length && A && (e && Math.abs(t - A) < 9e3 || Math.abs(Ie(C[0].pts - A, t)) < 20 * l)) || (A = Ie(C[0].pts, this._initPTS)), C.forEach(function(e) {
                        e.pts = e.dts = Ie(e.pts, A)
                    }), e && "aac" === r.config.segmentCodec)
                    for (let t = 0, i = A; t < C.length;) {
                        const M = C[t];
                        T = M.pts;
                        const o = T - i,
                            d = Math.abs(1e3 * o / a);
                        if (o <= -l) this.logger.warn(`Dropping 1 audio frame @ ${(i/a).toFixed(3)}s due to ${d} ms overlap.`), C.splice(t, 1), r.parsingData.len -= M.unit.length;
                        else if (o >= l && d < 1e4 && i) {
                            const d = Math.round(o / l);
                            this.logger.warn(`Injecting ${d} audio frame @ ${(i/a).toFixed(3)}s due to ${Math.round(1e3*o/a)} ms gap.`);
                            for (let e = 0; e < d; e++) w = Math.max(i, 0), I = re(r.config.codec, r.config.channelCount), I || (this.logger.warn("Unable to get silent frame for given audio codec; duplicating last frame instead."), I = M.unit.subarray(0)), C.splice(t, 0, {
                                unit: I,
                                pts: w,
                                dts: w,
                                keyTagInfo: s
                            }), r.parsingData.len += I.length, i += l, t += 1;
                            M.pts = M.dts = i, i += l, t += 1
                        } else i += l, M.pts = M.dts = 0 === t ? A : C[t - 1].pts + l, t += 1
                    }
                for (let e = 0, t = C.length; e < t; e++) {
                    if (p = C[e], m = p.unit, T = p.pts, E = p.dts, void 0 !== b) f.duration = Math.round((E - b) / o);
                    else {
                        const i = Math.round(1e3 * (T - A) / a);
                        let t = 0;
                        if (n && "aac" === r.config.segmentCodec && i) {
                            if (0 < i && i < 1e4) t = Math.round((T - A) / l), 0 < t && (I = re(r.config.codec, r.config.channelCount), I = I || m.subarray(0), r.parsingData.len += t * I.length);
                            else if (i < -12) {
                                r.parsingData.len -= m.byteLength;
                                continue
                            }
                            T = E = A
                        }
                        if (v = Math.max(0, T), S = Math.max(0, E), !(0 < r.parsingData.len)) return; {
                            const i = d ? r.parsingData.len : r.parsingData.len + 8;
                            try {
                                g = new Uint8Array(i)
                            } catch (r) {
                                const n = new F(!1, `fail allocating audio mdat ${i}`, $.FailedToAllocateAudioMdat, i);
                                return void this.observer.trigger(x.INTERNAL_ERROR, n)
                            }
                            d || (h = new DataView(g.buffer), h.setUint32(0, i), g.set(pe.types.mdat, 4))
                        }
                        for (let e = 0; e < t; e++) w = T - (t - e) * l, I = re(r.config.codec, r.config.channelCount), I || (this.logger.warn("Unable to get silent frame for given audio codec; duplicating this frame instead."), I = m.subarray(0)), g.set(I, O), O += I.byteLength, f = {
                            size: I.byteLength,
                            cts: 0,
                            duration: 1024,
                            flags: {
                                isLeading: 0,
                                isDependedOn: 0,
                                hasRedundancy: 0,
                                degradPrio: 0,
                                dependsOn: 1,
                                paddingValue: 0,
                                isNonSync: 0
                            },
                            keyTagInfo: p.keyTagInfo,
                            subsamples: c ? [
                                [I.byteLength, 0]
                            ] : []
                        }, u.push(f)
                    }
                    g.set(m, O);
                    const M = m.byteLength;
                    O += M;
                    const s = [];
                    if (c)
                        if ("ec3" === r.config.segmentCodec) {
                            let e = 0;
                            for (; e < m.byteLength;) {
                                const i = 2 * (k.bsReadAndUpdate(m, {
                                    byteOffset: e + 2,
                                    usedBits: 5
                                }, 11) + 1);
                                e += i;
                                const n = Math.min(i, 16);
                                s.push([n, i - n])
                            }
                        } else {
                            const r = Math.min(M, 16);
                            s.push([r, M - r])
                        } f = {
                        size: M,
                        cts: 0,
                        duration: 0,
                        flags: {
                            isLeading: 0,
                            isDependedOn: 0,
                            hasRedundancy: 0,
                            degradPrio: 0,
                            dependsOn: 1,
                            paddingValue: 0,
                            isNonSync: 0
                        },
                        keyTagInfo: p.keyTagInfo,
                        subsamples: s
                    }, u.push(f), b = E
                }
                let D = 0;
                e = u.length;
                if (2 <= e && (D = u[e - 2].duration, f.duration = D), e) {
                    if (this.nextAudioPts = T + o * D, r.parsingData.len = 0, d) y = new Uint8Array;
                    else {
                        const i = {
                            sequenceNumber: r.parsingData.sequenceNumber++,
                            id: r.info.id,
                            type: r.type,
                            encrypted: r.info.encrypted,
                            samples: u,
                            defaultPerSampleIVSize: 0
                        };
                        y = pe.moof((S + this.config.audioPrimingDelay * a) / o, i)
                    }
                    const i = new Uint8Array(y.byteLength + g.byteLength);
                    return i.set(y), i.set(g, y.byteLength), r.parsingData.esSamples = [], {
                        data1: i,
                        startPTS: B(v / a, a),
                        endPTS: B(this.nextAudioPts / a, a),
                        startDTS: B(S / a, a),
                        endDTS: B((E + o * D) / a, a),
                        type: "audio"
                    }
                }
                return null
            }
            remuxEmptyAudio(t, e, i, r, n, s) {
                var a = t.info.inputTimescale,
                    o = a / (t.config.samplerate || a),
                    l = this.nextAudioPts,
                    d = (void 0 !== l ? l : S(n.startDTS) * a) + this._initDTS,
                    a = S(n.endDTS) * a + this._initDTS,
                    u = 1024 * o,
                    c = Math.ceil((a - d) / u),
                    h = re(t.config.codec, t.config.channelCount);
                if (this.logger.warn("remux empty Audio"), !h) return this.logger.error("Unable to remuxEmptyAudio since we were unable to get a silent frame for given audio codec!"), null;
                const p = [];
                for (let e = 0; e < c; e++) {
                    const i = d + e * u;
                    p.push({
                        unit: h,
                        pts: i,
                        dts: i,
                        keyTagInfo: s
                    }), t.parsingData.len += h.length
                }
                return t.parsingData.esSamples = p, this.remuxAudio(t, e, i, r, s)
            }
            remuxID3(t, e) {
                var i = t.id3Samples.length;
                let r;
                var n = t.inputTimescale;
                if (i) {
                    for (let e = 0; e < i; e++) r = t.id3Samples[e], r.pts = r.pts / n, r.dts = r.dts / n;
                    e.id3Samples = t.id3Samples
                }
                t.id3Samples = []
            }
            remuxText(t, e) {
                t.captionSamples.sort(function(e, t) {
                    return e.pts - t.pts
                });
                var i = t.captionSamples.length;
                let r;
                var n = t.inputTimescale;
                if (i) {
                    for (let e = 0; e < i; e++) r = t.captionSamples[e], r.pts = r.pts / n;
                    e.captionData || (e.captionData = {}), e.captionData.ts = t.captionSamples
                }
                t.captionSamples = []
            }
        }

        function Ie(e, t) {
            var i;
            if (void 0 === t) return e;
            for (i = t < e ? -8589934592 : 8589934592; 4294967296 < Math.abs(e - t);) e += i;
            return e
        }
        e = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : "undefined" != typeof global ? global : void 0 !== Jy ? Jy : {};

        function we(e) {
            try {
                return JSON.stringify(e)
            } catch (e) {
                return '"[Circular]"'
            }
        }

        function Ae(e, t, i) {
            var r = i && i.stringify || we;
            if ("object" == typeof e && null !== e) {
                var n = t.length + 1;
                if (1 === n) return e;
                var s = new Array(n);
                s[0] = r(e);
                for (var a = 1; a < n; a++) s[a] = r(t[a]);
                return s.join(" ")
            }
            if ("string" != typeof e) return e;
            var o = t.length;
            if (0 === o) return e;
            for (var l = "", d = 0, u = -1, c = e && e.length || 0, h = 0; h < c;) {
                if (37 === e.charCodeAt(h) && h + 1 < c) {
                    switch (u = -1 < u ? u : 0, e.charCodeAt(h + 1)) {
                        case 100:
                            if (o <= d) break;
                            if (u < h && (l += e.slice(u, h)), null == t[d]) break;
                            l += Number(t[d]), u = h += 2;
                            break;
                        case 79:
                        case 111:
                        case 106:
                            if (o <= d) break;
                            if (u < h && (l += e.slice(u, h)), void 0 === t[d]) break;
                            var p = typeof t[d];
                            if ("string" == p) {
                                l += "'" + t[d] + "'", u = h + 2, h++;
                                break
                            }
                            if ("function" == p) {
                                l += t[d].name || "<anonymous>", u = h + 2, h++;
                                break
                            }
                            l += r(t[d]), u = h + 2, h++;
                            break;
                        case 115:
                            if (o <= d) break;
                            u < h && (l += e.slice(u, h)), l += String(t[d]), u = h + 2, h++;
                            break;
                        case 37:
                            u < h && (l += e.slice(u, h)), l += "%", u = h + 2, h++
                    }++d
                }++h
            }
            return -1 === u ? e : (u < c && (l += e.slice(u)), l)
        }
        var Oe = De;
        const ke = function() {
                function t(e) {
                    return void 0 !== e && e
                }
                try {
                    return "undefined" != typeof globalThis || Object.defineProperty(Object.prototype, "globalThis", {
                        get: function() {
                            return delete Object.prototype.globalThis, this.globalThis = this
                        },
                        configurable: !0
                    }), globalThis
                } catch (e) {
                    return t(Jy) || t(window) || t(this) || {}
                }
            }().console || {},
            Ce = {
                mapHttpRequest: Le,
                mapHttpResponse: Le,
                wrapRequestSerializer: _e,
                wrapResponseSerializer: _e,
                wrapErrorSerializer: _e,
                req: Le,
                res: Le,
                err: function(e) {
                    const t = {
                        type: e.constructor.name,
                        msg: e.message,
                        stack: e.stack
                    };
                    for (const i in e) void 0 === t[i] && (t[i] = e[i]);
                    return t
                }
            };

        function De(s) {
            (s = s || {}).browser = s.browser || {};
            const a = s.browser.transmit;
            if (a && "function" != typeof a.send) throw Error("pino: transmit option must have a send function");
            const e = s.browser.write || ke;
            s.browser.write && (s.browser.asObject = !0);
            const o = s.serializers || {},
                l = (t = s.browser.serialize, i = o, Array.isArray(t) ? t.filter(function(e) {
                    return "!stdSerializers.err" !== e
                }) : !0 === t && Object.keys(i));
            var t, i;
            let r = s.browser.serialize;
            Array.isArray(s.browser.serialize) && -1 < s.browser.serialize.indexOf("!stdSerializers.err") && (r = !1), "function" == typeof e && (e.error = e.fatal = e.warn = e.info = e.debug = e.trace = e), !1 === s.enabled && (s.level = "silent");
            const n = s.level || "info",
                d = Object.create(e);
            d.log || (d.log = Ne), Object.defineProperty(d, "levelVal", {
                get: function() {
                    return "silent" === this.level ? 1 / 0 : this.levels.values[this.level]
                }
            }), Object.defineProperty(d, "level", {
                get: function() {
                    return this._level
                },
                set: function(e) {
                    if ("silent" !== e && !this.levels.values[e]) throw Error("unknown level " + e);
                    this._level = e, Me(u, d, "error", "log"), Me(u, d, "fatal", "error"), Me(u, d, "warn", "error"), Me(u, d, "info", "log"), Me(u, d, "debug", "log"), Me(u, d, "trace", "log")
                }
            });
            const u = {
                transmit: a,
                serialize: l,
                asObject: s.browser.asObject,
                levels: ["error", "fatal", "warn", "info", "debug", "trace"],
                timestamp: "function" == typeof(i = s).timestamp ? i.timestamp : !1 === i.timestamp ? Fe : Be
            };
            return d.levels = De.levels, d.level = n, d.setMaxListeners = d.getMaxListeners = d.emit = d.addListener = d.on = d.prependListener = d.once = d.prependOnceListener = d.removeListener = d.removeAllListeners = d.listeners = d.listenerCount = d.eventNames = d.write = d.flush = Ne, d.serializers = o, d._serialize = l, d._stdErrSerialize = r, d.child = function(t) {
                if (!t) throw new Error("missing bindings for child Pino");
                var i, r, e = t.serializers;

                function n(e) {
                    this._childLevel = 1 + (0 | e._childLevel), this.error = Pe(e, t, "error"), this.fatal = Pe(e, t, "fatal"), this.warn = Pe(e, t, "warn"), this.info = Pe(e, t, "info"), this.debug = Pe(e, t, "debug"), this.trace = Pe(e, t, "trace"), i && (this.serializers = i, this._serialize = r), a && (this._logEvent = Re([].concat(e._logEvent.bindings, t)))
                }
                return l && e && (i = Object.assign({}, o, e), r = !0 === s.browser.serialize ? Object.keys(i) : l, delete t.serializers, xe([t], r, i, this._stdErrSerialize)), n.prototype = this, new n(this)
            }, a && (d._logEvent = Re()), d
        }

        function Me(e, t, i, r) {
            var n, s, a, o, l = Object.getPrototypeOf(t);
            t[i] = !(t.levelVal > t.levels.values[i]) && (l[i] || ke[i] || ke[r]) || Ne, s = t, a = i, !(n = e).transmit && s[a] === Ne || (s[a] = (o = s[a], function() {
                const e = n.timestamp(),
                    t = new Array(arguments.length),
                    i = Object.getPrototypeOf && Object.getPrototypeOf(this) === ke ? ke : this;
                for (var r = 0; r < t.length; r++) t[r] = arguments[r];
                if (n.serialize && !n.asObject && xe(t, this._serialize, this.serializers, this._stdErrSerialize), n.asObject ? o.call(i, function(e, t, i, r) {
                        e._serialize && xe(i, e._serialize, e.serializers, e._stdErrSerialize);
                        const n = i.slice();
                        let s = n[0];
                        const a = {};
                        r && (a.time = r), a.level = De.levels.values[t];
                        let o = 1 + (0 | e._childLevel);
                        if (o < 1 && (o = 1), null !== s && "object" == typeof s) {
                            for (; o-- && "object" == typeof n[0];) Object.assign(a, n.shift());
                            s = n.length ? Ae(n.shift(), n) : void 0
                        } else "string" == typeof s && (s = Ae(n.shift(), n));
                        return void 0 !== s && (a.msg = s), a
                    }(this, a, t, e)) : o.apply(i, t), n.transmit) {
                    const o = n.transmit.level || s.level,
                        i = De.levels.values[o],
                        r = De.levels.values[a];
                    r < i || function(e, t, i) {
                        const r = t.send,
                            n = t.ts,
                            s = t.methodLevel,
                            a = t.methodValue,
                            o = t.val,
                            l = e._logEvent.bindings;
                        xe(i, e._serialize || Object.keys(e.serializers), e.serializers, void 0 === e._stdErrSerialize || e._stdErrSerialize), e._logEvent.ts = n, e._logEvent.messages = i.filter(function(e) {
                            return -1 === l.indexOf(e)
                        }), e._logEvent.level.label = s, e._logEvent.level.value = a, r(s, e._logEvent, o), e._logEvent = Re(l)
                    }(this, {
                        ts: e,
                        methodLevel: a,
                        methodValue: r,
                        transmitLevel: o,
                        transmitValue: De.levels.values[n.transmit.level || s.level],
                        send: n.transmit.send,
                        val: s.levelVal
                    }, t)
                }
            }))
        }

        function xe(e, t, i, r) {
            for (const n in e)
                if (r && e[n] instanceof Error) e[n] = De.stdSerializers.err(e[n]);
                else if ("object" == typeof e[n] && !Array.isArray(e[n]))
                for (const r in e[n]) t && -1 < t.indexOf(r) && r in i && (e[n][r] = i[r](e[n][r]))
        }

        function Pe(i, r, n) {
            return function() {
                try{  const e = new Array(1 + arguments.length);
                    e[0] = r;
                    for (var t = 1; t < e.length; t++)
                        e[t] = arguments[t - 1];
                    return i[n].apply(this, e) } catch (e){}
            }
        }

        function Re(e) {
            return {
                ts: 0,
                messages: [],
                bindings: e || [],
                level: {
                    label: "",
                    value: 0
                }
            }
        }

        function Le() {
            return {}
        }

        function _e(e) {
            return e
        }

        function Ne() {}

        function Fe() {
            return !1
        }

        function Be() {
            return Date.now()
        }
        let Ue;

        function $e(e = {}) {
            return Object.assign(Object.assign({}, e), {
                customLevels: Object.assign(Object.assign({}, e.customLevels || {}), {
                    qe: 35
                })
            })
        }
        De.levels = {
            values: {
                fatal: 60,
                error: 50,
                warn: 40,
                info: 30,
                debug: 20,
                trace: 10
            },
            labels: {
                10: "trace",
                20: "debug",
                30: "info",
                40: "warn",
                50: "error",
                60: "fatal"
            }
        }, De.stdSerializers = Ce, De.stdTimeFunctions = Object.assign({}, {
            nullTime: Fe,
            epochTime: Be,
            unixTime: function() {
                return Math.round(Date.now() / 1e3)
            },
            isoTime: function() {
                return new Date(Date.now()).toISOString()
            }
        });
        const Ve = () => {};

        function Ke(e, t) {
            const i = (e = t in e ? e : console)[t] || e.log;
            return i ? i.bind(e) : Ve
        }

        function qe(r, n, e) {
            var {
                time: s,
                sessionId: t,
                critical: i,
                name: a,
                msg: o
            } = e;
            let l = "";
            if ("data" in e) try {
                const r = [],
                    n = [];
                l = JSON.stringify(e.data, (e, t) => {
                    if ("object" == typeof t && null !== t) {
                        var i = n.indexOf(t);
                        if (-1 !== i) return `[Circular object reference: '${r[i]}']`;
                        r.push(e), n.push(t)
                    }
                    return t
                })
            } catch (r) {
                l = `Log serialization error: "${r}"`
            }
            r(`${function(){const e=new Date(s),t=e.getTimezoneOffset(),i=He(Math.floor(Math.abs(t)/60)),r=He(Math.abs(t)%60);let n=t<=0?"UTC+"+i:"UTC-"+i;return n=r?n+":"+r:n,e.getFullYear()+"-"+He(e.getMonth()+1)+"-"+He(e.getDate())+" "+He(e.getHours())+":"+He(e.getMinutes())+":"+He(e.getSeconds())+"."+(e.getMilliseconds()/1e3).toFixed(3).slice(2,5)+" "+n}()}| [SessionID: ${t}] | [${n}] >${i?" [QE Critical]":""} [${a}] ${o||""} ${l}`)
        }

        function He(e) {
            return e < 10 ? "0" + e : e.toString()
        }

        function je(e, t = 1 / 0) {
            if (!e) return "";
            const i = new Uint8Array(e);
            let r, n = "";
            for (r = 0; r < i.length && r < t; r++) {
                let e = i[r].toString(16);
                e.length < 2 && (e = "0" + e), n += e
            }
            return n
        }
        const Qe = () => (Ue || (Ue = Oe($e()).child({
                name: "hls"
            }), Ue.qe = e => Ue.info(e), Ue.warn("getLogger called without hls object instantiated, returning a logger that is not configured")), Ue),
            We = {
                bin2str: e => String.fromCharCode.apply(null, Array.from(e)),
                readUint16(e, t) {
                    t = e[t] << 8 | e[t + 1];
                    return t < 0 ? 65536 + t : t
                },
                readSint32: (e, t) => e[t] << 24 | e[t + 1] << 16 | e[t + 2] << 8 | e[t + 3],
                readUint32(e, t) {
                    t = We.readSint32(e, t);
                    return t < 0 ? 4294967296 + t : t
                },
                writeUint32(e, t, i) {
                    e[t] = i >> 24, e[t + 1] = i >> 16 & 255, e[t + 2] = i >> 8 & 255, e[t + 3] = 255 & i
                },
                readUint64(e, t) {
                    var i = We.readUint32(e, t);
                    return i *= Math.pow(2, 32), i += We.readUint32(e, t + 4)
                },
                writeUint64(e, t, i) {
                    var r = Math.pow(2, 32) - 1,
                        n = Math.floor(i / (1 + r)),
                        r = Math.floor(i % (1 + r));
                    We.writeUint32(e, t, n), We.writeUint32(e, t + 4, r)
                },
                findBox(e, t) {
                    let i, r, n, s, a, o = [];
                    if (!t.length) return [];
                    for (i = 0; i < e.byteLength;) r = We.readUint32(e, i), n = We.bin2str(e.subarray(i + 4, i + 8)), s = 1 < r ? i + r : e.byteLength, n === t[0] && (1 === t.length ? o.push(e.subarray(i + 8, s)) : (a = We.findBox(e.subarray(i + 8, s), t.slice(1))).length && (o = o.concat(a))), i = s;
                    return o
                },
                findBoxWithOffset(e, t, i, r) {
                    let n, s, a, o, l, d = [];
                    if (!i.length) return [];
                    for (n = 0; n < e.byteLength;) s = We.readUint32(e, n), a = We.bin2str(e.subarray(n + 4, n + 8)), o = 1 < s ? n + s : e.byteLength, a === i[0] && (r && r.push({
                        offset: n + t,
                        type: a,
                        size: s
                    }), 1 === i.length ? d.push({
                        offset: n + t,
                        type: a,
                        data: e.subarray(n + 8, o),
                        boxSize: s,
                        walkedPath: r ? r.slice(0) : void 0
                    }) : (l = We.findBoxWithOffset(e.subarray(n + 8, o), n + t + 8, i.slice(1), r ? r.slice(0) : void 0)).length && (d = d.concat(l), r = r ? r.slice(0, -1) : void 0)), n = o;
                    return d
                }
            },
            Ge = {
                name: "MP4EncryptionRemuxer"
            };
        class ze extends h {
            constructor(e, t, i, r, n) {
                super(e, t, n)
            }
            static _isCommonEncryptionInternal(e) {
                return Boolean(e && !("NONE" === e || "AES-128" === e))
            }
            static remuxInitSegment(c, h, p, f) {
                if (!p) return c;
                let e = c;
                if (ze._isCommonEncryptionInternal(p.method)) {
                    const m = p.keyId;
                    let u = !1;
                    const g = [];
                    if (We.findBoxWithOffset(c, 0, ["moov", "trak"]).forEach(t => {
                            const o = t.data;
                            let l, i = 0;
                            const d = We.findBoxWithOffset(o, 0, ["mdia", "minf", "stbl", "stsd"], [])[0],
                                e = d.data.subarray(8);
                            let r = !0,
                                n = We.findBoxWithOffset(e, d.offset + 16, ["enca"]);
                            0 === n.length && (r = !1, n = We.findBoxWithOffset(e, d.offset + 16, ["encv"])), n.forEach(s => {
                                let e = null,
                                    a = null;
                                i = r ? (e = s.data.subarray(28), l = "audio", d.offset + 16 + 8 + 28) : (e = s.data.subarray(78), l = "video", d.offset + 16 + 8 + 78), e && We.findBoxWithOffset(e, i, ["sinf"]).forEach(e => {
                                    const t = e.data,
                                        i = We.findBox(t, ["frma"])[0],
                                        r = We.findBox(t, ["schm"])[0];
                                    if (i)
                                        if (r) {
                                            var n = We.bin2str(r.subarray(4, 8));
                                            if ("aac " === We.bin2str(i.subarray(0, 4)) && (ge.types || ge.init(), i.set(ge.types.mp4a, 0)), "cbcs" === n || "cenc" === n) {
                                                f && f.push(t);
                                                const e = We.findBox(t, ["schi", "tenc"])[0];
                                                if (e) {
                                                    const h = 8;
                                                    e.subarray(8, 24), e.set(m, 8);
                                                    const f = e[6],
                                                        t = e[7];
                                                    if (1 === f && 0 === t) {
                                                        const h = e[24];
                                                        0 < h && p.iv && h === p.iv.length && e.set(p.iv, 25)
                                                    }
                                                }
                                            } else if ("cbc2" === n) {
                                                u = !0, ge.types || ge.init();
                                                const h = We.findBoxWithOffset(t, 0, ["frma"])[0],
                                                    f = ge.box(ge.types.schi, ge.tenc(p, l)),
                                                    m = ge.box(ge.types.sinf, t.subarray(h.offset, h.boxSize), ge.schm(), f);
                                                a = ge.box(ge.types.trak, o.subarray(0, e.offset), m, o.subarray(e.offset + e.boxSize));
                                                const i = a.subarray(8),
                                                    r = m.byteLength - e.boxSize;
                                                d.walkedPath && (d.walkedPath.push({
                                                    type: "stsd",
                                                    offset: s.offset,
                                                    size: s.boxSize
                                                }), d.walkedPath.forEach(e => {
                                                    We.writeUint32(i, e.offset, e.size + r)
                                                }))
                                            }
                                        } else h.error(Ge, "missing schm box");
                                    else h.error(Ge, "missing frma box")
                                }), a = a || c.subarray(t.offset, t.offset + t.boxSize), g.push(a)
                            });
                            var s = We.findBoxWithOffset(o, 0, ["edts"])[0];
                            s && (ge.types || ge.init(), o.set(ge.types.free, s.offset + 4))
                        }), u) {
                        const p = ze.remuxCbc2InitSegment(c, g, h);
                        e = p || c
                    }
                }
                return e
            }
            static remuxCbc2InitSegment(i, r, n) {
                const s = We.findBoxWithOffset(i, 0, ["ftyp"])[0];
                if (s) {
                    const a = We.findBoxWithOffset(i, s.boxSize, ["moov"])[0];
                    let e = [],
                        t = 0;
                    for (; t < a.data.byteLength;) {
                        const i = We.readUint32(a.data, t),
                            n = We.bin2str(a.data.subarray(t + 4, t + 8)),
                            s = 1 < i ? t + i : a.data.byteLength;
                        "trak" === n ? r && (e = e.concat(r), r = void 0) : e.push(a.data.subarray(t, s)), t = s
                    }
                    const o = ge.box(ge.types.moov, ...e),
                        l = new Uint8Array(s.boxSize + o.byteLength);
                    return l.set(i.subarray(0, s.boxSize)), l.set(o, s.boxSize), l
                }
                n.error(Ge, "no ftyp found")
            }
            static remuxOverflowSegment(i, e) {
                ge.types || ge.init();
                const t = We.findBoxWithOffset(i, 0, ["moof", "traf", "tfdt"], []);
                let r, n = i.byteLength;
                if (t.forEach(e => {
                        0 === e.data[0] && (n += 4)
                    }), n > i.byteLength) {
                    r = new Uint8Array(n);
                    let e = 0,
                        t = 0;
                    for (; t < i.byteLength;) {
                        const n = We.readUint32(i, t),
                            s = We.bin2str(i.subarray(t + 4, t + 8)),
                            a = 1 < n ? t + n : i.byteLength;
                        if ("moof" === s) {
                            const n = ze.remuxOverflowMoof(i.subarray(t + 8, a));
                            r.set(n, e), e += n.byteLength
                        } else r.set(i.subarray(t, a), e), e += n;
                        t = a
                    }
                } else e.warn(Ge, "no increase in size");
                return r || i
            }
            static remuxOverflowMoof(e) {
                let t = 0;
                const i = [];
                for (; t < e.byteLength;) {
                    const r = We.readUint32(e, t);
                    if ("traf" === We.bin2str(e.subarray(t + 4, t + 8))) {
                        const s = ze.remuxOverflowTraf(e.subarray(t + 8, t + r));
                        i.push(s)
                    } else i.push(e.subarray(t, t + r));
                    t = 1 < r ? t + r : e.byteLength
                }
                const r = ge.box(ge.types.moof, ...i),
                    s = r.byteLength - e.byteLength - 8;
                return We.findBoxWithOffset(r, 0, ["moof", "traf", "trun"], []).forEach(e => {
                    var t;
                    0 != (1 & e.data[3]) && (t = We.readUint32(e.data, 8), We.writeUint32(e.data, 8, t + s))
                }), We.findBoxWithOffset(r, 0, ["moof", "traf", "saio"], []).forEach(t => {
                    const i = 1 & t.data[0];
                    let r = 4;
                    1 & t.data[3] && (r += 8);
                    var n = We.readUint32(t.data, r);
                    if (r += 4, i)
                        for (let e = 0; e < n; e++) {
                            const i = We.readUint64(t.data, r);
                            We.writeUint64(t.data, r, i + s), r += 8
                        } else
                            for (let e = 0; e < n; e++) {
                                const i = We.readUint32(t.data, r);
                                We.writeUint32(t.data, r, i + s), r += 4
                            }
                }), r
            }
            static remuxOverflowTraf(e) {
                let t = 0;
                const i = [];
                for (; t < e.byteLength;) {
                    var r, n = We.readUint32(e, t);
                    "tfdt" === We.bin2str(e.subarray(t + 4, t + 8)) && 0 === e[t + 8] ? (r = We.readUint32(e, t + 12), r = ge.box(ge.types.tfdt, new Uint8Array([1, 0, 0, 0, 0, 0, 0, 0, r >> 24, r >> 16 & 255, r >> 8 & 255, 255 & r])), i.push(r)) : i.push(e.subarray(t, t + n)), t = 1 < n ? t + n : e.byteLength
                }
                return ge.box(ge.types.traf, ...i)
            }
            remuxText(e, t) {
                e.captionSamples.sort(function(e, t) {
                    return e.pts - t.pts
                }), e.captionSamples.length && (t.captionData || (t.captionData = {}), t.captionData.mp4 = e.captionSamples), e.captionSamples = []
            }
            remuxIFrame(e, t, i, r, n) {
                if (!t.samples || !t.samples.length || !t.samples[0].data) return null;
                let s;
                const a = ge.moof(e * t.timescale, t),
                    o = new Uint8Array(a.byteLength + t.samples[0].data.byteLength + 8);
                o.set(a), We.writeUint32(o, a.byteLength, t.samples[0].data.byteLength + 8), o.set(ge.types.mdat, a.byteLength + 4), o.set(t.samples[0].data, a.byteLength + 8), t.sequenceNumber++;
                var l = t.timescale,
                    d = B(e + r, l),
                    l = B(e, l);
                let u, c;
                u = i ? (s = "audiovideo", i.sequenceNumber = t.sequenceNumber, t.sequenceNumber++, c = Te.getSegment(i, i.sequenceNumber, e * i.info.timescale, r), y(c.endTs, d)) : (s = "video", d);
                n = {
                    data1: o,
                    data2: null == c ? void 0 : c.silentFragData,
                    startPTS: l,
                    startDTS: l,
                    endPTS: u,
                    endDTS: u,
                    type: s,
                    dropped: 0,
                    track: n
                };
                this.observer.trigger(v.FRAG_PARSING_DATA, n), this.observer.trigger(v.FRAG_PARSED)
            }
            remuxEmsgAndRawData(e, t, i, r, n, s, a, o, l, d) {
                let u;
                t && r ? u = "audiovideo" : t ? u = "audio" : r && (u = "video");
                const c = Math.max(i, e),
                    h = {
                        data1: l,
                        track: d,
                        startPTS: B(a, o),
                        startDTS: B(a, o),
                        endPTS: void 0,
                        endDTS: void 0,
                        type: u,
                        dropped: 0
                    };
                return c && (h.endPTS = B(a + c, o), h.endDTS = B(a + c, o)), n && n.captionSamples.length && this.remuxText(n, h), s && 0 < s.id3Samples.length && this.remuxID3(s, h), this.observer.trigger(v.FRAG_PARSING_DATA, h), this.observer.trigger(v.FRAG_PARSED), h
            }
            remuxID3(t, e) {
                let i;
                var r = t.id3Samples.length;
                if (r) {
                    for (let e = 0; e < r; e++) i = t.id3Samples[e], i.pts = i.pts - 10, i.dts = i.dts - 10;
                    e.id3Samples = [...t.id3Samples]
                }
                t.id3Samples = []
            }
        }
        const Xe = Math.pow(2, 32) - 1,
            Ye = Math.pow(2, 20) - 1,
            Je = {
                name: "MP4Demuxer"
            };
        class Ze extends u {
            constructor(e, t, i, r, n) {
                super(e, t, i, {}, n), this.mp4Remuxer = t, this.audioPrimingDelay = i.audioPrimingDelay
            }
            resetTimeStamp(e) {
                ne(e) ? this.initData.audio && !this.initData.video ? this.initPtsTs = {
                    baseTime: Math.round(e * this.initData.audio.timescale / 9e4),
                    timescale: this.initData.audio.timescale
                } : this.initPtsTs = {
                    baseTime: e,
                    timescale: 9e4
                } : this.initPtsTs = void 0
            }
            static isHEVCFlavor(e) {
                if (!e) return !1;
                var t = e.indexOf("."),
                    t = t < 0 ? e : e.substring(0, t);
                return "hvc1" === t || "hev1" === t || "chvc" === t || "qhvc" === t || "qhev" === t || "muxa" === t || "dvh1" === t || "dvhe" === t || "cdh1" === t || "qdh1" === t || "qdhe" === t
            }
            resetInitSegment(t, i, r) {
                if (this._silentAudioTrack = void 0, t && t.byteLength) {
                    var n = ze.remuxInitSegment(t, this.logger, r),
                        s = this.initData = Ze.parseInitSegment(n);
                    let e;
                    s.foundLargeTimescale && this.logger.warn(Je, "large timescale found, will check for 32 bit tfdts");
                    var a = s.audioCodec,
                        r = s.videoCodec;
                    if (s.audio && s.video ? e = {
                            type: "audiovideo",
                            container: "video/mp4",
                            codec: a + "," + r,
                            initSegment: n
                        } : (s.audio && a && (e = {
                            type: "audio",
                            container: "audio/mp4",
                            codec: a,
                            initSegment: n
                        }), s.video && r && (e = {
                            type: "video",
                            container: "video/mp4",
                            codec: r,
                            initSegment: n
                        })), s.video) {
                        const o = s.video,
                            l = t.subarray(o.trakOffset, o.trakOffset + o.trakSize);
                        this._videoTrack = Object.assign(Object.assign({}, o), {
                            info: {
                                id: o.id,
                                timescale: o.timescale,
                                duration: i
                            },
                            trakData: l,
                            sequenceNumber: 0,
                            samples: []
                        }), this.trySEICaptions = !be.isVP09(r), this._captionTrack = Object.assign(Object.assign({}, s.caption), {
                            sequenceNumber: 0,
                            captionSamples: []
                        })
                    }
                    s.audio && a && (this._audioTrack = Object.assign({}, s.audio)), s.caption && (this.trySEICaptions = !1, this._captionTrack = Object.assign(Object.assign({}, s.caption), {
                        sequenceNumber: 0,
                        captionSamples: []
                    })), this.remuxedInitDataTrack = e;
                    s = {
                        track: e
                    };
                    this.observer.trigger(v.FRAG_PARSING_INIT_SEGMENT, s)
                }
            }
            static probe(e, t) {
                return 0 < We.findBox(e.subarray(0, Math.min(e.length, 512e3)), ["moof"]).length
            }
            static parseHvcC(e) {
                let t;
                var i, r;
                return e ? 1 === (i = e[0]) ? (r = e[1], t = {
                    profileSpace: r >> 6,
                    tierFlag: (32 & r) >> 5 ? "H" : "L",
                    profileIDC: 31 & r,
                    profileCompat: We.readUint32(e, 2),
                    constraintIndicator: e.subarray(6, 12),
                    levelIDC: e[12]
                }) : Qe().warn(Je, `Unhandled version ${i} in hvcC box`) : Qe().warn(Je, "No hvcC box"), t
            }
            static hvcCToCodecString(t, i) {
                const r = t + "." + (i.profileSpace ? String.fromCharCode(i.profileSpace + "A" - 1) : "") + i.profileIDC + "." + i.profileCompat.toString(16).toUpperCase() + "." + i.tierFlag + i.levelIDC;
                let n = "";
                for (let e = i.constraintIndicator.length - 1; 0 <= e; --e) {
                    const r = i.constraintIndicator[e];
                    if (0 !== r || "" !== n) {
                        const t = r.toString(16).toUpperCase();
                        n = "." + ("" === n ? t : t + n)
                    }
                }
                return r + n
            }
            static parseDvcC(e) {
                let t;
                return e ? t = {
                    versionMajor: e[0],
                    versionMinor: e[1],
                    profile: e[2] >> 1 & 127,
                    level: e[2] << 5 & 32 | e[3] >> 3 & 31
                } : Qe().warn(Je, "No dvcC box"), t
            }
            static dvcCToCodecString(e, t) {
                return e + "." + Ze.checkAndAddLeadingZero(t.profile) + "." + Ze.checkAndAddLeadingZero(t.level)
            }
            static parseVpcC(e) {
                let t;
                return e ? t = {
                    profile: e[4],
                    level: e[5],
                    bitDepth: e[6] >> 4 & 15
                } : Qe().warn(Je, "No vpcC box"), t
            }
            static vpcCToCodecString(e, t) {
                return e + "." + Ze.checkAndAddLeadingZero(t.profile) + "." + Ze.checkAndAddLeadingZero(t.level) + "." + Ze.checkAndAddLeadingZero(t.bitDepth)
            }
            static checkAndAddLeadingZero(e) {
                return (e < 10 ? "0" : "") + e
            }
            static parseInitSegment(e) {
                const c = {
                    foundLargeTimescale: !1,
                    tracksById: {}
                };
                return We.findBoxWithOffset(e, 0, ["moov", "trak"]).forEach(t => {
                    const i = t.data,
                        r = We.findBox(i, ["tkhd"])[0];
                    if (r) {
                        var n = 0 === (a = r[0]) ? 12 : 20,
                            s = We.readUint32(r, n),
                            e = We.findBox(i, ["mdia", "mdhd"])[0];
                        if (e) {
                            var a, o = 0 === (a = e[0]) ? 12 : 20,
                                n = We.readUint32(e, o);
                            o += 4, 1e6 <= n && (c.foundLargeTimescale = !0);
                            const l = 0 === a ? We.readUint32(e, o) : 0,
                                d = We.findBox(i, ["mdia", "hdlr"])[0];
                            if (d) {
                                const r = We.bin2str(d.subarray(8, 12)),
                                    u = {
                                        soun: "audio",
                                        vide: "video",
                                        clcp: "caption"
                                    } [r] || r;
                                if (u) {
                                    const r = We.findBox(i, ["mdia", "minf", "stbl", "stsd"]);
                                    if (r.length) {
                                        const i = r[0];
                                        We.bin2str(i.subarray(12, 16));
                                        o = Ze.parseStsd(i);
                                        let e;
                                        if ("caption" === u) {
                                            const t = Object.assign({
                                                id: s,
                                                type: u,
                                                timescale: n,
                                                duration: l,
                                                isTimingTrack: !1,
                                                sequenceNumber: 0,
                                                captionSamples: []
                                            }, o);
                                            c.caption = t, e = t
                                        } else {
                                            const i = Object.assign({
                                                id: s,
                                                type: u,
                                                timescale: n,
                                                duration: l,
                                                isTimingTrack: !0,
                                                trakOffset: t.offset,
                                                trakSize: t.boxSize,
                                                sequenceNumber: 0,
                                                samples: [],
                                                fragmentDuration: 0
                                            }, o);
                                            "video" === u ? (c.video = i, c.videoCodec = i.codec) : (c.audio = i, c.audioCodec = i.codec), e = i
                                        }
                                        c.tracksById[s] = e
                                    }
                                }
                            }
                        }
                    }
                }), We.findBoxWithOffset(e, 0, ["moov", "mvex", "trex"]).forEach(e => {
                    var t = e.data,
                        e = We.readUint32(t, 4),
                        t = We.readUint32(t, 16);
                    c.tracksById[e].defaultSampleSize = t
                }), c
            }
            static parseStsd(e) {
                let r, t;
                const i = e.subarray(8);
                let n = We.bin2str(i.subarray(4, 8)),
                    s = null,
                    a = null;
                "enca" === n ? (s = We.findBox(i, ["enca"])[0], a = s.subarray(28)) : "encv" === n && (s = We.findBox(i, ["encv"])[0], a = s.subarray(78));
                e = !!a;
                r = 0, a && We.findBox(a, ["sinf"]).forEach(e => {
                    const t = We.findBox(e, ["schm"])[0];
                    if (t) {
                        var i = We.bin2str(t.subarray(4, 8));
                        if ("cbcs" === i || "cenc" === i) {
                            const t = We.findBox(e, ["frma"])[0];
                            t && (n = We.bin2str(t));
                            e = We.findBox(e, ["schi", "tenc"])[0];
                            e && (r = e[7])
                        }
                    }
                });
                let o;
                var l = i.subarray(86);
                switch (n) {
                    case "mp4a":
                        t = "mp4a.40.5";
                        break;
                    case "ac-3":
                    case "ec-3":
                    case "alac":
                    case "fLaC":
                        t = n;
                        break;
                    case "avc1":
                    case "avc3":
                        t = n + ".640028";
                        break;
                    case "hvc1":
                    case "hev1":
                        const d = We.findBox(l, ["hvcC"])[0];
                        o = Ze.parseHvcC(d), t = o ? Ze.hvcCToCodecString(n, o) : n + ".2.4.H150.B0";
                        break;
                    case "dvh1":
                    case "dvhe":
                        const r = We.findBox(l, ["dvcC"])[0];
                        o = Ze.parseDvcC(r), t = o ? Ze.dvcCToCodecString(n, o) : n + ".05.01";
                        break;
                    case "c608":
                        t = n;
                        break;
                    case "vp09":
                        const i = We.findBox(l, ["vpcC"])[0];
                        o = Ze.parseVpcC(i), t = Ze.vpcCToCodecString(n, o);
                        break;
                    default:
                        t = n
                }
                return {
                    codec: t,
                    encrypted: e,
                    defaultPerSampleIVSize: r
                }
            }
            static has32BitTfdts(e) {
                const t = We.findBox(e, ["moof", "traf", "tfdt"]);
                let i = !1;
                return t.forEach(e => {
                    0 === e[0] && (i = !0)
                }), i
            }
            static getStartDtsTs(r, e) {
                const t = We.findBox(e, ["moof", "traf"]);
                let n, s = Number.MAX_SAFE_INTEGER;
                return t.map(function(i) {
                    return We.findBox(i, ["tfhd"]).forEach(e => {
                        var t = We.readUint32(e, 4),
                            e = r.tracksById[t];
                        if (e) {
                            if (!e.isTimingTrack) return 1 / 0;
                            t = e.timescale || 9e4, e = We.findBox(i, ["tfdt"]).map(function(e) {
                                let t;
                                var i = e[0];
                                return t = We.readUint32(e, 4), 1 === i && (t > Ye && Qe().warn(Je, `Value larger than can be represented by float for upper 32 bits ${t}`), t *= Math.pow(2, 32), t += We.readUint32(e, 8)), t
                            }), e = 0 < e.length ? e[0] : 1 / 0;
                            isFinite(e) && e / t < s && (s = e / t, n = {
                                baseTime: e,
                                timescale: t
                            })
                        }
                    })
                }), n
            }
            static offsetStartDTS(r, e, l, n) {
                We.findBox(e, ["moof", "traf"]).map(function(i) {
                    return We.findBox(i, ["tfhd"]).map(function(e) {
                        const t = We.readUint32(e, 4),
                            s = r.tracksById[t];
                        if (s) {
                            const a = s.timescale || 9e4,
                                o = "caption" === s.type ? 0 : n;
                            We.findBox(i, ["tfdt"]).map(function(t) {
                                const i = t[0],
                                    r = s.type;
                                if (0 === i) {
                                    let e = We.readUint32(t, 4) - Math.round(l.baseTime * a / l.timescale);
                                    "video" === r && e < 0 && (Qe().warn(Je, `video tdft would have gone negative by ${e/a} seconds`), e = 0), e += Math.round(o * a), e = Math.max(e, 0), We.writeUint32(t, 4, e)
                                } else {
                                    const i = We.readUint32(t, 4);
                                    i > Ye && Qe().error(Je, `baseMediaDecodeTime larger than can be represented by float for upper 32 bits ${i}`);
                                    let e = i;
                                    e *= Math.pow(2, 32), e += We.readUint32(t, 8), e -= Math.round(l.baseTime * a / l.timescale), "video" === r && e < 0 && (Qe().warn(Je, `video tdft would have gone negative by ${e/a} seconds`), e = 0), e += Math.round(o * a), e = Math.max(e, 0);
                                    const n = Math.floor(e / (1 + Xe)),
                                        s = Math.floor(e % (1 + Xe));
                                    We.writeUint32(t, 4, n), We.writeUint32(t, 8, s)
                                }
                            })
                        }
                    })
                })
            }
            static writeStartDTS(i, e, s) {
                We.findBox(e, ["moof", "traf"]).map(function(t) {
                    return We.findBox(t, ["tfhd"]).map(function(e) {
                        e = We.readUint32(e, 4), e = i.tracksById[e];
                        if (e) {
                            const r = e.timescale || 9e4,
                                n = Math.round(s * r) / r;
                            .01 < Math.abs(n - s) && Qe().warn(Je, `[iframes] large rounding error when adjusting timestamps, startDTS: ${s}, roundedStartDTS: ${n}`), We.findBox(t, ["tfdt"]).map(function(e) {
                                var t, i;
                                0 === e[0] ? We.writeUint32(e, 4, n * r) : (i = n * r, i = Math.max(i, 0), t = Math.floor(i / (1 + Xe)), i = Math.floor(i % (1 + Xe)), We.writeUint32(e, 4, t), We.writeUint32(e, 8, i))
                            })
                        }
                    })
                })
            }
            static parseSAIO(e) {
                let t = 0,
                    i = 0;
                var r = e[0];
                i += 4, 0 != (1 & We.readUint32(e, 0)) && (i += 8);
                var n = 16777215 & We.readUint32(e, i);
                return 1 == n ? (i += 4, t = We.readUint32(e, i), 1 === r && (i += 4, t *= Math.pow(2, 32), t += We.readUint32(e, i))) : Qe().error(Je, `saio entry count error, count is: ${n}`), t
            }
            static parseSAIZ(e) {
                let t = 0,
                    i = 0;
                return i += 4, 0 != (1 & We.readUint32(e, 0)) && (i += 8), t = e[i], i++, i += 4, 0 === t && (t = e[i]), t
            }
            static parseSubsample(e, t) {
                const i = {
                    subsamples: []
                };
                let r = 0;
                for (e && (i.iv = t.subarray(0, e), r += e), r += 2; r + 6 <= t.byteLength;) {
                    const e = We.readUint16(t, r);
                    r += 2;
                    var n = We.readUint32(t, r);
                    r += 4, i.subsamples.push([e, n])
                }
                return i
            }
            static isSEIMessage(e, t) {
                return e ? 39 === t || 40 === t : 6 === t
            }
            static parseCLCPSample(e, t, i) {
                let r = 0;
                const n = [];
                let s = 0;
                for (; r < i;) {
                    var a = t + r,
                        o = We.readUint32(e, a);
                    a += 4;
                    var l = We.bin2str(e.subarray(a, a + 4));
                    if (a += 4, "cdat" !== l) break; {
                        const t = o - 8,
                            d = e.subarray(a, a + t);
                        s += t, n.push(d), r += o
                    }
                }
                return {
                    cdatList: n,
                    cdatTotalSize: s
                }
            }
            static parseSamples(e, S, b, T, E, I) {
                const w = b.timescale,
                    d = b.id;
                let A, O = e,
                    k = 0,
                    C = !1;
                We.findBoxWithOffset(S, 0, ["moof"]).map(function(e) {
                    const t = e.data,
                        v = e.offset;
                    We.findBox(t, ["traf"]).map(function(l) {
                        var e = We.findBox(l, ["tfdt"]).map(function(e) {
                            let t;
                            var i = e[0];
                            return t = We.readUint32(e, 4), 1 === i && (t *= Math.pow(2, 32), t += We.readUint32(e, 8)), t / w
                        })[0];
                        return void 0 !== e && (O = e), We.findBox(l, ["tfhd"]).map(function(e) {
                            var t = We.readUint32(e, 4),
                                i = 16777215 & We.readUint32(e, 0),
                                r = 0 != (1 & i),
                                n = 0 != (2 & i),
                                s = 0 != (8 & i);
                            let g = 0;
                            var a = 0 != (16 & i);
                            let y = 0;
                            i = 0 != (32 & i);
                            let o = 8;
                            if (ne(b.defaultSampleSize) && (y = b.defaultSampleSize), t === d) {
                                if (r && (We.readUint32(e, o), o += 4, We.readUint32(e, o), o += 4), n && (We.readUint32(e, o), o += 4), s && (g = We.readUint32(e, o), o += 4), a && (y = We.readUint32(e, o), o += 4), i && (We.readUint32(e, o), o += 4), "video" === b.type) {
                                    let t = 0,
                                        i = 0;
                                    We.findBox(l, ["saio"]).map(function(e) {
                                        t = Ze.parseSAIO(e)
                                    }), We.findBox(l, ["saiz"]).map(function(e) {
                                        i = Ze.parseSAIZ(e)
                                    }), t && i && (A = Ze.parseSubsample(b.defaultPerSampleIVSize, S.subarray(t, t + i))), C = Ze.isHEVCFlavor(b.codec)
                                }
                                We.findBox(l, ["trun"]).map(function(i) {
                                    var t = i[0],
                                        e = 16777215 & We.readUint32(i, 0),
                                        r = 0 != (1 & e);
                                    let n = 0;
                                    var s = 0 != (4 & e),
                                        a = 0 != (256 & e);
                                    let o = 0;
                                    var l = 0 != (512 & e);
                                    let d = 0;
                                    var u = 0 != (1024 & e),
                                        c = 0 != (2048 & e);
                                    let h = 0;
                                    var p = We.readUint32(i, 4);
                                    let f = 8;
                                    r && (n = We.readUint32(i, f), f += 4), s && (f += 4);
                                    let m = n + v;
                                    for (let e = 0; e < p && (I < 0 || k < I); e++) {
                                        if (a ? (o = We.readUint32(i, f), f += 4) : o = g, l ? (d = We.readUint32(i, f), f += 4) : d = y, u && (f += 4), c && (h = 0 === t ? We.readUint32(i, f) : We.readSint32(i, f), f += 4), "video" === b.type) {
                                            if (ne(T)) b.samples.push({
                                                data: S.subarray(m, m + d),
                                                size: d,
                                                duration: T * w,
                                                cts: 0,
                                                flags: {
                                                    isLeading: 0,
                                                    isDependedOn: 0,
                                                    hasRedundancy: 0,
                                                    degradPrio: 0,
                                                    dependsOn: 2,
                                                    isNonSync: 0,
                                                    paddingValue: 0
                                                },
                                                subsamples: A ? A.subsamples : [],
                                                iv: A ? A.iv : void 0
                                            });
                                            else if (b.fragmentDuration += o, E) {
                                                let e = 0;
                                                for (; e < d;) {
                                                    const T = We.readUint32(S, m);
                                                    m += 4;
                                                    const E = 31 & S[m];
                                                    if (b.seiSamples || (b.seiSamples = []), Ze.isSEIMessage(C, E)) {
                                                        const i = S.subarray(m, m + T);
                                                        b.seiSamples.push({
                                                            pts: O + h / w,
                                                            type: E,
                                                            data: i,
                                                            sampleOffset: m,
                                                            naluSize: T
                                                        })
                                                    }
                                                    m += T, e += T + 4
                                                }
                                            }
                                        } else if ("audio" === b.type) b.fragmentDuration += o;
                                        else if ("caption" === b.type) {
                                            const {
                                                cdatList: i,
                                                cdatTotalSize: T
                                            } = Ze.parseCLCPSample(S, m, d);
                                            if (m += d, i.length) {
                                                let t;
                                                if (1 === i.length) t = new Uint8Array(i[0]);
                                                else if (1 < i.length) {
                                                    let e = 0;
                                                    t = new Uint8Array(T);
                                                    for (const T of i) t.set(T, e), e += T.length
                                                }
                                                b.captionSamples.push({
                                                    type: 3,
                                                    pts: O,
                                                    bytes: t
                                                })
                                            }
                                        }
                                        k++, O += o / w
                                    }
                                })
                            }
                        })
                    })
                })
            }
            static parseEmsg(e) {
                let t, i, r, n, s, a = "",
                    o = "",
                    l = 0;
                if (0 === e[0]) {
                    for (;
                        "\0" !== We.bin2str(e.subarray(l, l + 1));) a += We.bin2str(e.subarray(l, l + 1)), l += 1;
                    for (a += We.bin2str(e.subarray(l, l + 1)), l += 1;
                        "\0" !== We.bin2str(e.subarray(l, l + 1));) o += We.bin2str(e.subarray(l, l + 1)), l += 1;
                    o += We.bin2str(e.subarray(l, l + 1)), l += 1, t = We.readUint32(e, 12), i = We.readUint32(e, 16), n = We.readUint32(e, 20), s = We.readUint32(e, 24), l = 28
                } else {
                    l += 4, t = We.readUint32(e, l), l += 4;
                    const i = We.readUint32(e, l);
                    l += 4;
                    var d = We.readUint32(e, l);
                    for (l += 4, r = Math.pow(2, 32) * i + d, Number.isSafeInteger(r) || (r = Number.MAX_SAFE_INTEGER, Qe().warn(Je, "Presentation time exceeds safe integer limit and wrapped to max safe integer in parsing emsg box")), n = We.readUint32(e, l), l += 4, s = We.readUint32(e, l), l += 4;
                        "\0" !== We.bin2str(e.subarray(l, l + 1));) a += We.bin2str(e.subarray(l, l + 1)), l += 1;
                    for (a += We.bin2str(e.subarray(l, l + 1)), l += 1;
                        "\0" !== We.bin2str(e.subarray(l, l + 1));) o += We.bin2str(e.subarray(l, l + 1)), l += 1;
                    o += We.bin2str(e.subarray(l, l + 1)), l += 1
                }
                return {
                    schemeIdUri: a,
                    value: o,
                    timeScale: t,
                    presentationTime: r,
                    presentationTimeDelta: i,
                    eventDuration: n,
                    id: s,
                    payload: e.subarray(l, e.byteLength)
                }
            }
            static extractID3PayloadCreateID3Track(e, t, i, r) {
                const n = new M(e.payload, r),
                    s = new Uint8Array(e.payload),
                    a = s.byteLength;
                let o = 0,
                    l = 0;
                var d = ne(e.presentationTime) ? e.presentationTime / e.timeScale : t + e.presentationTimeDelta / e.timeScale;
                if (ne(d)) {
                    const c = e.eventDuration,
                        h = s.subarray(0, 10),
                        p = We.bin2str(h.subarray(l, l + 3));
                    l += 3, "ID3" !== p && Qe().error(Je, "No ID3 tag found when extracting ID3 payload"), l += 2;
                    var t = s.subarray(l, l + 1),
                        e = 64 & t[0],
                        u = 16 & t[0];
                    if (l += 1, M.readSynchSafeUint32(s.subarray(l, l + 4)), l += 4, e) {
                        const f = M.readSynchSafeUint32(s.subarray(l, l + 4));
                        l += 4, l += f
                    }
                    for (; l + 2 < a;) {
                        We.bin2str(s.subarray(l, l + 4)), l += 4;
                        const m = M.readSynchSafeUint32(s.subarray(l, l + 4));
                        l += 4;
                        const r = d + o * c,
                            a = {
                                data: s,
                                pts: r,
                                dts: r,
                                keyTagInfo: void 0,
                                frames: n.frames
                            };
                        i.id3Samples.push(a), l += m, o++, u && ("DI3" !== We.bin2str(s.subarray(l, l + 3)) && Qe().error(Je, "End should be DI3 if footer present in extracting ID3 payload"), l += 3, l += 7)
                    }
                    l + 2 === a && 0 !== We.readUint16(s, l) && Qe().warn(Je, "Padding should be 0 when extracting ID3 payload")
                } else Qe().error(Je, "No pts found in emsg info when extracting ID3 payload")
            }
            append(e, t, i, r, n, s, a) {
                let o = this.initData,
                    l = 0,
                    d = 0,
                    u = !1,
                    c = !1;
                void 0 === o && (this.resetInitSegment(e, 0), o = this.initData);
                let h, p = this.initPtsTs;
                p || (h = Ze.getStartDtsTs(o, e), this.initPtsTs = p = {
                    baseTime: h.baseTime - Math.round(t * h.timescale),
                    timescale: h.timescale
                }, this.observer.trigger(v.INIT_PTS_FOUND, {
                    initPTS: p
                })), o.foundLargeTimescale && Ze.has32BitTfdts(e) && !a && (e = ze.remuxOverflowSegment(e, this.logger)), h = Ze.getStartDtsTs(o, e);
                const f = We.findBox(e, ["emsg"]);
                if (o.video && o.video.encrypted && (We.findBox(e, ["moof", "traf"]).find(function(e) {
                        return Boolean(We.findBox(e, ["senc"])[0] || We.findBox(e, ["saiz"])[0] && We.findBox(e, ["saio"])[0])
                    }) || this.logger.warn(Je, `Missing subsample information for encrypted content codec=${o.videoCodec}`)), a) {
                    const t = this._videoTrack.timescale;
                    a = Math.ceil(a * t) / t;
                    const i = (h.baseTime + this.audioPrimingDelay * h.timescale) / h.timescale;
                    if (this._videoTrack && this._audioTrack && !this._silentAudioTrack) {
                        const e = Te.getTrack(this.observer, this._audioTrack.id, this._audioTrack.codec, 2, this.logger);
                        if (!e) throw `unable to create silent audio track for codec ${this._audioTrack.codec}`;
                        this._silentAudioTrack = Object.assign(Object.assign({}, e), {
                            sequenceNumber: 0
                        });
                        const t = ge.initSegment([this._videoTrack, this._silentAudioTrack]);
                        this.remuxedInitDataTrack = {
                            type: "audiovideo",
                            container: "video/mp4",
                            codec: this._silentAudioTrack.config.codec + "," + this._videoTrack.codec,
                            initSegment: t
                        };
                        const i = {
                            track: this.remuxedInitDataTrack
                        };
                        this.observer.trigger(v.FRAG_PARSING_INIT_SEGMENT, i)
                    }
                    Ze.parseSamples(i, e, this._videoTrack, a, !1, 1), this.mp4Remuxer.remuxIFrame(i, this._videoTrack, this._silentAudioTrack, a, this.remuxedInitDataTrack), this._videoTrack.samples = []
                } else {
                    a = (h.baseTime - this.audioPrimingDelay * h.timescale) / h.timescale, a = Math.max(0, a);
                    if (f && 0 < f.length) {
                        const e = f.map(e => {
                            e = Ze.parseEmsg(e);
                            return "https://aomedia.org/emsg/ID3\0" !== e.schemeIdUri || this._id3Track || (this._id3Track = {
                                id3Samples: [],
                                inputTimescale: 9e4
                            }), e
                        });
                        this._id3Track && e.map(e => {
                            Ze.extractID3PayloadCreateID3Track(e, t, this._id3Track, this.logger)
                        })
                    }
                    this._videoTrack && (Ze.parseSamples(a, e, this._videoTrack, void 0, this.trySEICaptions, -1), l = this._videoTrack.fragmentDuration / this._videoTrack.timescale, u = !0, this._videoTrack.fragmentDuration = 0, this.trySEICaptions ? (Ze.extractSEICaptionsFromNALu(this._videoTrack.seiSamples, this._captionTrack), this._videoTrack.seiSamples = []) : this._captionTrack && Ze.parseSamples(a, e, this._captionTrack, void 0, !1, Number.MAX_SAFE_INTEGER)), this._audioTrack && (Ze.parseSamples(a, e, this._audioTrack, void 0, !1, -1), d = this._audioTrack.fragmentDuration / this._audioTrack.timescale, c = !0, this._audioTrack.fragmentDuration = 0), this.mp4Remuxer.remuxEmsgAndRawData(d, c, l, u, this._captionTrack, this._id3Track, a, h.timescale, e, this.remuxedInitDataTrack), this._id3Track && (this._id3Track.id3Samples = [])
                }
            }
            static extractSEICaptionsFromNALu(a, o) {
                if (a) {
                    for (let s = 0; s < a.length; ++s) {
                        var l = a[s],
                            d = l.pts;
                        let t = 0;
                        t++;
                        let e = 0,
                            i = 0,
                            r = !1,
                            n = 0;
                        for (; !r && t < l.data.length;) {
                            for (e = 0; !(t >= l.data.length) && (n = l.data[t++], e += n, 255 === n););
                            for (i = 0; !(t >= l.data.length) && (n = l.data[t++], i += n, 255 === n););
                            const a = l.data.length - t;
                            if (4 === e && t < l.data.length) {
                                if (r = !0, 181 === l.data[t++]) {
                                    const a = We.readUint16(l.data, t);
                                    if (t += 2, 49 === a) {
                                        const a = We.readUint32(l.data, t);
                                        if (t += 4, 1195456820 === a && 3 === l.data[t++]) {
                                            const a = l.data[t++];
                                            t++;
                                            const u = 31 & a,
                                                c = [];
                                            if (64 & a)
                                                for (let e = 0; e < u; e++) {
                                                    const a = l.data[t++];
                                                    if (a === (252 & a)) {
                                                        const o = 3 & a;
                                                        if (0 == o || 1 == o) {
                                                            const a = l.data[t++],
                                                                o = l.data[t++];
                                                            c.push(a), c.push(o)
                                                        }
                                                    } else t += 2
                                                }
                                            0 < c.length && o.captionSamples.push({
                                                type: 3,
                                                pts: d,
                                                bytes: c
                                            })
                                        }
                                    }
                                }
                            } else if (i < a) t += i;
                            else if (i > a) break
                        }
                    }
                    return o
                }
            }
        }
        const et = {
            name: "ExpGolomb"
        };
        class tt {
            constructor(e, t) {
                this.data = e, this.logger = t, this._bytesAvailable = e.byteLength, this.word = 0, this.bitsAvailable = 0
            }
            get bytesAvailable() {
                return this._bytesAvailable
            }
            loadWord() {
                const e = this.data,
                    t = this._bytesAvailable,
                    i = e.byteLength - t,
                    r = new Uint8Array(4),
                    n = Math.min(4, t);
                if (0 === n) throw new Error("no bytes available");
                r.set(e.subarray(i, i + n)), this.word = new DataView(r.buffer).getUint32(0), this.bitsAvailable = 8 * n, this._bytesAvailable -= n
            }
            skipBits(e) {
                var t;
                this.bitsAvailable > e || (t = (e -= this.bitsAvailable) >> 3, e -= t >> 3, this._bytesAvailable -= t, this.loadWord()), this.word <<= e, this.bitsAvailable -= e
            }
            readBits(e) {
                let t = Math.min(this.bitsAvailable, e);
                var i = this.word >>> 32 - t;
                return 32 < e && this.logger.error(et, "Cannot read more than 32 bits at a time"), this.bitsAvailable -= t, 0 < this.bitsAvailable ? this.word <<= t : 0 < this._bytesAvailable && this.loadWord(), t = e - t, 0 < t && this.bitsAvailable ? i << t | this.readBits(t) : i
            }
            skipLZ() {
                let e;
                for (e = 0; e < this.bitsAvailable; ++e)
                    if (0 != (this.word & 2147483648 >>> e)) return this.word <<= e, this.bitsAvailable -= e, e;
                return this.loadWord(), e + this.skipLZ()
            }
            skipUEG() {
                this.skipBits(1 + this.skipLZ())
            }
            skipEG() {
                this.skipBits(1 + this.skipLZ())
            }
            readUEG() {
                var e = this.skipLZ();
                return this.readBits(e + 1) - 1
            }
            readEG() {
                var e = this.readUEG();
                return 1 & e ? 1 + e >>> 1 : -1 * (e >>> 1)
            }
            readBoolean() {
                return 1 === this.readBits(1)
            }
            readUByte() {
                return this.readBits(8)
            }
            readUShort() {
                return this.readBits(16)
            }
            readUInt() {
                return this.readBits(32)
            }
            skipScalingList(e) {
                let t, i, r = 8,
                    n = 8;
                for (t = 0; t < e; t++) 0 !== n && (i = this.readEG(), n = (r + i + 256) % 256), r = 0 === n ? r : n
            }
            readSPS() {
                let e, t, i, r = 0,
                    n = 0,
                    s = 0,
                    a = 0;
                const o = this.readUByte.bind(this),
                    l = this.readBits.bind(this),
                    d = this.readUEG.bind(this),
                    u = this.readBoolean.bind(this),
                    c = this.skipBits.bind(this),
                    h = this.skipEG.bind(this),
                    p = this.skipUEG.bind(this),
                    f = this.skipScalingList.bind(this);
                o();
                var m = o();
                if (l(5), c(3), o(), p(), 100 === m || 110 === m || 122 === m || 244 === m || 44 === m || 83 === m || 86 === m || 118 === m || 128 === m) {
                    const e = d();
                    if (3 === e && c(1), p(), p(), c(1), u())
                        for (t = 3 !== e ? 8 : 12, i = 0; i < t; i++) u() && f(i < 6 ? 16 : 64)
                }
                p();
                var g = d();
                if (0 === g) d();
                else if (1 === g)
                    for (c(1), h(), h(), e = d(), i = 0; i < e; i++) h();
                p(), c(1);
                var y = d(),
                    m = d(),
                    g = l(1);
                0 === g && c(1), c(1), u() && (r = d(), n = d(), s = d(), a = d());
                let v = [1, 1];
                if (u() && u()) switch (o()) {
                    case 1:
                        v = [1, 1];
                        break;
                    case 2:
                        v = [12, 11];
                        break;
                    case 3:
                        v = [10, 11];
                        break;
                    case 4:
                        v = [16, 11];
                        break;
                    case 5:
                        v = [40, 33];
                        break;
                    case 6:
                        v = [24, 11];
                        break;
                    case 7:
                        v = [20, 11];
                        break;
                    case 8:
                        v = [32, 11];
                        break;
                    case 9:
                        v = [80, 33];
                        break;
                    case 10:
                        v = [18, 11];
                        break;
                    case 11:
                        v = [15, 11];
                        break;
                    case 12:
                        v = [64, 33];
                        break;
                    case 13:
                        v = [160, 99];
                        break;
                    case 14:
                        v = [4, 3];
                        break;
                    case 15:
                        v = [3, 2];
                        break;
                    case 16:
                        v = [2, 1];
                        break;
                    case 255:
                        v = [o() << 8 | o(), o() << 8 | o()]
                }
                return {
                    width: Math.ceil(16 * (y + 1) - 2 * r - 2 * n),
                    height: (2 - g) * (m + 1) * 16 - (g ? 2 : 4) * (s + a),
                    pixelRatio: v
                }
            }
            readSliceType() {
                return this.readUByte(), this.readUEG(), this.readUEG()
            }
        }
        const it = {
            name: "TS Demuxer"
        };
        var rt, nt = class extends c {
            constructor(e, t, i, r, n) {
                super(e, t, i, r, n)
            }
            static probe(e, t) {
                return 564 <= e.length && 71 === e[0] && 71 === e[188] && 71 === e[376]
            }
            resetInitSegment(e, t, i) {
                this.pmtParsed = !1;
                var r = {
                        id: this._pmtId = -1,
                        inputTimescale: 9e4,
                        timescale: NaN,
                        duration: 0,
                        encrypted: i && i.isEncrypted,
                        keyTagInfo: i
                    },
                    i = {
                        len: 0,
                        sequenceNumber: 0
                    };
                this._avcContext = {
                    info: Object.assign({}, r),
                    parsingData: Object.assign(Object.assign({}, i), {
                        esSamples: new Array,
                        dropped: 0
                    }),
                    config: {},
                    container: "video/mp2t",
                    type: "video"
                }, this._audioContext = {
                    info: Object.assign({}, r),
                    parsingData: Object.assign(Object.assign({}, i), {
                        esSamples: new Array
                    }),
                    container: "video/mp2t",
                    type: "audio"
                }, this._id3Track = {
                    id: -1,
                    inputTimescale: 9e4,
                    id3Samples: []
                }, this._txtTrack = {
                    inputTimescale: 9e4,
                    captionSamples: []
                }, this._duration = t, this._initSegment = e
            }
            append(e, t, i, r, n, s, a) {
                let o, l, d, u, c, h = !1;
                this.contiguous = i;
                const p = this._avcContext,
                    f = this._audioContext,
                    m = this._id3Track;
                let g = this.pmtParsed,
                    y = p.info.id,
                    v = f.info.id,
                    S = m.id,
                    b = this._pmtId,
                    T = p.pesData,
                    E = f.pesData,
                    I = m.pesData;
                if (this.iframeMode = void 0 !== a, this._initSegment && 0 < this._initSegment.byteLength) {
                    const t = new Uint8Array(this._initSegment.byteLength + e.byteLength);
                    t.set(this._initSegment), t.set(e, this._initSegment.byteLength), this._initSegment = void 0, 71 === t[0] && (e = t)
                }
                let w, A, O = e.length;
                for (O -= O % 188, o = 0; o < O; o += 188) {
                    if (71 !== e[o]) {
                        const e = new D(!1, "TS packet did not start with 0x47", $.NoTSSyncByteFound);
                        return void this.observer.trigger(x.INTERNAL_ERROR, e)
                    }
                    if (l = !!(64 & e[o + 1]), d = ((31 & e[o + 1]) << 8) + e[o + 2], 1 < (48 & e[o + 3]) >> 4) {
                        if (u = o + 5 + e[o + 4], u === o + 188) continue
                    } else u = o + 4;
                    switch (d) {
                        case y:
                            l && (T && (c = this._parsePES(T)) && this._parseAVCPES(c, !1), T = {
                                data: [],
                                size: 0,
                                keyTagInfo: n
                            }), T && (T.data.push(e.subarray(u, o + 188)), T.size += o + 188 - u);
                            break;
                        case v:
                            if (l && !this.iframeMode) {
                                if (E && (c = this._parsePES(E))) switch (f.segmentCodec) {
                                    case "aac":
                                        this._parseAACPES(c);
                                        break;
                                    case "mp3":
                                        this._parseMPEGPES(c);
                                        break;
                                    case "ac3":
                                    case "ec3":
                                        this._parseDolbyPES(c)
                                }
                                E = {
                                    data: [],
                                    size: 0,
                                    keyTagInfo: n
                                }
                            }
                            E && (E.data.push(e.subarray(u, o + 188)), E.size += o + 188 - u);
                            break;
                        case S:
                            l && (I && (c = this._parsePES(I)) && m.id3Samples.push(c), I = {
                                data: [],
                                size: 0
                            }), I && (I.data.push(e.subarray(u, o + 188)), I.size += o + 188 - u);
                            break;
                        case 0:
                            l && (u += e[u] + 1), b = this._pmtId = this._parsePAT(e, u);
                            break;
                        case b:
                            l && (u += e[u] + 1);
                            const t = this._parsePMT(e, u, this.typeSupported);
                            y = t.avcId, 0 < y && (p.info.id = y, p.info.encrypted = t.videoEncrypted), v = t.audioId, 0 < v && (f.info.id = v, f.segmentCodec = t.audioSegmentCodec, f.info.encrypted = t.audioEncrypted), S = t.id3Id, 0 < S && (m.id = S), h && !g && (h = !1, o = -188), g = this.pmtParsed = !0;
                            break;
                        case 17:
                        case 8191:
                            break;
                        default:
                            h = !0
                    }
                }
                if (T && (c = this._parsePES(T)) ? (this._parseAVCPES(c, !0), p.pesData = void 0) : p.pesData = T, E && (c = this._parsePES(E))) {
                    switch (f.segmentCodec) {
                        case "aac":
                            this._parseAACPES(c);
                            break;
                        case "mp3":
                            this._parseMPEGPES(c);
                            break;
                        case "ac3":
                        case "ec3":
                            this._parseDolbyPES(c)
                    }
                    f.pesData = void 0
                } else E && E.size && this.logger.warn(it, "last AAC PES packet truncated,might overlap between fragments"), f.pesData = E;
                I && (c = this._parsePES(I)) ? (m.id3Samples.push(c), m.pesData = void 0) : m.pesData = I, f.config && f.segmentCodec && (w = {
                    type: "audio",
                    info: f.info,
                    config: f.config,
                    parsingData: f.parsingData
                });
                var k, C = p.config;
                "string" == typeof(k = C).codec && Array.isArray(k.sps) && Array.isArray(k.pps) && "number" == typeof k.width && "number" == typeof k.height && Array.isArray(k.pixelRatio) && (A = {
                    type: "video",
                    info: p.info,
                    config: C,
                    parsingData: p.parsingData
                }), this.esRemuxer.remuxEsTracks(w, A, m, this._txtTrack, t, i, r, n, s, a)
            }
            destroy() {
                this._duration = 0
            }
            _parsePAT(e, t) {
                return (31 & e[t + 10]) << 8 | e[t + 11]
            }
            _parsePMT(e, t, i) {
                var r;
                const n = {
                        audioId: -1,
                        avcId: -1,
                        id3Id: -1,
                        audioEncrypted: !1,
                        videoEncrypted: !1
                    },
                    s = t + 3 + ((15 & e[t + 1]) << 8 | e[t + 2]) - 4;
                for (t += 12 + ((15 & e[t + 10]) << 8 | e[t + 11]); t < s;) {
                    switch (r = (31 & e[t + 1]) << 8 | e[t + 2], e[t]) {
                        case 207:
                            n.audioEncrypted = !0;
                        case 15:
                            -1 === n.audioId && (n.audioId = r, n.audioSegmentCodec = "aac");
                            break;
                        case 21:
                            -1 === n.id3Id && (n.id3Id = r);
                            break;
                        case 219:
                            n.videoEncrypted = !0;
                        case 27:
                            -1 === n.avcId && (n.avcId = r);
                            break;
                        case 3:
                        case 4:
                            !0 !== i.mpeg && !0 !== i.mp3 ? this.logger.warn(it, "MPEG audio found, not supported in this browser for now") : -1 === n.audioId && (n.audioId = r, n.audioSegmentCodec = "mp3");
                            break;
                        case 193:
                            n.audioEncrypted = !0;
                        case 129:
                            !0 !== i.ac3 ? this.logger.warn(it, "AC-3 audio found, not supported in this browser for now") : -1 === n.audioId && (n.audioId = r, n.audioSegmentCodec = "ac3");
                            break;
                        case 194:
                            n.audioEncrypted = !0;
                        case 135:
                            !0 !== i.ec3 ? this.logger.warn(it, "EC-3 audio found, not supported in this browser for now") : -1 === n.audioId && (n.audioId = r, n.audioSegmentCodec = "ec3");
                            break;
                        case 36:
                            this.logger.warn(it, "HEVC stream type found, not supported for now");
                            break;
                        default:
                            this.logger.warn(it, "unkown stream type:" + e[t])
                    }
                    t += 5 + ((15 & e[t + 3]) << 8 | e[t + 4])
                }
                return n
            }
            _parsePES(e) {
                let i, t, r, n, s, a, o = 0;
                const l = e.data,
                    d = e.keyTagInfo;
                let u = NaN,
                    c = NaN;
                if (e && 0 !== e.size) {
                    for (; l[0].length < 19 && 1 < l.length;) {
                        const e = new Uint8Array(l[0].length + l[1].length);
                        e.set(l[0]), e.set(l[1], l[0].length), l[0] = e, l.splice(1, 1)
                    }
                    if (i = l[0], 1 === (i[0] << 16) + (i[1] << 8) + i[2] && (r = (i[4] << 8) + i[5], !(r && r > e.size - 6))) {
                        192 & (t = i[7]) && (u = 536870912 * (14 & i[9]) + 4194304 * (255 & i[10]) + 16384 * (254 & i[11]) + 128 * (255 & i[12]) + (254 & i[13]) / 2, 64 & t ? (c = 536870912 * (14 & i[14]) + 4194304 * (255 & i[15]) + 16384 * (254 & i[16]) + 128 * (255 & i[17]) + (254 & i[18]) / 2, 54e5 < u - c && (this.logger.warn(it, `${Math.round((u-c)/9e4)}s delta between PTS and DTS, align them`), u = c)) : c = u), n = i[8], a = n + 9, e.size -= a, s = new Uint8Array(e.size);
                        for (let t = 0, e = l.length; t < e; t++) {
                            i = l[t];
                            let e = i.byteLength;
                            if (a) {
                                if (a > e) {
                                    a -= e;
                                    continue
                                }
                                i = i.subarray(a), e -= a, a = 0
                            }
                            s.set(i, o), o += e
                        }
                        return r && (r -= n + 3), {
                            data: s,
                            pts: u,
                            dts: c,
                            len: r,
                            keyTagInfo: d
                        }
                    }
                }
            }
            pushAccesUnit(e, t) {
                const i = e.avcSample;
                if (i && i.units.length && i.frame) {
                    const r = e.parsingData.esSamples,
                        n = r.length;
                    (!0 === i.key || e.config.sps && (n || this.contiguous)) && (i.id = n, i.keyTagInfo = t, e.info.encrypted) && i.units.forEach(e => {
                        if (48 < e.data.byteLength) switch (e.type) {
                            case 1:
                            case 5:
                                e.data = this.discardEPB(e.data)
                        }
                    }), n || isFinite(i.pts) ? r.push(i) : e.parsingData.dropped++
                }
            }
            _parseAVCPES(o, e) {
                if (!o.data) throw "invalid pes data";
                const l = this._avcContext,
                    t = this._parseAVCNALu(o.data);
                let d, u, c, h = l.avcSample;
                const p = o.keyTagInfo;
                o.data = void 0, t.forEach(n => {
                    switch (n.type) {
                        case 1:
                            if (h && !this.iframeMode) {
                                u = !0, h.frame = !0;
                                const o = n.data;
                                if (4 < o.length) {
                                    const n = new tt(o, this.logger).readSliceType();
                                    2 !== n && 4 !== n && 7 !== n && 9 !== n || (h.key = !0)
                                }
                            }
                            break;
                        case 5:
                            u = !0, h && (h = h || (l.avcSample = this._createAVCSample(!0, o.pts, o.dts, "")), h.key = !0, h.frame = !0);
                            break;
                        case 6:
                            u = !0, d = new tt(this.discardEPB(n.data), this.logger), d.readUByte();
                            let e = 0,
                                t = 0,
                                i = !1,
                                r = 0;
                            for (; !i && 1 < d.bytesAvailable;) {
                                for (e = 0; r = d.readUByte(), e += r, 255 === r;);
                                for (t = 0; r = d.readUByte(), t += r, 255 === r;);
                                if (4 === e && 0 !== d.bytesAvailable) {
                                    if (i = !0, 181 === d.readUByte() && 49 === d.readUShort() && 1195456820 === d.readUInt() && 3 === d.readUByte()) {
                                        const n = d.readUByte(),
                                            l = 31 & n,
                                            s = [n, d.readUByte()];
                                        for (c = 0; c < l; c++) s.push(d.readUByte()), s.push(d.readUByte()), s.push(d.readUByte());
                                        this._insertSampleInOrder(this._txtTrack.captionSamples, {
                                            type: 3,
                                            pts: o.pts,
                                            bytes: s
                                        })
                                    }
                                } else if (t < d.bytesAvailable)
                                    for (c = 0; c < t; c++) d.readUByte()
                            }
                            break;
                        case 7:
                            if (u = !0, !l.config.sps) {
                                d = new tt(n.data, this.logger);
                                const o = d.readSPS();
                                l.config.width = o.width, l.config.height = o.height, l.config.pixelRatio = o.pixelRatio, l.config.sps = [n.data], l.info.duration = this._duration;
                                const a = n.data.subarray(1, 4);
                                let t = "avc1.";
                                for (c = 0; c < 3; c++) {
                                    let e = a[c].toString(16);
                                    e.length < 2 && (e = "0" + e), t += e
                                }
                                l.config.codec = t
                            }
                            break;
                        case 8:
                            u = !0, l.config.pps || (l.config.pps = [n.data]);
                            break;
                        case 9:
                            u = !1, h && this.pushAccesUnit(l, p), h = l.avcSample = this._createAVCSample(!1, o.pts, o.dts, "");
                            break;
                        case 12:
                            u = !1;
                            break;
                        default:
                            u = !1, h && (h.debug += "unknown NAL " + n.type + " ")
                    }
                    h && u && h.units.push(n)
                }), e && h && (this.pushAccesUnit(l, p), l.avcSample = void 0)
            }
            _createAVCSample(e, t, i, r) {
                return {
                    id: NaN,
                    key: e,
                    pts: t,
                    dts: i,
                    units: new Array,
                    debug: r
                }
            }
            _insertSampleInOrder(t, i) {
                var r = t.length;
                if (0 < r) {
                    if (i.pts >= t[r - 1].pts) t.push(i);
                    else
                        for (let e = r - 1; 0 <= e; e--)
                            if (i.pts < t[e].pts) {
                                t.splice(e, 0, i);
                                break
                            }
                } else t.push(i)
            }
            _getLastNalUnit() {
                const e = this._avcContext;
                let t, i = e.avcSample;
                if (!i || 0 === i.units.length) {
                    const t = e.parsingData.esSamples;
                    i = t[t.length - 1]
                }
                if (i) {
                    const e = i.units;
                    t = e[e.length - 1]
                }
                return t
            }
            _parseAVCNALu(e) {
                const t = e.byteLength;
                let i, r, n = 0;
                const s = this._avcContext;
                let a = s.naluState || 0;
                const o = a,
                    l = [];
                let d, u, c, h = -1;
                for (-1 === a && (h = 0, c = 31 & e[0], a = 0, n = 1); n < t;)
                    if (i = e[n++], a)
                        if (1 !== a)
                            if (i)
                                if (1 === i) {
                                    if (0 <= h) d = {
                                        data: e.subarray(h, n - a - 1),
                                        type: c
                                    }, l.push(d);
                                    else {
                                        const t = this._getLastNalUnit();
                                        if (t && (o && n <= 4 - o && t.state && (t.data = t.data.subarray(0, t.data.byteLength - o)), r = n - a - 1, 0 < r)) {
                                            const i = new Uint8Array(t.data.byteLength + r);
                                            i.set(t.data, 0), i.set(e.subarray(0, r), t.data.byteLength), t.data = i, t.state = 0
                                        }
                                    }
                                    a = n < t ? (u = 31 & e[n], h = n, c = u, 0) : -1
                                } else a = 0;
                else a = 3;
                else a = i ? 0 : 2;
                else a = i ? 0 : 1;
                if (0 <= h && 0 <= a && (d = {
                        data: e.subarray(h, t),
                        type: c,
                        state: a
                    }, l.push(d)), 0 === l.length) {
                    const t = this._getLastNalUnit();
                    if (t) {
                        const i = new Uint8Array(t.data.byteLength + e.byteLength);
                        i.set(t.data, 0), i.set(e, t.data.byteLength), t.data = i
                    }
                }
                return s.naluState = a, l
            }
            discardEPB(e) {
                const t = e.byteLength,
                    i = [];
                let r = 1;
                for (; r < t - 2;) 0 === e[r] && 0 === e[r + 1] && 3 === e[r + 2] ? (i.push(r + 2), r += 2) : r++;
                if (0 === i.length) return e;
                const n = t - i.length,
                    s = new Uint8Array(n);
                let a = 0;
                for (r = 0; r < n; a++, r++) a === i[0] && (a++, i.shift()), s[r] = e[a];
                return s
            }
            _parseAACPES(e) {
                const t = this._audioContext,
                    i = t.audioLastPTS,
                    r = e.keyTagInfo;
                let n, s, a, o, l, d, u, c = e.data,
                    h = e.pts,
                    p = t.audioOverFlow;
                if (p) {
                    const e = new Uint8Array(p.byteLength + c.byteLength);
                    e.set(p, 0), e.set(c, p.byteLength), c = e
                }
                for (a = 0, d = c.length; a < d - 1 && (255 !== c[a] || 240 != (240 & c[a + 1])); a++);
                if (a) {
                    let e, t, i;
                    i = a < d - 1 ? (e = `AAC PES did not start with ADTS header,offset:${a}`, t = !1, $.PESDidNotStartWithADTS) : (e = "no ADTS header found in AAC PES", t = !0, $.NoADTSHeaderInPES), this.logger.warn(it, `parsing error:${e}`);
                    const r = new D(t, e, i);
                    if (this.observer.trigger(x.INTERNAL_ERROR, r), t) return
                }
                if (!t.config) {
                    const e = E(this.observer, c, a, void 0, this.logger);
                    if (!e) throw "unable to parse adts header";
                    t.config = e
                }
                s = 0;
                var f = 9216e4 / t.config.samplerate;
                if (p && i) {
                    const e = i + f;
                    1 < Math.abs(e - h) && (h = e)
                }
                for (; a + 5 < d && (o = 1 & c[a + 1] ? 7 : 9, n = (3 & c[a + 3]) << 11 | c[a + 4] << 3 | (224 & c[a + 5]) >>> 5, n -= o, 0 < n && a + o + n <= d);)
                    for (l = h + s * f, u = {
                            unit: c.subarray(a + o, a + o + n),
                            pts: l,
                            dts: l,
                            keyTagInfo: r
                        }, t.parsingData.esSamples.push(u), t.parsingData.len += n, a += n + o, s++; a < d - 1 && (255 !== c[a] || 240 != (240 & c[a + 1])); a++);
                p = a < d ? c.subarray(a, d) : void 0, t.audioOverFlow = p, t.audioLastPTS = l
            }
            _parseMPEGPES(e) {
                "mp3" === this._audioContext.segmentCodec && ee.parse(this._audioContext.parsingData, e.data, 0, e.pts, this.logger)
            }
            _parseDolbyPES(e) {
                const t = this._audioContext;
                let i = e.data,
                    r = e.pts;
                var n = e.keyTagInfo;
                let s = 0,
                    a = 0,
                    o = t.audioOverFlow;
                e = t.audioLastPTS;
                if (!t.config) {
                    let e;
                    if ("ac3" === t.segmentCodec ? e = j(this.observer, i, a, this.logger) : "ec3" === t.segmentCodec && (e = Y(this.observer, i, a, this.logger)), !e) throw "unable to parse dolby header";
                    t.config = e
                }
                if ("ac3" !== t.config.segmentCodec && "ec3" !== t.config.segmentCodec) throw "unexpected config type";
                var l = 1536 / t.config.samplerate * t.info.inputTimescale;
                if (o) {
                    const c = new Uint8Array(o.byteLength + i.byteLength);
                    c.set(o, 0), c.set(i, o.byteLength), i = c
                }
                var d = i.length;
                if (o && e) {
                    const c = e + l;
                    1 < Math.abs(c - r) && (r = c)
                }
                let u = 0;
                for (; a + u <= d;) {
                    if (11 !== i[a] || 119 !== i[a + 1]) {
                        const c = new D(!0, "invalid dolby audio magic", $.InvalidDolbyAudioMagic);
                        return void this.observer.trigger(x.INTERNAL_ERROR, c)
                    }
                    "ac3" === t.segmentCodec ? u = Q(this.observer, i, a) : "ec3" === t.segmentCodec && (u = X(this.observer, i, a, this.logger));
                    const c = r + s * l;
                    t.audioLastPTS = c;
                    const o = {
                        unit: i.subarray(a, a + u),
                        pts: c,
                        dts: c,
                        keyTagInfo: n
                    };
                    t.parsingData.esSamples.push(o), t.info.duration = this._duration, t.parsingData.len += u, a += u, s++
                }
                o = a < d ? i.subarray(a, d) : void 0, t.audioOverFlow = o
            }
        };
        class st extends a {
            constructor(e, t, i, r) {
                super(), this.typeSupported = e, this.config = t, this.vendor = i, this.logger = r
            }
            destroy() {
                this.removeAllListeners();
                const e = this.demuxer,
                    t = this.remuxer;
                e && e.destroy(), t && t.destroy()
            }
            push(t, i, r, n, s, a, o, l, d, u, c, h) {
                if (t) {
                    let e = this.demuxer;
                    var p = new Uint8Array(t);
                    if (!e || (s || a) && !this.probeFn(p, this.logger)) {
                        const {
                            typeSupported: t,
                            config: i
                        } = this, r = [{
                            demux: Ze,
                            remux: ze
                        }, {
                            demux: nt,
                            remux: Ee
                        }, {
                            demux: J,
                            remux: Ee
                        }, {
                            demux: z,
                            remux: Ee
                        }, {
                            demux: K,
                            remux: Ee
                        }, {
                            demux: ie,
                            remux: Ee
                        }];
                        for (const n of r) {
                            const r = n.demux["probe"];
                            if (r(p, this.logger)) {
                                this.remuxer = new n.remux(this, i, t, this.vendor, this.logger), e = new n.demux(this, this.remuxer, i, t, this.logger), this.probeFn = r;
                                break
                            }
                        }
                        if (!e) {
                            const t = new D(!0, "no demux matching with content found", $.DemuxerNotFound);
                            return void this.trigger(x.INTERNAL_ERROR, t)
                        }
                        this.demuxer = e
                    }
                    const f = this.remuxer,
                        m = !this.lastKeyTagInfo || i && "NONE" !== i.method && this.lastKeyTagInfo.uri !== i.uri;
                    if (this.lastKeyTagInfo = i, (s || a || m) && (e.resetInitSegment(new Uint8Array(r), l, i, s), f.resetInitSegment()), s) {
                        const t = u ? S(u) : void 0;
                        e.resetTimeStamp(t), f.resetTimeStamp(t)
                    }
                    e.append(p, n, o, d, i, c, h)
                }
            }
        }

        function at() {
            let e = `${Date.now()}-${Math.random()}`;
            return "undefined" != typeof performance && "function" == typeof performance.now && (e += `-${performance.now()}`), e
        }
        class ot {
            constructor(e, t) {
                this.rpc = e, this.logger = t, this.init = (t, n, s) => e => {
                    const i = at(),
                        r = this.demuxers[i] = new st(t, n, s, this.logger);
                    [v.INIT_PTS_FOUND, v.FRAG_PARSING_INIT_SEGMENT, v.FRAG_PARSING_DATA, v.FRAG_PARSED, x.INTERNAL_ERROR].forEach(t => {
                        r.on(t, e => this.rpc.invoke("demuxer.event", [i, t, e])(() => {}))
                    }), e(i)
                }, this.push = (i, r, n, s, a, o, l, d, u, c, h, p, f) => e => {
                    const t = this.demuxers[i];
                    t ? (t.push(r, n, s, a, o, l, d, u, c, h, p, f), e()) : e(void 0, `Demuxer with id "${i}" does not exist on push`)
                }, this.destroy = i => e => {
                    const t = this.demuxers[i];
                    t ? (t.destroy(), delete this.demuxers[i], e()) : this.logger.error(`Demuxer with id "${i}" does not exist on destroy`)
                }, this.demuxers = {}, e.register("demuxer.init", this.init), e.register("demuxer.push", this.push), e.register("demuxer.destroy", this.destroy)
            }
        }
        class lt {
            constructor(e) {
                this.worker = e, this.handlers = {}, this.deferers = {}, this._messageHandler = e => {
                    var {
                        type: t,
                        id: i,
                        command: r,
                        args: n,
                        result: e,
                        error: s
                    } = e.data;
                    if (t === rt.Invoke) try {
                        if (null == this.handlers[r]) throw new Error(`command ${r} not found`);
                        this.handlers[r](...n)(this._respond.bind(this, i, r))
                    } catch (s) {
                        this._respond(i, r, null, new Error(`command ${r} not found`))
                    } else t === rt.Result && null != this.deferers[i] && (this.deferers[i](e, s), delete this.deferers[i])
                }, e.addEventListener("message", this._messageHandler)
            }
            register(e, t) {
                if (null != this.handlers[e]) return !1;
                this.handlers[e] = t
            }
            unregister(e) {
                if (null != this.handlers[e]) return !1;
                delete this.handlers[e]
            }
            invoke(i, r, n) {
                return (e = lt._fallbackCallback) => {
                    var t = at();
                    this.deferers[t] = e;
                    t = {
                        type: rt.Invoke,
                        id: t,
                        command: i,
                        args: r
                    };
                    this._send(t, n)
                }
            }
            teardown(e) {
                this.worker.removeEventListener("message", this._messageHandler), e()
            }
            _respond(e, t, i, r, n) {
                r instanceof Error && (r = `[${r.name}] ${r.message}\n${r.stack}`);
                r = {
                    type: rt.Result,
                    id: e,
                    command: t,
                    result: i,
                    error: r
                };
                this._send(r, n)
            }
            _send(e, t = []) {
                this.worker.postMessage(e, t.map(e => ArrayBuffer.isView(e) ? e.buffer : e).filter(e => void 0 !== e))
            }
        }
        lt._fallbackCallback = (e, t) => {
            if (null != t) throw t
        }, (vr = rt = rt || {})[vr.Invoke = 0] = "Invoke", vr[vr.Result = 1] = "Result", ArrayBuffer.isView || (ArrayBuffer.isView = function(e) {
            return null !== e && "object" == typeof e && e.buffer instanceof ArrayBuffer
        }), void 0 !== Yy && Yy && (Vr = new lt(l), iu = (n => {
            const t = (i = []) => {
                const r = {};
                return ["fatal", "error", "warn", "info", "debug", "trace", "qe"].forEach(e => {
                    return r[e] = (t = e, (...e) => {
                        n.invoke("logger.log", [i, t, ...e])((e, t) => {
                            if (null != t) throw t
                        })
                    });
                    var t
                }), r.child = e => t([...i, e]), r
            };
            return t()
        })(Vr), new i(Vr, iu), new ot(Vr, iu));
        var dt = function(e, t) {
            return (dt = Object.setPrototypeOf || {
                    __proto__: []
                }
                instanceof Array && function(e, t) {
                    e.__proto__ = t
                } || function(e, t) {
                    for (var i in t) Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i])
                })(e, t)
        };

        function ut(e, t) {
            if ("function" != typeof t && null !== t) throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");

            function i() {
                this.constructor = e
            }
            dt(e, t), e.prototype = null === t ? Object.create(t) : (i.prototype = t.prototype, new i)
        }
        var ct = function() {
            return (ct = Object.assign || function(e) {
                for (var t, i = 1, r = arguments.length; i < r; i++)
                    for (var n in t = arguments[i]) Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]);
                return e
            }).apply(this, arguments)
        };

        function ht(e, t, i, r) {
            var n, s = arguments.length,
                a = s < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, i) : r;
            if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, i, r);
            else
                for (var o = e.length - 1; 0 <= o; o--)(n = e[o]) && (a = (s < 3 ? n(a) : 3 < s ? n(t, i, a) : n(t, i)) || a);
            return 3 < s && a && Object.defineProperty(t, i, a), a
        }

        function pt(e, t) {
            if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(e, t)
        }

        function ft(e) {
            var t = "function" == typeof Symbol && Symbol.iterator,
                i = t && e[t],
                r = 0;
            if (i) return i.call(e);
            if (e && "number" == typeof e.length) return {
                next: function() {
                    return {
                        value: (e = e && r >= e.length ? void 0 : e) && e[r++],
                        done: !e
                    }
                }
            };
            throw new TypeError(t ? "Object is not iterable." : "Symbol.iterator is not defined.")
        }

        function mt(e, t) {
            var i = "function" == typeof Symbol && e[Symbol.iterator];
            if (!i) return e;
            var r, n, s = i.call(e),
                a = [];
            try {
                for (;
                    (void 0 === t || 0 < t--) && !(r = s.next()).done;) a.push(r.value)
            } catch (e) {
                n = {
                    error: e
                }
            } finally {
                try {
                    r && !r.done && (i = s.return) && i.call(s)
                } finally {
                    if (n) throw n.error
                }
            }
            return a
        }

        function gt() {
            for (var e = [], t = 0; t < arguments.length; t++) e = e.concat(mt(arguments[t]));
            return e
        }

        function yt(e) {
            return "function" == typeof e
        }
        var vt = !1,
            St = {
                Promise: void 0,
                set useDeprecatedSynchronousErrorHandling(e) {
                    vt = e
                },
                get useDeprecatedSynchronousErrorHandling() {
                    return vt
                }
            };

        function bt(e) {
            setTimeout(function() {
                throw e
            }, 0)
        }
        var Tt = {
                closed: !0,
                next: function(e) {},
                error: function(e) {
                    if (St.useDeprecatedSynchronousErrorHandling) throw e;
                    bt(e)
                },
                complete: function() {}
            },
            Et = Array.isArray || function(e) {
                return e && "number" == typeof e.length
            };

        function It(e) {
            return null !== e && "object" == typeof e
        }
        var wt = (kt.prototype = Object.create(Error.prototype), kt),
            At = (Ot.prototype.unsubscribe = function() {
                var t;
                if (!this.closed) {
                    var e = this._parentOrParents,
                        i = this._ctorUnsubscribe,
                        r = this._unsubscribe,
                        n = this._subscriptions;
                    if (this.closed = !0, this._parentOrParents = null, this._subscriptions = null, e instanceof Ot) e.remove(this);
                    else if (null !== e)
                        for (var s = 0; s < e.length; ++s) e[s].remove(this);
                    if (yt(r)) {
                        i && (this._unsubscribe = void 0);
                        try {
                            r.call(this)
                        } catch (e) {
                            t = e instanceof wt ? Ct(e.errors) : [e]
                        }
                    }
                    if (Et(n))
                        for (var s = -1, a = n.length; ++s < a;) {
                            var o = n[s];
                            if (It(o)) try {
                                o.unsubscribe()
                            } catch (e) {
                                t = t || [], e instanceof wt ? t = t.concat(Ct(e.errors)) : t.push(e)
                            }
                        }
                    if (t) throw new wt(t)
                }
            }, Ot.prototype.add = function(e) {
                var t, i = e;
                if (!e) return Ot.EMPTY;
                switch (typeof e) {
                    case "function":
                        i = new Ot(e);
                    case "object":
                        if (i === this || i.closed || "function" != typeof i.unsubscribe) return i;
                        if (this.closed) return i.unsubscribe(), i;
                        i instanceof Ot || (t = i, (i = new Ot)._subscriptions = [t]);
                        break;
                    default:
                        throw new Error("unrecognized teardown " + e + " added to Subscription.")
                }
                var r = i._parentOrParents;
                if (null === r) i._parentOrParents = this;
                else if (r instanceof Ot) {
                    if (r === this) return i;
                    i._parentOrParents = [r, this]
                } else {
                    if (-1 !== r.indexOf(this)) return i;
                    r.push(this)
                }
                r = this._subscriptions;
                return null === r ? this._subscriptions = [i] : r.push(i), i
            }, Ot.prototype.remove = function(e) {
                var t = this._subscriptions;
                !t || -1 !== (e = t.indexOf(e)) && t.splice(e, 1)
            }, Ot.EMPTY = ((dl = new Ot).closed = !0, dl), Ot);

        function Ot(e) {
            this.closed = !1, this._parentOrParents = null, this._subscriptions = null, e && (this._ctorUnsubscribe = !0, this._unsubscribe = e)
        }

        function kt(e) {
            return Error.call(this), this.message = e ? e.length + " errors occurred during unsubscription:\n" + e.map(function(e, t) {
                return t + 1 + ") " + e.toString()
            }).join("\n  ") : "", this.name = "UnsubscriptionError", this.errors = e, this
        }

        function Ct(e) {
            return e.reduce(function(e, t) {
                return e.concat(t instanceof wt ? t.errors : t)
            }, [])
        }
        var Dt, Mt, xt = "function" == typeof Symbol ? Symbol("rxSubscriber") : "@@rxSubscriber_" + Math.random(),
            Pt = (ut(_t, Mt = At), _t.prototype[xt] = function() {
                return this
            }, _t.create = function(e, t, i) {
                i = new _t(e, t, i);
                return i.syncErrorThrowable = !1, i
            }, _t.prototype.next = function(e) {
                this.isStopped || this._next(e)
            }, _t.prototype.error = function(e) {
                this.isStopped || (this.isStopped = !0, this._error(e))
            }, _t.prototype.complete = function() {
                this.isStopped || (this.isStopped = !0, this._complete())
            }, _t.prototype.unsubscribe = function() {
                this.closed || (this.isStopped = !0, Mt.prototype.unsubscribe.call(this))
            }, _t.prototype._next = function(e) {
                this.destination.next(e)
            }, _t.prototype._error = function(e) {
                this.destination.error(e), this.unsubscribe()
            }, _t.prototype._complete = function() {
                this.destination.complete(), this.unsubscribe()
            }, _t.prototype._unsubscribeAndRecycle = function() {
                var e = this._parentOrParents;
                return this._parentOrParents = null, this.unsubscribe(), this.closed = !1, this.isStopped = !1, this._parentOrParents = e, this
            }, _t),
            Rt = (ut(Lt, Dt = Pt), Lt.prototype.next = function(e) {
                var t;
                !this.isStopped && this._next && (t = this._parentSubscriber, St.useDeprecatedSynchronousErrorHandling && t.syncErrorThrowable ? this.__tryOrSetError(t, this._next, e) && this.unsubscribe() : this.__tryOrUnsub(this._next, e))
            }, Lt.prototype.error = function(e) {
                if (!this.isStopped) {
                    var t = this._parentSubscriber,
                        i = St.useDeprecatedSynchronousErrorHandling;
                    if (this._error) i && t.syncErrorThrowable ? this.__tryOrSetError(t, this._error, e) : this.__tryOrUnsub(this._error, e), this.unsubscribe();
                    else if (t.syncErrorThrowable) i ? (t.syncErrorValue = e, t.syncErrorThrown = !0) : bt(e), this.unsubscribe();
                    else {
                        if (this.unsubscribe(), i) throw e;
                        bt(e)
                    }
                }
            }, Lt.prototype.complete = function() {
                var e, t, i = this;
                this.isStopped || (e = this._parentSubscriber, this._complete && (t = function() {
                    return i._complete.call(i._context)
                }, St.useDeprecatedSynchronousErrorHandling && e.syncErrorThrowable ? this.__tryOrSetError(e, t) : this.__tryOrUnsub(t)), this.unsubscribe())
            }, Lt.prototype.__tryOrUnsub = function(e, t) {
                try {
                    e.call(this._context, t)
                } catch (e) {
                    if (this.unsubscribe(), St.useDeprecatedSynchronousErrorHandling) throw e;
                    bt(e)
                }
            }, Lt.prototype.__tryOrSetError = function(e, t, i) {
                if (!St.useDeprecatedSynchronousErrorHandling) throw new Error("bad call");
                try {
                    t.call(this._context, i)
                } catch (t) {
                    return St.useDeprecatedSynchronousErrorHandling ? (e.syncErrorValue = t, e.syncErrorThrown = !0) : bt(t), !0
                }
                return !1
            }, Lt.prototype._unsubscribe = function() {
                var e = this._parentSubscriber;
                this._context = null, this._parentSubscriber = null, e.unsubscribe()
            }, Lt);

        function Lt(e, t, i, r) {
            var n, s = Dt.call(this) || this;
            s._parentSubscriber = e;
            e = s;
            return yt(t) ? n = t : t && (n = t.next, i = t.error, r = t.complete, t !== Tt && (yt((e = Object.create(t)).unsubscribe) && s.add(e.unsubscribe.bind(e)), e.unsubscribe = s.unsubscribe.bind(s))), s._context = e, s._next = n, s._error = i, s._complete = r, s
        }

        function _t(e, t, i) {
            var r = Mt.call(this) || this;
            switch (r.syncErrorValue = null, r.syncErrorThrown = !1, r.syncErrorThrowable = !1, r.isStopped = !1, arguments.length) {
                case 0:
                    r.destination = Tt;
                    break;
                case 1:
                    if (!e) {
                        r.destination = Tt;
                        break
                    }
                    if ("object" == typeof e) {
                        e instanceof _t ? (r.syncErrorThrowable = e.syncErrorThrowable, (r.destination = e).add(r)) : (r.syncErrorThrowable = !0, r.destination = new Rt(r, e));
                        break
                    }
                default:
                    r.syncErrorThrowable = !0, r.destination = new Rt(r, e, t, i)
            }
            return r
        }
        var Nt = "function" == typeof Symbol && Symbol.observable || "@@observable";

        function Ft(e) {
            return e
        }

        function Bt() {
            for (var e = [], t = 0; t < arguments.length; t++) e[t] = arguments[t];
            return Ut(e)
        }

        function Ut(t) {
            return 0 === t.length ? Ft : 1 === t.length ? t[0] : function(e) {
                return t.reduce(function(e, t) {
                    return t(e)
                }, e)
            }
        }
        var $t = (Vt.prototype.lift = function(e) {
            var t = new Vt;
            return t.source = this, t.operator = e, t
        }, Vt.prototype.subscribe = function(e, t, i) {
            var r = this.operator,
                i = function(e, t, i) {
                    if (e) {
                        if (e instanceof Pt) return e;
                        if (e[xt]) return e[xt]()
                    }
                    return e || t || i ? new Pt(e, t, i) : new Pt(Tt)
                }(e, t, i);
            if (r ? i.add(r.call(i, this.source)) : i.add(this.source || St.useDeprecatedSynchronousErrorHandling && !i.syncErrorThrowable ? this._subscribe(i) : this._trySubscribe(i)), St.useDeprecatedSynchronousErrorHandling && i.syncErrorThrowable && (i.syncErrorThrowable = !1, i.syncErrorThrown)) throw i.syncErrorValue;
            return i
        }, Vt.prototype._trySubscribe = function(t) {
            try {
                return this._subscribe(t)
            } catch (e) {
                St.useDeprecatedSynchronousErrorHandling && (t.syncErrorThrown = !0, t.syncErrorValue = e),
                    function(e) {
                        for (; e;) {
                            var t = e,
                                i = t.closed,
                                r = t.destination,
                                t = t.isStopped;
                            if (i || t) return;
                            e = r && r instanceof Pt ? r : null
                        }
                        return 1
                    }(t) ? t.error(e) : console.warn(e)
            }
        }, Vt.prototype.forEach = function(r, e) {
            var n = this;
            return new(e = Kt(e))(function(e, t) {
                var i = n.subscribe(function(e) {
                    try {
                        r(e)
                    } catch (e) {
                        t(e), i && i.unsubscribe()
                    }
                }, t, e)
            })
        }, Vt.prototype._subscribe = function(e) {
            var t = this.source;
            return t && t.subscribe(e)
        }, Vt.prototype[Nt] = function() {
            return this
        }, Vt.prototype.pipe = function() {
            for (var e = [], t = 0; t < arguments.length; t++) e[t] = arguments[t];
            return 0 === e.length ? this : Ut(e)(this)
        }, Vt.prototype.toPromise = function(e) {
            var r = this;
            return new(e = Kt(e))(function(e, t) {
                var i;
                r.subscribe(function(e) {
                    return i = e
                }, function(e) {
                    return t(e)
                }, function() {
                    return e(i)
                })
            })
        }, Vt.create = function(e) {
            return new Vt(e)
        }, Vt);

        function Vt(e) {
            this._isScalar = !1, e && (this._subscribe = e)
        }

        function Kt(e) {
            if (!(e = e || (St.Promise || Promise))) throw new Error("no Promise impl found");
            return e
        }
        var qt, Ht, jt, Qt, Wt = (ii.prototype = Object.create(Error.prototype), ii),
            Gt = (ut(ti, Qt = At), ti.prototype.unsubscribe = function() {
                var e, t;
                this.closed || (this.closed = !0, e = (t = this.subject).observers, this.subject = null, !e || 0 === e.length || t.isStopped || t.closed || -1 !== (t = e.indexOf(this.subscriber)) && e.splice(t, 1))
            }, ti),
            zt = (ut(ei, jt = Pt), ei),
            Xt = (ut(Zt, Ht = $t), Zt.prototype[xt] = function() {
                return new zt(this)
            }, Zt.prototype.lift = function(e) {
                var t = new Yt(this, this);
                return t.operator = e, t
            }, Zt.prototype.next = function(e) {
                if (this.closed) throw new Wt;
                if (!this.isStopped)
                    for (var t = this.observers, i = t.length, r = t.slice(), n = 0; n < i; n++) r[n].next(e)
            }, Zt.prototype.error = function(e) {
                if (this.closed) throw new Wt;
                this.hasError = !0, this.thrownError = e, this.isStopped = !0;
                for (var t = this.observers, i = t.length, r = t.slice(), n = 0; n < i; n++) r[n].error(e);
                this.observers.length = 0
            }, Zt.prototype.complete = function() {
                if (this.closed) throw new Wt;
                this.isStopped = !0;
                for (var e = this.observers, t = e.length, i = e.slice(), r = 0; r < t; r++) i[r].complete();
                this.observers.length = 0
            }, Zt.prototype.unsubscribe = function() {
                this.isStopped = !0, this.closed = !0, this.observers = null
            }, Zt.prototype._trySubscribe = function(e) {
                if (this.closed) throw new Wt;
                return Ht.prototype._trySubscribe.call(this, e)
            }, Zt.prototype._subscribe = function(e) {
                if (this.closed) throw new Wt;
                return this.hasError ? (e.error(this.thrownError), At.EMPTY) : this.isStopped ? (e.complete(), At.EMPTY) : (this.observers.push(e), new Gt(this, e))
            }, Zt.prototype.asObservable = function() {
                var e = new $t;
                return e.source = this, e
            }, Zt.create = function(e, t) {
                return new Yt(e, t)
            }, Zt),
            Yt = (ut(Jt, qt = Xt), Jt.prototype.next = function(e) {
                var t = this.destination;
                t && t.next && t.next(e)
            }, Jt.prototype.error = function(e) {
                var t = this.destination;
                t && t.error && this.destination.error(e)
            }, Jt.prototype.complete = function() {
                var e = this.destination;
                e && e.complete && this.destination.complete()
            }, Jt.prototype._subscribe = function(e) {
                return this.source ? this.source.subscribe(e) : At.EMPTY
            }, Jt);

        function Jt(e, t) {
            var i = qt.call(this) || this;
            return i.destination = e, i.source = t, i
        }

        function Zt() {
            var e = Ht.call(this) || this;
            return e.observers = [], e.closed = !1, e.isStopped = !1, e.hasError = !1, e.thrownError = null, e
        }

        function ei(e) {
            var t = jt.call(this, e) || this;
            return t.destination = e, t
        }

        function ti(e, t) {
            var i = Qt.call(this) || this;
            return i.subject = e, i.subscriber = t, i.closed = !1, i
        }

        function ii() {
            return Error.call(this), this.message = "object unsubscribed", this.name = "ObjectUnsubscribedError", this
        }

        function ri() {
            return function(e) {
                return e.lift(new pi(e))
            }
        }
        var ni, si, ai, oi, li, di, ui, ci, hi, pi = (Li.prototype.call = function(e, t) {
                var i = this.connectable;
                i._refCount++;
                e = new fi(e, i), t = t.subscribe(e);
                return e.closed || (e.connection = i.connect()), t
            }, Li),
            fi = (ut(Ri, hi = Pt), Ri.prototype._unsubscribe = function() {
                var e, t = this.connectable;
                t ? (this.connectable = null, (e = t._refCount) <= 0 ? this.connection = null : (t._refCount = e - 1, 1 < e ? this.connection = null : (e = this.connection, t = t._connection, this.connection = null, !t || e && t !== e || t.unsubscribe()))) : this.connection = null
            }, Ri),
            w = (ut(Pi, ci = $t), Pi.prototype._subscribe = function(e) {
                return this.getSubject().subscribe(e)
            }, Pi.prototype.getSubject = function() {
                var e = this._subject;
                return e && !e.isStopped || (this._subject = this.subjectFactory()), this._subject
            }, Pi.prototype.connect = function() {
                var e = this._connection;
                return e || (this._isComplete = !1, (e = this._connection = new At).add(this.source.subscribe(new gi(this.getSubject(), this))), e.closed && (this._connection = null, e = At.EMPTY)), e
            }, Pi.prototype.refCount = function() {
                return ri()(this)
            }, Pi),
            mi = {
                operator: {
                    value: null
                },
                _refCount: {
                    value: 0,
                    writable: !0
                },
                _subject: {
                    value: null,
                    writable: !0
                },
                _connection: {
                    value: null,
                    writable: !0
                },
                _subscribe: {
                    value: (fl = w.prototype)._subscribe
                },
                _isComplete: {
                    value: fl._isComplete,
                    writable: !0
                },
                getSubject: {
                    value: fl.getSubject
                },
                connect: {
                    value: fl.connect
                },
                refCount: {
                    value: fl.refCount
                }
            },
            gi = (ut(xi, ui = zt), xi.prototype._error = function(e) {
                this._unsubscribe(), ui.prototype._error.call(this, e)
            }, xi.prototype._complete = function() {
                this.connectable._isComplete = !0, this._unsubscribe(), ui.prototype._complete.call(this)
            }, xi.prototype._unsubscribe = function() {
                var e, t = this.connectable;
                t && (this.connectable = null, e = t._connection, t._refCount = 0, t._subject = null, t._connection = null, e && e.unsubscribe())
            }, xi),
            yi = (ut(Mi, di = Xt), Object.defineProperty(Mi.prototype, "value", {
                get: function() {
                    return this.getValue()
                },
                enumerable: !0,
                configurable: !0
            }), Mi.prototype._subscribe = function(e) {
                var t = di.prototype._subscribe.call(this, e);
                return t && !t.closed && e.next(this._value), t
            }, Mi.prototype.getValue = function() {
                if (this.hasError) throw this.thrownError;
                if (this.closed) throw new Wt;
                return this._value
            }, Mi.prototype.next = function(e) {
                di.prototype.next.call(this, this._value = e)
            }, Mi),
            A = (ut(Di, li = At), Di.prototype.schedule = function(e, t) {
                return this
            }, ut(Ci, oi = Di), Ci.prototype.schedule = function(e, t) {
                if (void 0 === t && (t = 0), this.closed) return this;
                this.state = e;
                var i = this.id,
                    e = this.scheduler;
                return null != i && (this.id = this.recycleAsyncId(e, i, t)), this.pending = !0, this.delay = t, this.id = this.id || this.requestAsyncId(e, this.id, t), this
            }, Ci.prototype.requestAsyncId = function(e, t, i) {
                return void 0 === i && (i = 0), setInterval(e.flush.bind(e, this), i)
            }, Ci.prototype.recycleAsyncId = function(e, t, i) {
                if (null !== (i = void 0 === i ? 0 : i) && this.delay === i && !1 === this.pending) return t;
                clearInterval(t)
            }, Ci.prototype.execute = function(e, t) {
                if (this.closed) return new Error("executing a cancelled action");
                this.pending = !1;
                t = this._execute(e, t);
                if (t) return t;
                !1 === this.pending && null != this.id && (this.id = this.recycleAsyncId(this.scheduler, this.id, null))
            }, Ci.prototype._execute = function(e, t) {
                var i = !1,
                    r = void 0;
                try {
                    this.work(e)
                } catch (e) {
                    i = !0, r = !!e && e || new Error(e)
                }
                if (i) return this.unsubscribe(), r
            }, Ci.prototype._unsubscribe = function() {
                var e = this.id,
                    t = this.scheduler,
                    i = t.actions,
                    r = i.indexOf(this);
                this.work = null, this.state = null, this.pending = !1, this.scheduler = null, -1 !== r && i.splice(r, 1), null != e && (this.id = this.recycleAsyncId(t, e, null)), this.delay = null
            }, Ci),
            vi = (ut(ki, ai = A), ki.prototype.schedule = function(e, t) {
                return 0 < (t = void 0 === t ? 0 : t) ? ai.prototype.schedule.call(this, e, t) : (this.delay = t, this.state = e, this.scheduler.flush(this), this)
            }, ki.prototype.execute = function(e, t) {
                return 0 < t || this.closed ? ai.prototype.execute.call(this, e, t) : this._execute(e, t)
            }, ki.prototype.requestAsyncId = function(e, t, i) {
                return null !== (i = void 0 === i ? 0 : i) && 0 < i || null === i && 0 < this.delay ? ai.prototype.requestAsyncId.call(this, e, t, i) : e.flush(this)
            }, ki),
            Si = (Oi.prototype.schedule = function(e, t, i) {
                return void 0 === t && (t = 0), new this.SchedulerAction(this, e).schedule(i, t)
            }, Oi.now = function() {
                return Date.now()
            }, Oi),
            bi = (ut(Ai, si = Si), Ai.prototype.schedule = function(e, t, i) {
                return void 0 === t && (t = 0), Ai.delegate && Ai.delegate !== this ? Ai.delegate.schedule(e, t, i) : si.prototype.schedule.call(this, e, t, i)
            }, Ai.prototype.flush = function(e) {
                var t, i = this.actions;
                if (this.active) i.push(e);
                else {
                    this.active = !0;
                    do {
                        if (t = e.execute(e.state, e.delay)) break
                    } while (e = i.shift());
                    if (this.active = !1, t) {
                        for (; e = i.shift();) e.unsubscribe();
                        throw t
                    }
                }
            }, Ai),
            Ti = (ut(wi, ni = bi), new wi(vi)),
            Ei = Ti,
            Ii = new $t(function(e) {
                return e.complete()
            });

        function wi() {
            return null !== ni && ni.apply(this, arguments) || this
        }

        function Ai(e, t) {
            void 0 === t && (t = Si.now);
            var i = si.call(this, e, function() {
                return Ai.delegate && Ai.delegate !== i ? Ai.delegate.now() : t()
            }) || this;
            return i.actions = [], i.active = !1, i.scheduled = void 0, i
        }

        function Oi(e, t) {
            void 0 === t && (t = Oi.now), this.SchedulerAction = e, this.now = t
        }

        function ki(e, t) {
            var i = ai.call(this, e, t) || this;
            return i.scheduler = e, i.work = t, i
        }

        function Ci(e, t) {
            var i = oi.call(this, e, t) || this;
            return i.scheduler = e, i.work = t, i.pending = !1, i
        }

        function Di(e, t) {
            return li.call(this) || this
        }

        function Mi(e) {
            var t = di.call(this) || this;
            return t._value = e, t
        }

        function xi(e, t) {
            e = ui.call(this, e) || this;
            return e.connectable = t, e
        }

        function Pi(e, t) {
            var i = ci.call(this) || this;
            return i.source = e, i.subjectFactory = t, i._refCount = 0, i._isComplete = !1, i
        }

        function Ri(e, t) {
            e = hi.call(this, e) || this;
            return e.connectable = t, e
        }

        function Li(e) {
            this.connectable = e
        }

        function _i(e) {
            return e ? (t = e, new $t(function(e) {
                return t.schedule(function() {
                    return e.complete()
                })
            })) : Ii;
            var t
        }

        function Ni(e) {
            return e && "function" == typeof e.schedule
        }
        var Fi = function(r) {
            return function(e) {
                for (var t = 0, i = r.length; t < i && !e.closed; t++) e.next(r[t]);
                e.complete()
            }
        };

        function Bi(r, n) {
            return new $t(function(e) {
                var t = new At,
                    i = 0;
                return t.add(n.schedule(function() {
                    i !== r.length ? (e.next(r[i++]), e.closed || t.add(this.schedule())) : e.complete()
                })), t
            })
        }

        function Ui(e, t) {
            return t ? Bi(e, t) : new $t(Fi(e))
        }

        function $i() {
            for (var e = [], t = 0; t < arguments.length; t++) e[t] = arguments[t];
            var i = e[e.length - 1];
            return Ni(i) ? (e.pop(), Bi(e, i)) : Ui(e)
        }

        function Vi(t, i) {
            return new $t(i ? function(e) {
                return i.schedule(Ki, 0, {
                    error: t,
                    subscriber: e
                })
            } : function(e) {
                return e.error(t)
            })
        }

        function Ki(e) {
            var t = e.error;
            e.subscriber.error(t)
        }
        var qi = (Hi.prototype.observe = function(e) {
            switch (this.kind) {
                case "N":
                    return e.next && e.next(this.value);
                case "E":
                    return e.error && e.error(this.error);
                case "C":
                    return e.complete && e.complete()
            }
        }, Hi.prototype.do = function(e, t, i) {
            switch (this.kind) {
                case "N":
                    return e && e(this.value);
                case "E":
                    return t && t(this.error);
                case "C":
                    return i && i()
            }
        }, Hi.prototype.accept = function(e, t, i) {
            return e && "function" == typeof e.next ? this.observe(e) : this.do(e, t, i)
        }, Hi.prototype.toObservable = function() {
            switch (this.kind) {
                case "N":
                    return $i(this.value);
                case "E":
                    return Vi(this.error);
                case "C":
                    return _i()
            }
            throw new Error("unexpected notification kind value")
        }, Hi.createNext = function(e) {
            return void 0 !== e ? new Hi("N", e) : Hi.undefinedValueNotification
        }, Hi.createError = function(e) {
            return new Hi("E", void 0, e)
        }, Hi.createComplete = function() {
            return Hi.completeNotification
        }, Hi.completeNotification = new Hi("C"), Hi.undefinedValueNotification = new Hi("N", void 0), Hi);

        function Hi(e, t, i) {
            this.kind = e, this.value = t, this.error = i, this.hasValue = "N" === e
        }

        function ji(t, i) {
            return void 0 === i && (i = 0),
                function(e) {
                    return e.lift(new zi(t, i))
                }
        }
        var Qi, Wi, Gi, zi = (ar.prototype.call = function(e, t) {
                return t.subscribe(new Xi(e, this.scheduler, this.delay))
            }, ar),
            Xi = (ut(sr, Gi = Pt), sr.dispatch = function(e) {
                var t = e.notification,
                    e = e.destination;
                t.observe(e), this.unsubscribe()
            }, sr.prototype.scheduleMessage = function(e) {
                this.destination.add(this.scheduler.schedule(sr.dispatch, this.delay, new Yi(e, this.destination)))
            }, sr.prototype._next = function(e) {
                this.scheduleMessage(qi.createNext(e))
            }, sr.prototype._error = function(e) {
                this.scheduleMessage(qi.createError(e)), this.unsubscribe()
            }, sr.prototype._complete = function() {
                this.scheduleMessage(qi.createComplete()), this.unsubscribe()
            }, sr),
            Yi = function(e, t) {
                this.notification = e, this.destination = t
            },
            Ji = (ut(nr, Wi = Xt), nr.prototype.nextInfiniteTimeWindow = function(e) {
                var t;
                this.isStopped || ((t = this._events).push(e), t.length > this._bufferSize && t.shift()), Wi.prototype.next.call(this, e)
            }, nr.prototype.nextTimeWindow = function(e) {
                this.isStopped || (this._events.push(new Zi(this._getNow(), e)), this._trimBufferThenGetEvents()), Wi.prototype.next.call(this, e)
            }, nr.prototype._subscribe = function(e) {
                var t, i = this._infiniteTimeWindow,
                    r = i ? this._events : this._trimBufferThenGetEvents(),
                    n = this.scheduler,
                    s = r.length;
                if (this.closed) throw new Wt;
                if (t = this.isStopped || this.hasError ? At.EMPTY : (this.observers.push(e), new Gt(this, e)), n && e.add(e = new Xi(e, n)), i)
                    for (var a = 0; a < s && !e.closed; a++) e.next(r[a]);
                else
                    for (a = 0; a < s && !e.closed; a++) e.next(r[a].value);
                return this.hasError ? e.error(this.thrownError) : this.isStopped && e.complete(), t
            }, nr.prototype._getNow = function() {
                return (this.scheduler || Ei).now()
            }, nr.prototype._trimBufferThenGetEvents = function() {
                for (var e = this._getNow(), t = this._bufferSize, i = this._windowTime, r = this._events, n = r.length, s = 0; s < n && !(e - r[s].time < i);) s++;
                return 0 < (s = t < n ? Math.max(s, n - t) : s) && r.splice(0, s), r
            }, nr),
            Zi = function(e, t) {
                this.time = e, this.value = t
            },
            er = (ut(rr, Qi = Xt), rr.prototype._subscribe = function(e) {
                return this.hasError ? (e.error(this.thrownError), At.EMPTY) : this.hasCompleted && this.hasNext ? (e.next(this.value), e.complete(), At.EMPTY) : Qi.prototype._subscribe.call(this, e)
            }, rr.prototype.next = function(e) {
                this.hasCompleted || (this.value = e, this.hasNext = !0)
            }, rr.prototype.error = function(e) {
                this.hasCompleted || Qi.prototype.error.call(this, e)
            }, rr.prototype.complete = function() {
                this.hasCompleted = !0, this.hasNext && Qi.prototype.next.call(this, this.value), Qi.prototype.complete.call(this)
            }, rr),
            tr = new bi(A),
            ir = tr;

        function rr() {
            var e = null !== Qi && Qi.apply(this, arguments) || this;
            return e.value = null, e.hasNext = !1, e.hasCompleted = !1, e
        }

        function nr(e, t, i) {
            void 0 === e && (e = Number.POSITIVE_INFINITY), void 0 === t && (t = Number.POSITIVE_INFINITY);
            var r = Wi.call(this) || this;
            return r.scheduler = i, r._events = [], r._infiniteTimeWindow = !1, r._bufferSize = e < 1 ? 1 : e, r._windowTime = t < 1 ? 1 : t, t === Number.POSITIVE_INFINITY ? (r._infiniteTimeWindow = !0, r.next = r.nextInfiniteTimeWindow) : r.next = r.nextTimeWindow, r
        }

        function sr(e, t, i) {
            void 0 === i && (i = 0);
            e = Gi.call(this, e) || this;
            return e.scheduler = t, e.delay = i, e
        }

        function ar(e, t) {
            void 0 === t && (t = 0), this.scheduler = e, this.delay = t
        }

        function or() {}
        var lr = (cr.prototype = Object.create(Error.prototype), cr),
            dr = (ur.prototype = Object.create(Error.prototype), ur);

        function ur() {
            return Error.call(this), this.message = "Timeout has occurred", this.name = "TimeoutError", this
        }

        function cr() {
            return Error.call(this), this.message = "argument out of range", this.name = "ArgumentOutOfRangeError", this
        }

        function hr(t, i) {
            return function(e) {
                if ("function" != typeof t) throw new TypeError("argument is not a function. Are you looking for `mapTo()`?");
                return e.lift(new gr(t, i))
            }
        }
        var pr, fr, mr, gr = (Ir.prototype.call = function(e, t) {
                return t.subscribe(new yr(e, this.project, this.thisArg))
            }, Ir),
            yr = (ut(Er, mr = Pt), Er.prototype._next = function(e) {
                var t;
                try {
                    t = this.project.call(this.thisArg, e, this.count++)
                } catch (e) {
                    return void this.destination.error(e)
                }
                this.destination.next(t)
            }, Er),
            vr = (ut(Tr, fr = Pt), Tr.prototype.notifyNext = function(e, t, i, r, n) {
                this.destination.next(t)
            }, Tr.prototype.notifyError = function(e, t) {
                this.destination.error(e)
            }, Tr.prototype.notifyComplete = function(e) {
                this.destination.complete()
            }, Tr),
            Sr = (ut(br, pr = Pt), br.prototype._next = function(e) {
                this.parent.notifyNext(this.outerValue, e, this.outerIndex, this.index++, this)
            }, br.prototype._error = function(e) {
                this.parent.notifyError(e, this), this.unsubscribe()
            }, br.prototype._complete = function() {
                this.parent.notifyComplete(this), this.unsubscribe()
            }, br);

        function br(e, t, i) {
            var r = pr.call(this) || this;
            return r.parent = e, r.outerValue = t, r.outerIndex = i, r.index = 0, r
        }

        function Tr() {
            return null !== fr && fr.apply(this, arguments) || this
        }

        function Er(e, t, i) {
            e = mr.call(this, e) || this;
            return e.project = t, e.count = 0, e.thisArg = i || e, e
        }

        function Ir(e, t) {
            this.project = e, this.thisArg = t
        }
        var wr = "function" == typeof Symbol && Symbol.iterator ? Symbol.iterator : "@@iterator",
            Ar = function(e) {
                return e && "number" == typeof e.length && "function" != typeof e
            };

        function Or(e) {
            return e && "function" != typeof e.subscribe && "function" == typeof e.then
        }
        var kr = function(e) {
            if (e && "function" == typeof e[Nt]) return n = e,
                function(e) {
                    var t = n[Nt]();
                    if ("function" != typeof t.subscribe) throw new TypeError("Provided object does not correctly implement Symbol.observable");
                    return t.subscribe(e)
                };
            if (Ar(e)) return Fi(e);
            if (Or(e)) return i = e,
                function(t) {
                    return i.then(function(e) {
                        t.closed || (t.next(e), t.complete())
                    }, function(e) {
                        return t.error(e)
                    }).then(null, bt), t
                };
            if (e && "function" == typeof e[wr]) return r = e,
                function(t) {
                    for (var e = r[wr]();;) {
                        var i = void 0;
                        try {
                            i = e.next()
                        } catch (e) {
                            return t.error(e), t
                        }
                        if (i.done) {
                            t.complete();
                            break
                        }
                        if (t.next(i.value), t.closed) break
                    }
                    return "function" == typeof e.return && t.add(function() {
                        e.return && e.return()
                    }), t
                };
            var r, i, n, e = It(e) ? "an invalid object" : "'" + e + "'";
            throw new TypeError("You provided " + e + " where a stream was expected. You can provide an Observable, Promise, Array, or Iterable.")
        };

        function Cr(e, t, i, r, n) {
            if (!(n = void 0 === n ? new Sr(e, i, r) : n).closed) return t instanceof $t ? t.subscribe(n) : kr(t)(n)
        }
        var Dr = {};

        function Mr() {
            for (var e = [], t = 0; t < arguments.length; t++) e[t] = arguments[t];
            var i = void 0,
                r = void 0;
            return Ni(e[e.length - 1]) && (r = e.pop()), "function" == typeof e[e.length - 1] && (i = e.pop()), Ui(e = 1 === e.length && Et(e[0]) ? e[0] : e, r).lift(new Pr(i))
        }
        var xr, Pr = (_r.prototype.call = function(e, t) {
                return t.subscribe(new Rr(e, this.resultSelector))
            }, _r),
            Rr = (ut(Lr, xr = vr), Lr.prototype._next = function(e) {
                this.values.push(Dr), this.observables.push(e)
            }, Lr.prototype._complete = function() {
                var e = this.observables,
                    t = e.length;
                if (0 === t) this.destination.complete();
                else {
                    this.active = t, this.toRespond = t;
                    for (var i = 0; i < t; i++) {
                        var r = e[i];
                        this.add(Cr(this, r, void 0, i))
                    }
                }
            }, Lr.prototype.notifyComplete = function(e) {
                0 == --this.active && this.destination.complete()
            }, Lr.prototype.notifyNext = function(e, t, i) {
                var r = this.values,
                    n = r[i],
                    n = this.toRespond ? n === Dr ? --this.toRespond : this.toRespond : 0;
                r[i] = t, 0 === n && (this.resultSelector ? this._tryResultSelector(r) : this.destination.next(r.slice()))
            }, Lr.prototype._tryResultSelector = function(e) {
                var t;
                try {
                    t = this.resultSelector.apply(this, e)
                } catch (e) {
                    return void this.destination.error(e)
                }
                this.destination.next(t)
            }, Lr);

        function Lr(e, t) {
            e = xr.call(this, e) || this;
            return e.resultSelector = t, e.active = 0, e.values = [], e.observables = [], e
        }

        function _r(e) {
            this.resultSelector = e
        }

        function Nr(e, t) {
            if (null != e) {
                if (e && "function" == typeof e[Nt]) return s = e, a = t, new $t(function(t) {
                    var i = new At;
                    return i.add(a.schedule(function() {
                        var e = s[Nt]();
                        i.add(e.subscribe({
                            next: function(e) {
                                i.add(a.schedule(function() {
                                    return t.next(e)
                                }))
                            },
                            error: function(e) {
                                i.add(a.schedule(function() {
                                    return t.error(e)
                                }))
                            },
                            complete: function() {
                                i.add(a.schedule(function() {
                                    return t.complete()
                                }))
                            }
                        }))
                    })), i
                });
                if (Or(e)) return r = e, n = t, new $t(function(t) {
                    var i = new At;
                    return i.add(n.schedule(function() {
                        return r.then(function(e) {
                            i.add(n.schedule(function() {
                                t.next(e), i.add(n.schedule(function() {
                                    return t.complete()
                                }))
                            }))
                        }, function(e) {
                            i.add(n.schedule(function() {
                                return t.error(e)
                            }))
                        })
                    })), i
                });
                if (Ar(e)) return Bi(e, t);
                if (e && "function" == typeof e[wr] || "string" == typeof e) return function(t, i) {
                    if (!t) throw new Error("Iterable cannot be null");
                    return new $t(function(r) {
                        var n, e = new At;
                        return e.add(function() {
                            n && "function" == typeof n.return && n.return()
                        }), e.add(i.schedule(function() {
                            n = t[wr](), e.add(i.schedule(function() {
                                if (!r.closed) {
                                    try {
                                        var e = n.next(),
                                            t = e.value,
                                            i = e.done
                                    } catch (t) {
                                        return void r.error(t)
                                    }
                                    i ? r.complete() : (r.next(t), this.schedule())
                                }
                            }))
                        })), e
                    })
                }(e, t)
            }
            var r, n, s, a;
            throw new TypeError((null !== e && typeof e || e) + " is not observable")
        }

        function Fr(e, t) {
            return t ? Nr(e, t) : e instanceof $t ? e : new $t(kr(e))
        }
        var Br, Ur, $r = (ut(qr, Ur = Pt), qr.prototype._next = function(e) {
                this.parent.notifyNext(e)
            }, qr.prototype._error = function(e) {
                this.parent.notifyError(e), this.unsubscribe()
            }, qr.prototype._complete = function() {
                this.parent.notifyComplete(), this.unsubscribe()
            }, qr),
            Vr = (ut(Kr, Br = Pt), Kr.prototype.notifyNext = function(e) {
                this.destination.next(e)
            }, Kr.prototype.notifyError = function(e) {
                this.destination.error(e)
            }, Kr.prototype.notifyComplete = function() {
                this.destination.complete()
            }, Kr);

        function Kr() {
            return null !== Br && Br.apply(this, arguments) || this
        }

        function qr(e) {
            var t = Ur.call(this) || this;
            return t.parent = e, t
        }

        function Hr(e, t) {
            if (!t.closed) return e instanceof $t ? e.subscribe(t) : kr(e)(t)
        }

        function jr(t, n, i) {
            return void 0 === i && (i = Number.POSITIVE_INFINITY), "function" == typeof n ? function(e) {
                return e.pipe(jr(function(i, r) {
                    return Fr(t(i, r)).pipe(hr(function(e, t) {
                        return n(i, e, r, t)
                    }))
                }, i))
            } : ("number" == typeof n && (i = n), function(e) {
                return e.lift(new Wr(t, i))
            })
        }
        var Qr, Wr = (Xr.prototype.call = function(e, t) {
                return t.subscribe(new Gr(e, this.project, this.concurrent))
            }, Xr),
            Gr = (ut(zr, Qr = Vr), zr.prototype._next = function(e) {
                this.active < this.concurrent ? this._tryNext(e) : this.buffer.push(e)
            }, zr.prototype._tryNext = function(e) {
                var t, i = this.index++;
                try {
                    t = this.project(e, i)
                } catch (e) {
                    return void this.destination.error(e)
                }
                this.active++, this._innerSub(t)
            }, zr.prototype._innerSub = function(e) {
                var t = new $r(this),
                    i = this.destination;
                i.add(t);
                e = Hr(e, t);
                e !== t && i.add(e)
            }, zr.prototype._complete = function() {
                this.hasCompleted = !0, 0 === this.active && 0 === this.buffer.length && this.destination.complete(), this.unsubscribe()
            }, zr.prototype.notifyNext = function(e) {
                this.destination.next(e)
            }, zr.prototype.notifyComplete = function() {
                var e = this.buffer;
                this.active--, 0 < e.length ? this._next(e.shift()) : 0 === this.active && this.hasCompleted && this.destination.complete()
            }, zr);

        function zr(e, t, i) {
            void 0 === i && (i = Number.POSITIVE_INFINITY);
            e = Qr.call(this, e) || this;
            return e.project = t, e.concurrent = i, e.hasCompleted = !1, e.buffer = [], e.active = 0, e.index = 0, e
        }

        function Xr(e, t) {
            void 0 === t && (t = Number.POSITIVE_INFINITY), this.project = e, this.concurrent = t
        }

        function Yr(e) {
            return jr(Ft, e = void 0 === e ? Number.POSITIVE_INFINITY : e)
        }

        function Jr() {
            for (var e = [], t = 0; t < arguments.length; t++) e[t] = arguments[t];
            return Yr(1)($i.apply(void 0, e))
        }

        function Zr(i) {
            return new $t(function(t) {
                var e;
                try {
                    e = i()
                } catch (e) {
                    return void t.error(e)
                }
                return (e ? Fr(e) : _i()).subscribe(t)
            })
        }

        function en() {
            for (var e = [], t = 0; t < arguments.length; t++) e[t] = arguments[t];
            if (1 === e.length) {
                var i = e[0];
                if (Et(i)) return tn(i, null);
                if (It(i) && Object.getPrototypeOf(i) === Object.prototype) {
                    var r = Object.keys(i);
                    return tn(r.map(function(e) {
                        return i[e]
                    }), r)
                }
            }
            if ("function" != typeof e[e.length - 1]) return tn(e, null);
            var n = e.pop();
            return tn(e = 1 === e.length && Et(e[0]) ? e[0] : e, null).pipe(hr(function(e) {
                return n.apply(void 0, e)
            }))
        }

        function tn(l, d) {
            return new $t(function(r) {
                var n = l.length;
                if (0 !== n)
                    for (var s = new Array(n), a = 0, o = 0, e = 0; e < n; e++) ! function(t) {
                        var e = Fr(l[t]),
                            i = !1;
                        r.add(e.subscribe({
                            next: function(e) {
                                i || (i = !0, o++), s[t] = e
                            },
                            error: function(e) {
                                return r.error(e)
                            },
                            complete: function() {
                                ++a !== n && i || (o === n && r.next(d ? d.reduce(function(e, t, i) {
                                    return e[t] = s[i], e
                                }, {}) : s), r.complete())
                            }
                        }))
                    }(e);
                else r.complete()
            })
        }

        function rn(e, i, r, t) {
            return yt(r) && (t = r, r = void 0), t ? rn(e, i, r).pipe(hr(function(e) {
                return Et(e) ? t.apply(void 0, e) : t(e)
            })) : new $t(function(t) {
                ! function e(t, i, r, n, s) {
                    var a;
                    if (function(e) {
                            return e && "function" == typeof e.addEventListener && "function" == typeof e.removeEventListener
                        }(t)) {
                        var o = t;
                        t.addEventListener(i, r, s), a = function() {
                            return o.removeEventListener(i, r, s)
                        }
                    } else if (function(e) {
                            return e && "function" == typeof e.on && "function" == typeof e.off
                        }(t)) {
                        var l = t;
                        t.on(i, r), a = function() {
                            return l.off(i, r)
                        }
                    } else if (function(e) {
                            return e && "function" == typeof e.addListener && "function" == typeof e.removeListener
                        }(t)) {
                        var d = t;
                        t.addListener(i, r), a = function() {
                            return d.removeListener(i, r)
                        }
                    } else {
                        if (!t || !t.length) throw new TypeError("Invalid event target");
                        for (var u = 0, c = t.length; u < c; u++) e(t[u], i, r, n, s)
                    }
                    n.add(a)
                }(e, i, function(e) {
                    1 < arguments.length ? t.next(Array.prototype.slice.call(arguments)) : t.next(e)
                }, t, r)
            })
        }

        function nn(e, t, i) {
            return void 0 === t && (t = Ii), void 0 === i && (i = Ii), Zr(function() {
                return e() ? t : i
            })
        }

        function sn(e) {
            return !Et(e) && 0 <= e - parseFloat(e) + 1
        }

        function an() {
            for (var e = [], t = 0; t < arguments.length; t++) e[t] = arguments[t];
            var i = Number.POSITIVE_INFINITY,
                r = null,
                n = e[e.length - 1];
            return Ni(n) ? (r = e.pop(), 1 < e.length && "number" == typeof e[e.length - 1] && (i = e.pop())) : "number" == typeof n && (i = e.pop()), null === r && 1 === e.length && e[0] instanceof $t ? e[0] : Yr(i)(Ui(e, r))
        }
        var on = new $t(or);

        function ln(t, i) {
            return function(e) {
                return e.lift(new un(t, i))
            }
        }
        var dn, un = (pn.prototype.call = function(e, t) {
                return t.subscribe(new cn(e, this.predicate, this.thisArg))
            }, pn),
            cn = (ut(hn, dn = Pt), hn.prototype._next = function(e) {
                var t;
                try {
                    t = this.predicate.call(this.thisArg, e, this.count++)
                } catch (e) {
                    return void this.destination.error(e)
                }
                t && this.destination.next(e)
            }, hn);

        function hn(e, t, i) {
            e = dn.call(this, e) || this;
            return e.predicate = t, e.thisArg = i, e.count = 0, e
        }

        function pn(e, t) {
            this.predicate = e, this.thisArg = t
        }

        function fn() {
            for (var e = [], t = 0; t < arguments.length; t++) e[t] = arguments[t];
            if (1 === e.length) {
                if (!Et(e[0])) return e[0];
                e = e[0]
            }
            return Ui(e, void 0).lift(new gn)
        }
        var mn, gn = (Sn.prototype.call = function(e, t) {
                return t.subscribe(new yn(e))
            }, Sn),
            yn = (ut(vn, mn = vr), vn.prototype._next = function(e) {
                this.observables.push(e)
            }, vn.prototype._complete = function() {
                var e = this.observables,
                    t = e.length;
                if (0 === t) this.destination.complete();
                else {
                    for (var i = 0; i < t && !this.hasFirst; i++) {
                        var r = Cr(this, e[i], void 0, i);
                        this.subscriptions && this.subscriptions.push(r), this.add(r)
                    }
                    this.observables = null
                }
            }, vn.prototype.notifyNext = function(e, t, i) {
                if (!this.hasFirst) {
                    this.hasFirst = !0;
                    for (var r, n = 0; n < this.subscriptions.length; n++) n !== i && ((r = this.subscriptions[n]).unsubscribe(), this.remove(r));
                    this.subscriptions = null
                }
                this.destination.next(t)
            }, vn);

        function vn(e) {
            e = mn.call(this, e) || this;
            return e.hasFirst = !1, e.observables = [], e.subscriptions = [], e
        }

        function Sn() {}

        function bn(i, e, r) {
            void 0 === i && (i = 0);
            var n = -1;
            return sn(e) ? n = Number(e) < 1 ? 1 : Number(e) : Ni(e) && (r = e), Ni(r) || (r = ir), new $t(function(e) {
                var t = sn(i) ? i : +i - r.now();
                return r.schedule(Tn, t, {
                    index: 0,
                    period: n,
                    subscriber: e
                })
            })
        }

        function Tn(e) {
            var t = e.index,
                i = e.period,
                r = e.subscriber;
            if (r.next(t), !r.closed) {
                if (-1 === i) return r.complete();
                e.index = t + 1, this.schedule(e, i)
            }
        }

        function En() {
            for (var e = [], t = 0; t < arguments.length; t++) e[t] = arguments[t];
            var i = e[e.length - 1];
            return "function" == typeof i && e.pop(), Ui(e, void 0).lift(new An(i))
        }
        var In, wn, An = (Ln.prototype.call = function(e, t) {
                return t.subscribe(new On(e, this.resultSelector))
            }, Ln),
            On = (ut(Rn, wn = Pt), Rn.prototype._next = function(e) {
                var t = this.iterators;
                Et(e) ? t.push(new Cn(e)) : "function" == typeof e[wr] ? t.push(new kn(e[wr]())) : t.push(new Dn(this.destination, this, e))
            }, Rn.prototype._complete = function() {
                var e = this.iterators,
                    t = e.length;
                if (this.unsubscribe(), 0 !== t) {
                    this.active = t;
                    for (var i = 0; i < t; i++) {
                        var r = e[i];
                        r.stillUnsubscribed ? this.destination.add(r.subscribe()) : this.active--
                    }
                } else this.destination.complete()
            }, Rn.prototype.notifyInactive = function() {
                this.active--, 0 === this.active && this.destination.complete()
            }, Rn.prototype.checkIterators = function() {
                for (var e = this.iterators, t = e.length, i = this.destination, r = 0; r < t; r++)
                    if ("function" == typeof(a = e[r]).hasValue && !a.hasValue()) return;
                for (var n = !1, s = [], r = 0; r < t; r++) {
                    var a, o = (a = e[r]).next();
                    if (a.hasCompleted() && (n = !0), o.done) return void i.complete();
                    s.push(o.value)
                }
                this.resultSelector ? this._tryresultSelector(s) : i.next(s), n && i.complete()
            }, Rn.prototype._tryresultSelector = function(e) {
                var t;
                try {
                    t = this.resultSelector.apply(this, e)
                } catch (e) {
                    return void this.destination.error(e)
                }
                this.destination.next(t)
            }, Rn),
            kn = (Pn.prototype.hasValue = function() {
                return !0
            }, Pn.prototype.next = function() {
                var e = this.nextResult;
                return this.nextResult = this.iterator.next(), e
            }, Pn.prototype.hasCompleted = function() {
                var e = this.nextResult;
                return Boolean(e && e.done)
            }, Pn),
            Cn = (xn.prototype[wr] = function() {
                return this
            }, xn.prototype.next = function(e) {
                var t = this.index++,
                    i = this.array;
                return t < this.length ? {
                    value: i[t],
                    done: !1
                } : {
                    value: null,
                    done: !0
                }
            }, xn.prototype.hasValue = function() {
                return this.array.length > this.index
            }, xn.prototype.hasCompleted = function() {
                return this.array.length === this.index
            }, xn),
            Dn = (ut(Mn, In = Vr), Mn.prototype[wr] = function() {
                return this
            }, Mn.prototype.next = function() {
                var e = this.buffer;
                return 0 === e.length && this.isComplete ? {
                    value: null,
                    done: !0
                } : {
                    value: e.shift(),
                    done: !1
                }
            }, Mn.prototype.hasValue = function() {
                return 0 < this.buffer.length
            }, Mn.prototype.hasCompleted = function() {
                return 0 === this.buffer.length && this.isComplete
            }, Mn.prototype.notifyComplete = function() {
                0 < this.buffer.length ? (this.isComplete = !0, this.parent.notifyInactive()) : this.destination.complete()
            }, Mn.prototype.notifyNext = function(e) {
                this.buffer.push(e), this.parent.checkIterators()
            }, Mn.prototype.subscribe = function() {
                return Hr(this.observable, new $r(this))
            }, Mn);

        function Mn(e, t, i) {
            e = In.call(this, e) || this;
            return e.parent = t, e.observable = i, e.stillUnsubscribed = !0, e.buffer = [], e.isComplete = !1, e
        }

        function xn(e) {
            this.array = e, this.index = 0, this.length = 0, this.length = e.length
        }

        function Pn(e) {
            this.iterator = e, this.nextResult = e.next()
        }

        function Rn(e, t, i) {
            e = wn.call(this, e) || this;
            return e.resultSelector = t, e.iterators = [], e.active = 0, e.resultSelector = "function" == typeof t ? t : void 0, e
        }

        function Ln(e) {
            this.resultSelector = e
        }
        var _n, Nn = (Un.prototype.call = function(e, t) {
                return t.subscribe(new Fn(e, this.durationSelector))
            }, Un),
            Fn = (ut(Bn, _n = Vr), Bn.prototype._next = function(e) {
                if (this.value = e, this.hasValue = !0, !this.throttled) {
                    var t = void 0;
                    try {
                        t = (0, this.durationSelector)(e)
                    } catch (e) {
                        return this.destination.error(e)
                    }
                    t = Hr(t, new $r(this));
                    !t || t.closed ? this.clearThrottle() : this.add(this.throttled = t)
                }
            }, Bn.prototype.clearThrottle = function() {
                var e = this.value,
                    t = this.hasValue,
                    i = this.throttled;
                i && (this.remove(i), this.throttled = void 0, i.unsubscribe()), t && (this.value = void 0, this.hasValue = !1, this.destination.next(e))
            }, Bn.prototype.notifyNext = function() {
                this.clearThrottle()
            }, Bn.prototype.notifyComplete = function() {
                this.clearThrottle()
            }, Bn);

        function Bn(e, t) {
            e = _n.call(this, e) || this;
            return e.durationSelector = t, e.hasValue = !1, e
        }

        function Un(e) {
            this.durationSelector = e
        }

        function $n(e, t) {
            return void 0 === t && (t = ir), i = function() {
                    return bn(e, t)
                },
                function(e) {
                    return e.lift(new Nn(i))
                };
            var i
        }

        function Vn(i) {
            return function(e) {
                var t = new qn(i),
                    e = e.lift(t);
                return t.caught = e
            }
        }
        var Kn, qn = (Qn.prototype.call = function(e, t) {
                return t.subscribe(new Hn(e, this.selector, this.caught))
            }, Qn),
            Hn = (ut(jn, Kn = Vr), jn.prototype.error = function(e) {
                if (!this.isStopped) {
                    var t = void 0;
                    try {
                        t = this.selector(e, this.caught)
                    } catch (e) {
                        return void Kn.prototype.error.call(this, e)
                    }
                    this._unsubscribeAndRecycle();
                    var i = new $r(this);
                    this.add(i);
                    t = Hr(t, i);
                    t !== i && this.add(t)
                }
            }, jn);

        function jn(e, t, i) {
            e = Kn.call(this, e) || this;
            return e.selector = t, e.caught = i, e
        }

        function Qn(e) {
            this.selector = e
        }

        function Wn(e, t) {
            return jr(e, t, 1)
        }

        function Gn(t, i) {
            return void 0 === i && (i = ir),
                function(e) {
                    return e.lift(new Xn(t, i))
                }
        }
        var zn, Xn = (Zn.prototype.call = function(e, t) {
                return t.subscribe(new Yn(e, this.dueTime, this.scheduler))
            }, Zn),
            Yn = (ut(Jn, zn = Pt), Jn.prototype._next = function(e) {
                this.clearDebounce(), this.lastValue = e, this.hasValue = !0, this.add(this.debouncedSubscription = this.scheduler.schedule(es, this.dueTime, this))
            }, Jn.prototype._complete = function() {
                this.debouncedNext(), this.destination.complete()
            }, Jn.prototype.debouncedNext = function() {
                var e;
                this.clearDebounce(), this.hasValue && (e = this.lastValue, this.lastValue = null, this.hasValue = !1, this.destination.next(e))
            }, Jn.prototype.clearDebounce = function() {
                var e = this.debouncedSubscription;
                null !== e && (this.remove(e), e.unsubscribe(), this.debouncedSubscription = null)
            }, Jn);

        function Jn(e, t, i) {
            e = zn.call(this, e) || this;
            return e.dueTime = t, e.scheduler = i, e.debouncedSubscription = null, e.lastValue = null, e.hasValue = !1, e
        }

        function Zn(e, t) {
            this.dueTime = e, this.scheduler = t
        }

        function es(e) {
            e.debouncedNext()
        }
        var ts, is = (ss.prototype.call = function(e, t) {
                return t.subscribe(new rs(e, this.defaultValue))
            }, ss),
            rs = (ut(ns, ts = Pt), ns.prototype._next = function(e) {
                this.isEmpty = !1, this.destination.next(e)
            }, ns.prototype._complete = function() {
                this.isEmpty && this.destination.next(this.defaultValue), this.destination.complete()
            }, ns);

        function ns(e, t) {
            e = ts.call(this, e) || this;
            return e.defaultValue = t, e.isEmpty = !0, e
        }

        function ss(e) {
            this.defaultValue = e
        }

        function as(e) {
            return e instanceof Date && !isNaN(+e)
        }
        var os, ls = (hs.prototype.call = function(e, t) {
                return t.subscribe(new ds(e, this.delay, this.scheduler))
            }, hs),
            ds = (ut(cs, os = Pt), cs.dispatch = function(e) {
                for (var t, i = e.source, r = i.queue, n = e.scheduler, s = e.destination; 0 < r.length && r[0].time - n.now() <= 0;) r.shift().notification.observe(s);
                0 < r.length ? (t = Math.max(0, r[0].time - n.now()), this.schedule(e, t)) : (this.unsubscribe(), i.active = !1)
            }, cs.prototype._schedule = function(e) {
                this.active = !0, this.destination.add(e.schedule(cs.dispatch, this.delay, {
                    source: this,
                    destination: this.destination,
                    scheduler: e
                }))
            }, cs.prototype.scheduleNotification = function(e) {
                var t;
                !0 !== this.errored && (t = this.scheduler, e = new us(t.now() + this.delay, e), this.queue.push(e), !1 === this.active && this._schedule(t))
            }, cs.prototype._next = function(e) {
                this.scheduleNotification(qi.createNext(e))
            }, cs.prototype._error = function(e) {
                this.errored = !0, this.queue = [], this.destination.error(e), this.unsubscribe()
            }, cs.prototype._complete = function() {
                this.scheduleNotification(qi.createComplete()), this.unsubscribe()
            }, cs),
            us = function(e, t) {
                this.time = e, this.notification = t
            };

        function cs(e, t, i) {
            e = os.call(this, e) || this;
            return e.delay = t, e.scheduler = i, e.queue = [], e.active = !1, e.errored = !1, e
        }

        function hs(e, t) {
            this.delay = e, this.scheduler = t
        }
        var ps, fs, ms, gs = (Es.prototype.call = function(e, t) {
                return t.subscribe(new ys(e, this.delayDurationSelector))
            }, Es),
            ys = (ut(Ts, ms = vr), Ts.prototype.notifyNext = function(e, t, i, r, n) {
                this.destination.next(e), this.removeSubscription(n), this.tryComplete()
            }, Ts.prototype.notifyError = function(e, t) {
                this._error(e)
            }, Ts.prototype.notifyComplete = function(e) {
                e = this.removeSubscription(e);
                e && this.destination.next(e), this.tryComplete()
            }, Ts.prototype._next = function(e) {
                var t = this.index++;
                try {
                    var i = this.delayDurationSelector(e, t);
                    i && this.tryDelay(i, e)
                } catch (e) {
                    this.destination.error(e)
                }
            }, Ts.prototype._complete = function() {
                this.completed = !0, this.tryComplete(), this.unsubscribe()
            }, Ts.prototype.removeSubscription = function(e) {
                e.unsubscribe();
                var t = this.delayNotifierSubscriptions.indexOf(e);
                return -1 !== t && this.delayNotifierSubscriptions.splice(t, 1), e.outerValue
            }, Ts.prototype.tryDelay = function(e, t) {
                t = Cr(this, e, t);
                t && !t.closed && (this.destination.add(t), this.delayNotifierSubscriptions.push(t))
            }, Ts.prototype.tryComplete = function() {
                this.completed && 0 === this.delayNotifierSubscriptions.length && this.destination.complete()
            }, Ts),
            vs = (ut(bs, fs = $t), bs.prototype._subscribe = function(e) {
                this.subscriptionDelay.subscribe(new vs(e, this.source))
            }, ut(Ss, ps = Pt), Ss.prototype._next = function(e) {
                this.subscribeToSource()
            }, Ss.prototype._error = function(e) {
                this.unsubscribe(), this.parent.error(e)
            }, Ss.prototype._complete = function() {
                this.unsubscribe(), this.subscribeToSource()
            }, Ss.prototype.subscribeToSource = function() {
                this.sourceSubscribed || (this.sourceSubscribed = !0, this.unsubscribe(), this.source.subscribe(this.parent))
            }, Ss);

        function Ss(e, t) {
            var i = ps.call(this) || this;
            return i.parent = e, i.source = t, i.sourceSubscribed = !1, i
        }

        function bs(e, t) {
            var i = fs.call(this) || this;
            return i.source = e, i.subscriptionDelay = t, i
        }

        function Ts(e, t) {
            e = ms.call(this, e) || this;
            return e.delayDurationSelector = t, e.completed = !1, e.delayNotifierSubscriptions = [], e.index = 0, e
        }

        function Es(e) {
            this.delayDurationSelector = e
        }

        function Is(t, i) {
            return function(e) {
                return e.lift(new As(t, i))
            }
        }
        var ws, As = (Cs.prototype.call = function(e, t) {
                return t.subscribe(new Os(e, this.compare, this.keySelector))
            }, Cs),
            Os = (ut(ks, ws = Pt), ks.prototype.compare = function(e, t) {
                return e === t
            }, ks.prototype._next = function(e) {
                try {
                    var t = this.keySelector,
                        i = t ? t(e) : e
                } catch (e) {
                    return this.destination.error(e)
                }
                t = !1;
                if (this.hasKey) try {
                    t = (0, this.compare)(this.key, i)
                } catch (e) {
                    return this.destination.error(e)
                } else this.hasKey = !0;
                t || (this.key = i, this.destination.next(e))
            }, ks);

        function ks(e, t, i) {
            e = ws.call(this, e) || this;
            return e.keySelector = i, e.hasKey = !1, "function" == typeof t && (e.compare = t), e
        }

        function Cs(e, t) {
            this.compare = e, this.keySelector = t
        }

        function Ds(t) {
            return function(e) {
                return 0 === t ? _i() : e.lift(new xs(t))
            }
        }
        var Ms, xs = (Ls.prototype.call = function(e, t) {
                return t.subscribe(new Ps(e, this.total))
            }, Ls),
            Ps = (ut(Rs, Ms = Pt), Rs.prototype._next = function(e) {
                var t = this.total,
                    i = ++this.count;
                i <= t && (this.destination.next(e), i === t && (this.destination.complete(), this.unsubscribe()))
            }, Rs);

        function Rs(e, t) {
            e = Ms.call(this, e) || this;
            return e.total = t, e.count = 0, e
        }

        function Ls(e) {
            if (this.total = e, this.total < 0) throw new lr
        }

        function _s(t, n) {
            return n ? function(e) {
                return e.pipe(_s(function(i, r) {
                    return Fr(t(i, r)).pipe(hr(function(e, t) {
                        return n(i, e, r, t)
                    }))
                }))
            } : function(e) {
                return e.lift(new Fs(t))
            }
        }
        var Ns, Fs = ($s.prototype.call = function(e, t) {
                return t.subscribe(new Bs(e, this.project))
            }, $s),
            Bs = (ut(Us, Ns = Vr), Us.prototype._next = function(e) {
                this.hasSubscription || this.tryNext(e)
            }, Us.prototype.tryNext = function(e) {
                var t, i = this.index++;
                try {
                    t = this.project(e, i)
                } catch (e) {
                    return void this.destination.error(e)
                }
                this.hasSubscription = !0, this._innerSub(t)
            }, Us.prototype._innerSub = function(e) {
                var t = new $r(this),
                    i = this.destination;
                i.add(t);
                e = Hr(e, t);
                e !== t && i.add(e)
            }, Us.prototype._complete = function() {
                this.hasCompleted = !0, this.hasSubscription || this.destination.complete(), this.unsubscribe()
            }, Us.prototype.notifyNext = function(e) {
                this.destination.next(e)
            }, Us.prototype.notifyError = function(e) {
                this.destination.error(e)
            }, Us.prototype.notifyComplete = function() {
                this.hasSubscription = !1, this.hasCompleted && this.destination.complete()
            }, Us);

        function Us(e, t) {
            e = Ns.call(this, e) || this;
            return e.project = t, e.hasSubscription = !1, e.hasCompleted = !1, e.index = 0, e
        }

        function $s(e) {
            this.project = e
        }

        function Vs(t) {
            return function(e) {
                return e.lift(new qs(t))
            }
        }
        var Ks, qs = (Qs.prototype.call = function(e, t) {
                return t.subscribe(new Hs(e, this.callback))
            }, Qs),
            Hs = (ut(js, Ks = Pt), js);

        function js(e, t) {
            e = Ks.call(this, e) || this;
            return e.add(new At(t)), e
        }

        function Qs(e) {
            this.callback = e
        }

        function Ws(t) {
            return function(e) {
                return 0 === t ? _i() : e.lift(new zs(t))
            }
        }
        var Gs, zs = (Js.prototype.call = function(e, t) {
                return t.subscribe(new Xs(e, this.total))
            }, Js),
            Xs = (ut(Ys, Gs = Pt), Ys.prototype._next = function(e) {
                var t = this.ring,
                    i = this.total,
                    r = this.count++;
                t.length < i ? t.push(e) : t[r % i] = e
            }, Ys.prototype._complete = function() {
                var e = this.destination,
                    t = this.count;
                if (0 < t)
                    for (var i = this.count >= this.total ? this.total : this.count, r = this.ring, n = 0; n < i; n++) {
                        var s = t++ % i;
                        e.next(r[s])
                    }
                e.complete()
            }, Ys);

        function Ys(e, t) {
            e = Gs.call(this, e) || this;
            return e.total = t, e.ring = new Array, e.count = 0, e
        }

        function Js(e) {
            if (this.total = e, this.total < 0) throw new lr
        }

        function Zs(t) {
            return function(e) {
                return e.lift(new ta(t))
            }
        }
        var ea, ta = (na.prototype.call = function(e, t) {
                return t.subscribe(new ia(e, this.value))
            }, na),
            ia = (ut(ra, ea = Pt), ra.prototype._next = function(e) {
                this.destination.next(this.value)
            }, ra);

        function ra(e, t) {
            e = ea.call(this, e) || this;
            return e.value = t, e
        }

        function na(e) {
            this.value = e
        }

        function sa(t, i) {
            var r = 2 <= arguments.length ? !0 : !1;
            return function(e) {
                return e.lift(new oa(t, i, r))
            }
        }
        var aa, oa = (ua.prototype.call = function(e, t) {
                return t.subscribe(new la(e, this.accumulator, this.seed, this.hasSeed))
            }, ua),
            la = (ut(da, aa = Pt), Object.defineProperty(da.prototype, "seed", {
                get: function() {
                    return this._seed
                },
                set: function(e) {
                    this.hasSeed = !0, this._seed = e
                },
                enumerable: !0,
                configurable: !0
            }), da.prototype._next = function(e) {
                if (this.hasSeed) return this._tryNext(e);
                this.seed = e, this.destination.next(e)
            }, da.prototype._tryNext = function(e) {
                var t, i = this.index++;
                try {
                    t = this.accumulator(this.seed, e, i)
                } catch (e) {
                    this.destination.error(e)
                }
                this.seed = t, this.destination.next(t)
            }, da);

        function da(e, t, i, r) {
            e = aa.call(this, e) || this;
            return e.accumulator = t, e._seed = i, e.hasSeed = r, e.index = 0, e
        }

        function ua(e, t, i) {
            void 0 === i && (i = !1), this.accumulator = e, this.seed = t, this.hasSeed = i
        }
        ca.prototype.call = function(e, t) {
            var i = this.selector,
                r = this.subjectFactory(),
                e = i(r).subscribe(e);
            return e.add(t.subscribe(r)), e
        };

        function ca(e, t) {
            this.subjectFactory = e, this.selector = t
        }

        function ha() {
            return function(e) {
                return e.lift(new fa)
            }
        }
        var pa, fa = (ya.prototype.call = function(e, t) {
                return t.subscribe(new ma(e))
            }, ya),
            ma = (ut(ga, pa = Pt), ga.prototype._next = function(e) {
                var t;
                this.hasPrev ? t = [this.prev, e] : this.hasPrev = !0, this.prev = e, t && this.destination.next(t)
            }, ga);

        function ga(e) {
            e = pa.call(this, e) || this;
            return e.hasPrev = !1, e
        }

        function ya() {}

        function va(t) {
            return function(e) {
                return e.lift(new ba(t, e))
            }
        }
        var Sa, ba = (Ia.prototype.call = function(e, t) {
                return t.subscribe(new Ta(e, this.notifier, this.source))
            }, Ia),
            Ta = (ut(Ea, Sa = Vr), Ea.prototype.error = function(e) {
                if (!this.isStopped) {
                    var t = this.errors,
                        i = this.retries,
                        r = this.retriesSubscription;
                    if (i) this.errors = void 0, this.retriesSubscription = void 0;
                    else {
                        t = new Xt;
                        try {
                            i = (0, this.notifier)(t)
                        } catch (e) {
                            return Sa.prototype.error.call(this, e)
                        }
                        r = Hr(i, new $r(this))
                    }
                    this._unsubscribeAndRecycle(), this.errors = t, this.retries = i, this.retriesSubscription = r, t.next(e)
                }
            }, Ea.prototype._unsubscribe = function() {
                var e = this.errors,
                    t = this.retriesSubscription;
                e && (e.unsubscribe(), this.errors = void 0), t && (t.unsubscribe(), this.retriesSubscription = void 0), this.retries = void 0
            }, Ea.prototype.notifyNext = function() {
                var e = this._unsubscribe;
                this._unsubscribe = null, this._unsubscribeAndRecycle(), this._unsubscribe = e, this.source.subscribe(this)
            }, Ea);

        function Ea(e, t, i) {
            e = Sa.call(this, e) || this;
            return e.notifier = t, e.source = i, e
        }

        function Ia(e, t) {
            this.notifier = e, this.source = t
        }

        function wa() {
            return new Xt
        }

        function Aa() {
            return function(e) {
                return ri()((t = e, i = "function" == typeof(r = wa) ? r : function() {
                    return r
                }, (e = Object.create(t, mi)).source = t, e.subjectFactory = i, e));
                var t, i, r
            }
        }

        function Oa(e, t, i) {
            var c = e && "object" == typeof e ? e : {
                bufferSize: e,
                windowTime: t,
                refCount: !1,
                scheduler: i
            };
            return function(e) {
                return e.lift((e = c.bufferSize, n = void 0 === e ? Number.POSITIVE_INFINITY : e, e = c.windowTime, s = void 0 === e ? Number.POSITIVE_INFINITY : e, a = c.refCount, o = c.scheduler, l = 0, u = d = !1, function(e) {
                    var t;
                    l++, !i || d ? (d = !1, i = new Ji(n, s, o), t = i.subscribe(this), r = e.subscribe({
                        next: function(e) {
                            i.next(e)
                        },
                        error: function(e) {
                            d = !0, i.error(e)
                        },
                        complete: function() {
                            u = !0, r = void 0, i.complete()
                        }
                    }), u && (r = void 0)) : t = i.subscribe(this), this.add(function() {
                        l--, t.unsubscribe(), t = void 0, r && !u && a && 0 === l && (r.unsubscribe(), i = r = void 0)
                    })
                }));
                var i, r, n, s, a, o, l, d, u
            }
        }

        function ka(t) {
            return function(e) {
                return e.lift(new Da(t))
            }
        }
        var Ca, Da = (Pa.prototype.call = function(e, t) {
                return t.subscribe(new Ma(e, this.total))
            }, Pa),
            Ma = (ut(xa, Ca = Pt), xa.prototype._next = function(e) {
                ++this.count > this.total && this.destination.next(e)
            }, xa);

        function xa(e, t) {
            e = Ca.call(this, e) || this;
            return e.total = t, e.count = 0, e
        }

        function Pa(e) {
            this.total = e
        }

        function Ra() {
            for (var t = [], e = 0; e < arguments.length; e++) t[e] = arguments[e];
            var i = t[t.length - 1];
            return Ni(i) ? (t.pop(), function(e) {
                return Jr(t, e, i)
            }) : function(e) {
                return Jr(t, e)
            }
        }

        function La(t, n) {
            return "function" == typeof n ? function(e) {
                return e.pipe(La(function(i, r) {
                    return Fr(t(i, r)).pipe(hr(function(e, t) {
                        return n(i, e, r, t)
                    }))
                }))
            } : function(e) {
                return e.lift(new Na(t))
            }
        }
        var _a, Na = (Ua.prototype.call = function(e, t) {
                return t.subscribe(new Fa(e, this.project))
            }, Ua),
            Fa = (ut(Ba, _a = Vr), Ba.prototype._next = function(e) {
                var t, i = this.index++;
                try {
                    t = this.project(e, i)
                } catch (e) {
                    return void this.destination.error(e)
                }
                this._innerSub(t)
            }, Ba.prototype._innerSub = function(e) {
                var t = this.innerSubscription;
                t && t.unsubscribe();
                var i = new $r(this),
                    t = this.destination;
                t.add(i), this.innerSubscription = Hr(e, i), this.innerSubscription !== i && t.add(this.innerSubscription)
            }, Ba.prototype._complete = function() {
                var e = this.innerSubscription;
                e && !e.closed || _a.prototype._complete.call(this), this.unsubscribe()
            }, Ba.prototype._unsubscribe = function() {
                this.innerSubscription = void 0
            }, Ba.prototype.notifyComplete = function() {
                this.innerSubscription = void 0, this.isStopped && _a.prototype._complete.call(this)
            }, Ba.prototype.notifyNext = function(e) {
                this.destination.next(e)
            }, Ba);

        function Ba(e, t) {
            e = _a.call(this, e) || this;
            return e.project = t, e.index = 0, e
        }

        function Ua(e) {
            this.project = e
        }

        function $a(e, t) {
            return t ? La(function() {
                return e
            }, t) : La(function() {
                return e
            })
        }

        function Va(t) {
            return function(e) {
                return e.lift(new qa(t))
            }
        }
        var Ka, qa = (Qa.prototype.call = function(e, t) {
                var i = new Ha(e),
                    e = Hr(this.notifier, new $r(i));
                return e && !i.seenValue ? (i.add(e), t.subscribe(i)) : i
            }, Qa),
            Ha = (ut(ja, Ka = Vr), ja.prototype.notifyNext = function() {
                this.seenValue = !0, this.complete()
            }, ja.prototype.notifyComplete = function() {}, ja);

        function ja(e) {
            e = Ka.call(this, e) || this;
            return e.seenValue = !1, e
        }

        function Qa(e) {
            this.notifier = e
        }

        function Wa(t, i) {
            return void 0 === i && (i = !1),
                function(e) {
                    return e.lift(new za(t, i))
                }
        }
        var Ga, za = (Ja.prototype.call = function(e, t) {
                return t.subscribe(new Xa(e, this.predicate, this.inclusive))
            }, Ja),
            Xa = (ut(Ya, Ga = Pt), Ya.prototype._next = function(e) {
                var t, i = this.destination;
                try {
                    t = this.predicate(e, this.index++)
                } catch (e) {
                    return void i.error(e)
                }
                this.nextOrComplete(e, t)
            }, Ya.prototype.nextOrComplete = function(e, t) {
                var i = this.destination;
                Boolean(t) ? i.next(e) : (this.inclusive && i.next(e), i.complete())
            }, Ya);

        function Ya(e, t, i) {
            e = Ga.call(this, e) || this;
            return e.predicate = t, e.inclusive = i, e.index = 0, e
        }

        function Ja(e, t) {
            this.predicate = e, this.inclusive = t
        }

        function Za(t, i, r) {
            return function(e) {
                return e.lift(new to(t, i, r))
            }
        }
        var eo, to = (so.prototype.call = function(e, t) {
                return t.subscribe(new io(e, this.nextOrObserver, this.error, this.complete))
            }, so),
            io = (ut(no, eo = Pt), no.prototype._next = function(e) {
                try {
                    this._tapNext.call(this._context, e)
                } catch (e) {
                    return void this.destination.error(e)
                }
                this.destination.next(e)
            }, no.prototype._error = function(e) {
                try {
                    this._tapError.call(this._context, e)
                } catch (e) {
                    return void this.destination.error(e)
                }
                this.destination.error(e)
            }, no.prototype._complete = function() {
                try {
                    this._tapComplete.call(this._context)
                } catch (e) {
                    return void this.destination.error(e)
                }
                return this.destination.complete()
            }, no),
            ro = {
                leading: !0,
                trailing: !1
            };

        function no(e, t, i, r) {
            e = eo.call(this, e) || this;
            return e._tapNext = or, e._tapError = or, e._tapComplete = or, e._tapError = i || or, e._tapComplete = r || or, yt(t) ? (e._context = e)._tapNext = t : t && (e._context = t, e._tapNext = t.next || or, e._tapError = t.error || or, e._tapComplete = t.complete || or), e
        }

        function so(e, t, i) {
            this.nextOrObserver = e, this.error = t, this.complete = i
        }

        function ao(t, i, r) {
            return void 0 === i && (i = ir), void 0 === r && (r = ro),
                function(e) {
                    return e.lift(new lo(t, i, r.leading, r.trailing))
                }
        }
        var oo, lo = (ho.prototype.call = function(e, t) {
                return t.subscribe(new uo(e, this.duration, this.scheduler, this.leading, this.trailing))
            }, ho),
            uo = (ut(co, oo = Pt), co.prototype._next = function(e) {
                this.throttled ? this.trailing && (this._trailingValue = e, this._hasTrailingValue = !0) : (this.add(this.throttled = this.scheduler.schedule(po, this.duration, {
                    subscriber: this
                })), this.leading ? this.destination.next(e) : this.trailing && (this._trailingValue = e, this._hasTrailingValue = !0))
            }, co.prototype._complete = function() {
                this._hasTrailingValue && this.destination.next(this._trailingValue), this.destination.complete()
            }, co.prototype.clearThrottle = function() {
                var e = this.throttled;
                e && (this.trailing && this._hasTrailingValue && (this.destination.next(this._trailingValue), this._trailingValue = null, this._hasTrailingValue = !1), e.unsubscribe(), this.remove(e), this.throttled = null)
            }, co);

        function co(e, t, i, r, n) {
            e = oo.call(this, e) || this;
            return e.duration = t, e.scheduler = i, e.leading = r, e.trailing = n, e._hasTrailingValue = !1, e._trailingValue = null, e
        }

        function ho(e, t, i, r) {
            this.duration = e, this.scheduler = t, this.leading = i, this.trailing = r
        }

        function po(e) {
            e.subscriber.clearThrottle()
        }
        var fo, mo = (vo.prototype.call = function(e, t) {
                return t.subscribe(new go(e, this.absoluteTimeout, this.waitFor, this.withObservable, this.scheduler))
            }, vo),
            go = (ut(yo, fo = Vr), yo.dispatchTimeout = function(e) {
                var t = e.withObservable;
                e._unsubscribeAndRecycle(), e.add(Hr(t, new $r(e)))
            }, yo.prototype.scheduleTimeout = function() {
                var e = this.action;
                e ? this.action = e.schedule(this, this.waitFor) : this.add(this.action = this.scheduler.schedule(yo.dispatchTimeout, this.waitFor, this))
            }, yo.prototype._next = function(e) {
                this.absoluteTimeout || this.scheduleTimeout(), fo.prototype._next.call(this, e)
            }, yo.prototype._unsubscribe = function() {
                this.action = void 0, this.scheduler = null, this.withObservable = null
            }, yo);

        function yo(e, t, i, r, n) {
            e = fo.call(this, e) || this;
            return e.absoluteTimeout = t, e.waitFor = i, e.withObservable = r, e.scheduler = n, e.scheduleTimeout(), e
        }

        function vo(e, t, i, r) {
            this.waitFor = e, this.absoluteTimeout = t, this.withObservable = i, this.scheduler = r
        }

        function So(e, t) {
            return void 0 === t && (t = ir), r = e, n = Vi(new dr), void 0 === (s = t) && (s = ir),
                function(e) {
                    var t = as(r),
                        i = t ? +r - s.now() : Math.abs(r);
                    return e.lift(new mo(i, t, n, s))
                };
            var r, n, s
        }

        function bo() {
            for (var i = [], e = 0; e < arguments.length; e++) i[e] = arguments[e];
            return function(e) {
                var t;
                return "function" == typeof i[i.length - 1] && (t = i.pop()), e.lift(new Io(i, t))
            }
        }
        var To, Eo, Io = (Co.prototype.call = function(e, t) {
                return t.subscribe(new wo(e, this.observables, this.project))
            }, Co),
            wo = (ut(ko, To = vr), ko.prototype.notifyNext = function(e, t, i) {
                this.values[i] = t;
                t = this.toRespond;
                0 < t.length && (-1 !== (i = t.indexOf(i)) && t.splice(i, 1))
            }, ko.prototype.notifyComplete = function() {}, ko.prototype._next = function(e) {
                0 === this.toRespond.length && (e = [e].concat(this.values), this.project ? this._tryProject(e) : this.destination.next(e))
            }, ko.prototype._tryProject = function(e) {
                var t;
                try {
                    t = this.project.apply(this, e)
                } catch (e) {
                    return void this.destination.error(e)
                }
                this.destination.next(t)
            }, ko),
            Ao = {
                type: null,
                entityIds: null,
                skip: !1
            },
            Oo = !1;

        function ko(e, t, i) {
            var r = To.call(this, e) || this;
            r.observables = t, r.project = i, r.toRespond = [];
            var n = t.length;
            r.values = new Array(n);
            for (var s = 0; s < n; s++) r.toRespond.push(s);
            for (s = 0; s < n; s++) {
                var a = t[s];
                r.add(Cr(r, a, void 0, s))
            }
            return r
        }

        function Co(e, t) {
            this.observables = e, this.project = t
        }

        function Do(e, t) {
            Mo(e, t), Oo = !0
        }

        function Mo(e, t) {
            !1 === Oo && (Ao.type = e, Ao.entityIds = t)
        }

        function xo(e, t) {
            return e.hasOwnProperty(t)
        }

        function Po(e) {
            return null == e
        }

        function Ro(e) {
            return Po(e) ? [] : Array.isArray(e) ? e : [e]
        }(iu = Eo = Eo || {}).Set = "Set", iu.Add = "Add", iu.Update = "Update", iu.Remove = "Remove";
        var Lo = "undefined" != typeof window,
            _o = !0;

        function No(e) {
            var t = typeof e;
            return null != e && ("object" == t || "function" == t)
        }

        function Fo(e) {
            return Array.isArray(e)
        }

        function Bo(e) {
            return !1 === Po(e)
        }

        function Uo(e) {
            return Fo(e) && 0 === e.length
        }

        function $o(e) {
            return "function" == typeof e
        }

        function Vo(e) {
            return void 0 === e
        }

        function Ko(e) {
            return e.hasOwnProperty("active")
        }

        function qo(e) {
            return Fo(e)
        }

        function Ho(e) {
            var t, i = e.active,
                r = e.ids,
                n = e.entities;
            return qo(i) ? (t = r, (r = (e = i).filter(function(e) {
                return -1 < t.indexOf(e)
            })).length === e.length ? e : r) : !1 === xo(n, i) ? null : i
        }

        function jo(e, t) {
            var i, r, n = {};
            try {
                for (var s = ft(Object.keys(e)), a = s.next(); !a.done; a = s.next()) {
                    var o = a.value;
                    n[o] = t(e[o])
                }
            } catch (e) {
                i = {
                    error: e
                }
            } finally {
                try {
                    a && !a.done && (r = s.return) && r.call(s)
                } finally {
                    if (i) throw i.error
                }
            }
            return n
        }
        var Qo = {
            resettable: !1,
            ttl: null,
            producerFn: void 0
        };

        function Wo(t) {
            Object.freeze(t);
            var i = "function" == typeof t,
                r = Object.prototype.hasOwnProperty;
            return Object.getOwnPropertyNames(t).forEach(function(e) {
                !r.call(t, e) || i && ("caller" === e || "callee" === e || "arguments" === e) || null === t[e] || "object" != typeof t[e] && "function" != typeof t[e] || Object.isFrozen(t[e]) || Wo(t[e])
            }), t
        }
        var Go, zo = new Xt,
            Xo = new Ji(50, 5e3),
            Yo = new Xt;

        function Jo(e) {
            return null != e && "" + e != "false"
        }

        function Zo(e) {
            return Jo(e) && "Object" === e.constructor.name
        }
        ut(function(e) {
            return Go.call(this, e) || this
        }, Go = Error);
        var el = {},
            tl = {};
        Lo && (window.$$stores = el, window.$$queries = tl);
        var il = new Xt,
            rl = new yi(!1),
            nl = {
                activeTransactions: 0,
                batchTransaction: null
            };

        function sl() {
            return 0 < nl.activeTransactions
        }

        function al(e, t) {
            void 0 === t && (t = void 0), sl() || (nl.batchTransaction = new Xt), nl.activeTransactions++, rl.next(!0);
            try {
                return e.apply(t)
            } finally {
                Do("@Transaction"), 0 == --nl.activeTransactions && (nl.batchTransaction.next(!0), nl.batchTransaction.complete(), rl.next(!1), il.next(!0))
            }
        }

        function ol() {
            return function(e, t, i) {
                var r = i.value;
                return i.value = function() {
                    for (var e = this, t = [], i = 0; i < arguments.length; i++) t[i] = arguments[i];
                    return al(function() {
                        return r.apply(e, t)
                    }, this)
                }, i
            }
        }

        function ll(t) {
            return function(e) {
                return e.pipe(Za(function(e) {
                    return al(function() {
                        return t(e)
                    })
                }))
            }
        }
        var dl = (ul.prototype.setLoading = function(t) {
            (t = void 0 === t ? !1 : t) !== this._value().loading && (_o && Mo("Set Loading"), this._setState(function(e) {
                return ct({}, e, {
                    loading: t
                })
            }))
        }, ul.prototype.setHasCache = function(e, t) {
            var i, r = this;
            void 0 === t && (t = {
                restartTTL: !1
            }), e !== this.cache.active.value && this.cache.active.next(e), t.restartTTL && (i = this.getCacheTTL()) && (null !== this.cache.ttl && clearTimeout(this.cache.ttl), this.cache.ttl = setTimeout(function() {
                return r.setHasCache(!1)
            }, i))
        }, ul.prototype.getValue = function() {
            return this.storeValue
        }, ul.prototype.setError = function(t) {
            t !== this._value().error && (_o && Mo("Set Error"), this._setState(function(e) {
                return ct({}, e, {
                    error: t
                })
            }))
        }, ul.prototype._select = function(t) {
            return this.store.asObservable().pipe(hr(function(e) {
                return t(e.state)
            }), Is())
        }, ul.prototype._value = function() {
            return this.storeValue
        }, ul.prototype._cache = function() {
            return this.cache.active
        }, Object.defineProperty(ul.prototype, "config", {
            get: function() {
                return this.constructor.akitaConfig || {}
            },
            enumerable: !0,
            configurable: !0
        }), Object.defineProperty(ul.prototype, "storeName", {
            get: function() {
                return this.config.storeName || this.options.storeName || this.options.name
            },
            enumerable: !0,
            configurable: !0
        }), Object.defineProperty(ul.prototype, "deepFreeze", {
            get: function() {
                return this.config.deepFreezeFn || this.options.deepFreezeFn || Wo
            },
            enumerable: !0,
            configurable: !0
        }), Object.defineProperty(ul.prototype, "cacheConfig", {
            get: function() {
                return this.config.cache || this.options.cache
            },
            enumerable: !0,
            configurable: !0
        }), Object.defineProperty(ul.prototype, "_producerFn", {
            get: function() {
                return this.config.producerFn || this.options.producerFn || Qo.producerFn
            },
            enumerable: !0,
            configurable: !0
        }), Object.defineProperty(ul.prototype, "resettable", {
            get: function() {
                return (Bo(this.config.resettable) ? this.config : this.options).resettable
            },
            enumerable: !0,
            configurable: !0
        }), ul.prototype._setState = function(e, t) {
            var i, r = this;
            if (void 0 === t && (t = !0), $o(e) ? (i = e(this._value()), this.storeValue = _o ? this.deepFreeze(i) : i) : this.storeValue = e, !this.store) return this.store = new yi({
                state: this.storeValue
            }), void(_o && this.store.subscribe(function(e) {
                var t = e.action;
                t && (e = r.storeName, Yo.next({
                    storeName: e,
                    action: t
                }))
            }));
            sl() ? this.handleTransaction() : this.dispatch(this.storeValue, t)
        }, ul.prototype.reset = function() {
            var e = this;
            this.isResettable() ? (_o && Mo("Reset"), this._setState(function() {
                return Object.assign({}, e._initialState)
            }), this.setHasCache(!1)) : _o && console.warn("You need to enable the reset functionality")
        }, ul.prototype.update = function(e) {
            _o && Mo("Update");
            var t = this._value(),
                e = $o(e) ? $o(this._producerFn) ? this._producerFn(t, e) : e(t) : e,
                e = this.akitaPreUpdate(t, ct({}, t, e)),
                e = Zo(t) ? e : new t.constructor(e);
            this._setState(e)
        }, ul.prototype.updateStoreConfig = function(e) {
            this.options = ct({}, this.options, e)
        }, ul.prototype.akitaPreUpdate = function(e, t) {
            return t
        }, ul.prototype.ngOnDestroy = function() {
            this.destroy()
        }, ul.prototype.destroy = function() {
            var e;
            Lo && window.hmrEnabled || this !== el[this.storeName] || (delete el[this.storeName], e = this.storeName, zo.next(e), this.setHasCache(!1), this.cache.active.complete(), this.store.complete())
        }, ul.prototype.onInit = function(e) {
            var t, i;
            (el[this.storeName] = this)._setState(function() {
                return e
            }), i = this.storeName, Xo.next(i), this.isResettable() && (this._initialState = e), _o && (t = this.storeName, i = this.constructor.name, t || console.error("@StoreConfig({ name }) is missing in " + i))
        }, ul.prototype.dispatch = function(e, t) {
            var i = void 0;
            (t = void 0 === t ? !0 : t) && (i = Ao, Oo = !1), this.store.next({
                state: e,
                action: i
            })
        }, ul.prototype.watchTransaction = function() {
            var e = this;
            (nl.batchTransaction ? nl.batchTransaction.asObservable() : $i(!0)).subscribe(function() {
                e.inTransaction = !1, e.dispatch(e._value())
            })
        }, ul.prototype.isResettable = function() {
            return !1 !== this.resettable && (this.resettable || Qo.resettable)
        }, ul.prototype.handleTransaction = function() {
            this.inTransaction || (this.watchTransaction(), this.inTransaction = !0)
        }, ul.prototype.getCacheTTL = function() {
            return this.cacheConfig && this.cacheConfig.ttl || Qo.ttl
        }, ul);

        function ul(e, t) {
            this.options = t = void 0 === t ? {} : t, this.inTransaction = !1, this.cache = {
                active: new yi(!1),
                ttl: null
            }, this.onInit(e)
        }
        var cl, hl, pl, fl = (ut(yl, pl = dl), Object.defineProperty(yl.prototype, "selectEntityAction$", {
                get: function() {
                    return this.entityActions.asObservable()
                },
                enumerable: !0,
                configurable: !0
            }), Object.defineProperty(yl.prototype, "selectEntityIdChanges$", {
                get: function() {
                    return this.entityIdChanges.asObservable()
                },
                enumerable: !0,
                configurable: !0
            }), Object.defineProperty(yl.prototype, "idKey", {
                get: function() {
                    return this.config.idKey || this.options.idKey || "id"
                },
                enumerable: !0,
                configurable: !0
            }), yl.prototype.set = function(a, o) {
                var l, d = this;
                void 0 === o && (o = {}), Po(a) || (_o && Mo("Set Entity"), l = this.akitaPreAddEntity === yl.prototype.akitaPreAddEntity, this.setHasCache(!0, {
                    restartTTL: !0
                }), this._setState(function(e) {
                    var t, i, r, n, s, e = (t = {
                        state: e,
                        entities: a,
                        idKey: d.idKey,
                        preAddEntity: d.akitaPreAddEntity,
                        isNativePreAdd: l
                    }, r = t.state, n = t.entities, s = t.idKey, e = t.preAddEntity, t = t.isNativePreAdd, e = Fo(n) ? (i = (s = function(e, t, i) {
                        var r, n, s = {
                            entities: {},
                            ids: []
                        };
                        try {
                            for (var a = ft(e), o = a.next(); !o.done; o = a.next()) {
                                var l = i(o.value);
                                s.entities[l[t]] = l, s.ids.push(l[t])
                            }
                        } catch (e) {
                            r = {
                                error: e
                            }
                        } finally {
                            try {
                                o && !o.done && (n = a.return) && n.call(a)
                            } finally {
                                if (r) throw r.error
                            }
                        }
                        return s
                    }(n, s, e)).entities, s.ids) : n.entities && n.ids ? (i = t ? n.entities : jo(n.entities, e), n.ids) : (i = t ? n : jo(n, e), Object.keys(i).map(function(e) {
                        return isNaN(e) ? e : Number(e)
                    })), e = ct({}, r, {
                        entities: i,
                        ids: e,
                        loading: !1
                    }), Ko(r) && (e.active = Ho(e)), e);
                    return !1 === Vo(o.activeId) && (e.active = o.activeId), e
                }), this.hasInitialUIState() && this.handleUICreation(), this.entityActions.next({
                    type: Eo.Set,
                    ids: this.ids
                }))
            }, yl.prototype.add = function(e, t) {
                void 0 === t && (t = {
                    loading: !1
                });
                var i, e = Ro(e);
                Uo(e) || (i = function(e) {
                    var t, i, r = e.state,
                        n = e.entities,
                        s = e.idKey,
                        a = e.options,
                        o = void 0 === a ? {} : a,
                        l = e.preAddEntity,
                        d = {},
                        u = [],
                        c = !1;
                    try {
                        for (var h = ft(n), p = h.next(); !p.done; p = h.next()) {
                            var f, m, g = p.value;
                            !1 === xo(r.entities, g[s]) && (d[m = (f = l(g))[s]] = f, o.prepend ? u.unshift(m) : u.push(m), c = !0)
                        }
                    } catch (e) {
                        t = {
                            error: e
                        }
                    } finally {
                        try {
                            p && !p.done && (i = h.return) && i.call(h)
                        } finally {
                            if (t) throw t.error
                        }
                    }
                    return c ? {
                        newState: ct({}, r, {
                            entities: ct({}, r.entities, d),
                            ids: o.prepend ? gt(u, r.ids) : gt(r.ids, u)
                        }),
                        newIds: u
                    } : null
                }({
                    state: this._value(),
                    preAddEntity: this.akitaPreAddEntity,
                    entities: e,
                    idKey: this.idKey,
                    options: t
                })) && (_o && Mo("Add Entity"), i.newState.loading = t.loading, this._setState(function() {
                    return i.newState
                }), this.hasInitialUIState() && this.handleUICreation(!0), this.entityActions.next({
                    type: Eo.Add,
                    ids: i.newIds
                }))
            }, yl.prototype.update = function(t, i) {
                var r, n, s = this;
                Vo(i) ? pl.prototype.update.call(this, t) : (n = [], Uo(n = $o(t) ? this.ids.filter(function(e) {
                    return t(s.entities[e])
                }) : Po(t) ? this.ids : Ro(t)) || (_o && Mo("Update Entity", n), this._setState(function(e) {
                    return function(e) {
                        var t = e.state,
                            i = e.ids,
                            r = e.idKey,
                            n = e.newStateOrFn,
                            s = e.preUpdateEntity,
                            a = e.producerFn,
                            o = e.onEntityIdChanges,
                            l = {},
                            d = !1;
                        try {
                            for (var u = ft(i), c = u.next(); !c.done; c = u.next()) {
                                var h, p, f, m, g, y, v = c.value;
                                !1 !== xo(t.entities, v) && (h = t.entities[v], p = void 0, f = (p = $o(n) ? $o(a) ? a(h, n) : n(h) : n).hasOwnProperty(r) && p[r] !== h[r], y = void 0, m = v, f && (d = !0, m = p[r]), g = ct({}, h, p), y = Zo(h) ? g : new(Zo(p) ? h : p).constructor(g), l[m] = s(h, y))
                            }
                        } catch (e) {
                            T = {
                                error: e
                            }
                        } finally {
                            try {
                                c && !c.done && (b = u.return) && b.call(u)
                            } finally {
                                if (T) throw T.error
                            }
                        }
                        var S, b = t.ids,
                            T = t.entities;
                        return d && (S = mt(i, 1)[0], T = function(e, t) {
                            var i = {};
                            for (n in e) Object.prototype.hasOwnProperty.call(e, n) && t.indexOf(n) < 0 && (i[n] = e[n]);
                            if (null != e && "function" == typeof Object.getOwnPropertySymbols)
                                for (var r = 0, n = Object.getOwnPropertySymbols(e); r < n.length; r++) t.indexOf(n[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, n[r]) && (i[n[r]] = e[n[r]]);
                            return i
                        }(t.entities, ["symbol" == typeof S ? S : S + ""]), b = t.ids.map(function(e) {
                            return e === S ? m : e
                        }), o(S, m)), ct({}, t, {
                            entities: ct({}, T, l),
                            ids: b
                        })
                    }({
                        idKey: s.idKey,
                        ids: n,
                        preUpdateEntity: s.akitaPreUpdateEntity,
                        state: e,
                        newStateOrFn: i,
                        producerFn: s._producerFn,
                        onEntityIdChanges: function(e, t) {
                            r = {
                                oldId: e,
                                newId: t
                            }, s.entityIdChanges.next(ct({}, r, {
                                pending: !0
                            }))
                        }
                    })
                }), r && this.entityIdChanges.next(ct({}, r, {
                    pending: !1
                })), this.entityActions.next({
                    type: Eo.Update,
                    ids: n
                })))
            }, yl.prototype.upsert = function(e, i, r, t) {
                var n = this;
                void 0 === t && (t = {});
                var s = Ro(e),
                    e = function(t) {
                        return function(e) {
                            return xo(n.entities, e) === t
                        }
                    },
                    a = $o(r) ? t.baseClass : r ? r.baseClass : void 0,
                    o = $o(a),
                    t = s.filter(e(!0)),
                    e = s.filter(e(!1)).map(function(e) {
                        var t = "function" == typeof i ? i({}) : i,
                            t = $o(r) ? r(e, t) : t,
                            t = ct({}, t, ((t = {})[n.idKey] = e, t));
                        return o ? new a(t) : t
                    });
                this.update(t, i), this.add(e), _o && Do("Upsert Entity")
            }, yl.prototype.upsertMany = function(e, t) {
                var i, r;
                void 0 === t && (t = {});
                var n = [],
                    s = [],
                    a = {};
                try {
                    for (var o = ft(e), l = o.next(); !l.done; l = o.next()) {
                        var d, u, c, h, p, f, m = l.value,
                            g = this.akitaPreCheckEntity(m),
                            y = g[this.idKey];
                        xo(this.entities, y) ? (d = this._value().entities[y], u = ct({}, this._value().entities[y], g), c = t.baseClass ? new t.baseClass(u) : u, f = (h = this.akitaPreUpdateEntity(d, c))[this.idKey], a[f] = h, s.push(f)) : (p = t.baseClass ? new t.baseClass(g) : g, f = (h = this.akitaPreAddEntity(p))[this.idKey], n.push(f), a[f] = h)
                    }
                } catch (e) {
                    i = {
                        error: e
                    }
                } finally {
                    try {
                        l && !l.done && (r = o.return) && r.call(o)
                    } finally {
                        if (i) throw i.error
                    }
                }
                _o && Do("Upsert Many"), this._setState(function(e) {
                    return ct({}, e, {
                        ids: n.length ? gt(e.ids, n) : e.ids,
                        entities: ct({}, e.entities, a),
                        loading: !!t.loading
                    })
                }), s.length && this.entityActions.next({
                    type: Eo.Update,
                    ids: s
                }), n.length && this.entityActions.next({
                    type: Eo.Add,
                    ids: n
                }), n.length && this.hasUIStore() && this.handleUICreation(!0)
            }, yl.prototype.replace = function(e, t) {
                var i, r, n = Ro(e);
                if (!Uo(n)) {
                    var s = {};
                    try {
                        for (var a = ft(n), o = a.next(); !o.done; o = a.next()) {
                            var l = o.value;
                            t[this.idKey] = l, s[l] = t
                        }
                    } catch (e) {
                        i = {
                            error: e
                        }
                    } finally {
                        try {
                            o && !o.done && (r = a.return) && r.call(a)
                        } finally {
                            if (i) throw i.error
                        }
                    }
                    _o && Mo("Replace Entity", e), this._setState(function(e) {
                        return ct({}, e, {
                            entities: ct({}, e.entities, s)
                        })
                    })
                }
            }, yl.prototype.move = function(e, t) {
                var i = this.ids.slice();
                i.splice(t < 0 ? i.length + t : t, 0, i.splice(e, 1)[0]), _o && Mo("Move Entity"), this._setState(function(e) {
                    return ct({}, e, {
                        entities: ct({}, e.entities),
                        ids: i
                    })
                })
            }, yl.prototype.remove = function(t) {
                var e, i, r = this;
                Uo(this.ids) || (e = Bo(t), i = [], Uo(i = $o(t) ? this.ids.filter(function(e) {
                    return t(r.entities[e])
                }) : e ? Ro(t) : this.ids) || (_o && Mo("Remove Entity", i), this._setState(function(e) {
                    return function(e) {
                        var t, i = e.state,
                            r = e.ids;
                        if (Po(r)) return ct({}, i, {
                            entities: {},
                            ids: [],
                            active: qo(i.active) ? [] : null
                        });
                        var n = i.entities,
                            s = {};
                        try {
                            for (var a = ft(i.ids), o = a.next(); !o.done; o = a.next()) {
                                var l = o.value;
                                !1 === r.includes(l) && (s[l] = n[l])
                            }
                        } catch (e) {
                            d = {
                                error: e
                            }
                        } finally {
                            try {
                                o && !o.done && (t = a.return) && t.call(a)
                            } finally {
                                if (d) throw d.error
                            }
                        }
                        var d = ct({}, i, {
                            entities: s,
                            ids: i.ids.filter(function(e) {
                                return !1 === r.includes(e)
                            })
                        });
                        return Ko(i) && (d.active = Ho(d)), d
                    }({
                        state: e,
                        ids: i
                    })
                }), e || this.setHasCache(!1), this.handleUIRemove(i), this.entityActions.next({
                    type: Eo.Remove,
                    ids: i
                })))
            }, yl.prototype.updateActive = function(e) {
                var t = Ro(this.active);
                _o && Mo("Update Active", t), this.update(t, e)
            }, yl.prototype.setActive = function(e) {
                e = function(e, t, i) {
                    var r;
                    if (Fo(e)) r = e;
                    else if (No(e)) {
                        if (Po(i)) return;
                        e = Object.assign({
                            wrap: !0
                        }, e);
                        var n = t.indexOf(i);
                        if (e.prev) {
                            var s = 0 === n;
                            if (s && !e.wrap) return;
                            r = s ? t[t.length - 1] : t[n - 1]
                        } else if (e.next) {
                            s = t.length === n + 1;
                            if (s && !e.wrap) return;
                            r = s ? t[0] : t[n + 1]
                        }
                    } else {
                        if (e === i) return;
                        r = e
                    }
                    return r
                }(e, this.ids, this.active);
                void 0 !== e && (_o && Mo("Set Active", e), this._setActive(e))
            }, yl.prototype.addActive = function(e) {
                var t = this,
                    i = Ro(e);
                Uo(i) || i.every(function(e) {
                    return -1 < t.active.indexOf(e)
                }) || (_o && Mo("Add Active", e), this._setState(function(e) {
                    var t = Array.from(new Set(gt(e.active, i)));
                    return ct({}, e, {
                        active: t
                    })
                }))
            }, yl.prototype.removeActive = function(e) {
                var t = this,
                    i = Ro(e);
                Uo(i) || i.some(function(e) {
                    return -1 < t.active.indexOf(e)
                }) && (_o && Mo("Remove Active", e), this._setState(function(e) {
                    return ct({}, e, {
                        active: Array.isArray(e.active) ? e.active.filter(function(e) {
                            return -1 === i.indexOf(e)
                        }) : null
                    })
                }))
            }, yl.prototype.toggleActive = function(e) {
                var i = this,
                    t = Ro(e),
                    r = function(t) {
                        return function(e) {
                            return i.active.includes(e) === t
                        }
                    },
                    e = t.filter(r(!0)),
                    r = t.filter(r(!1));
                this.removeActive(e), this.addActive(r), _o && Do("Toggle Active")
            }, yl.prototype.createUIStore = function(e, t) {
                var i = {
                    name: "UI/" + this.storeName,
                    idKey: this.idKey
                };
                return this.ui = new ml(e = void 0 === e ? {} : e, ct({}, i, t = void 0 === t ? {} : t)), this.ui
            }, yl.prototype.destroy = function() {
                pl.prototype.destroy.call(this), this.ui instanceof yl && this.ui.destroy(), this.entityActions.complete()
            }, yl.prototype.akitaPreUpdateEntity = function(e, t) {
                return t
            }, yl.prototype.akitaPreAddEntity = function(e) {
                return e
            }, yl.prototype.akitaPreCheckEntity = function(e) {
                return e
            }, Object.defineProperty(yl.prototype, "ids", {
                get: function() {
                    return this._value().ids
                },
                enumerable: !0,
                configurable: !0
            }), Object.defineProperty(yl.prototype, "entities", {
                get: function() {
                    return this._value().entities
                },
                enumerable: !0,
                configurable: !0
            }), Object.defineProperty(yl.prototype, "active", {
                get: function() {
                    return this._value().active
                },
                enumerable: !0,
                configurable: !0
            }), yl.prototype._setActive = function(t) {
                this._setState(function(e) {
                    return ct({}, e, {
                        active: t
                    })
                })
            }, yl.prototype.handleUICreation = function(e) {
                var r = this,
                    t = this.ids,
                    n = $o(this.ui._akitaCreateEntityFn),
                    i = function(e) {
                        var t = r.entities[e],
                            i = n ? r.ui._akitaCreateEntityFn(t) : r.ui._akitaCreateEntityFn;
                        return ct(((e = {})[r.idKey] = t[r.idKey], e), i)
                    },
                    i = ((e = void 0 === e ? !1 : e) ? this.ids.filter(function(e) {
                        return Vo(r.ui.entities[e])
                    }) : t).map(i);
                e ? this.ui.add(i) : this.ui.set(i)
            }, yl.prototype.hasInitialUIState = function() {
                return this.hasUIStore() && !1 === Vo(this.ui._akitaCreateEntityFn)
            }, yl.prototype.handleUIRemove = function(e) {
                this.hasUIStore() && this.ui.remove(e)
            }, yl.prototype.hasUIStore = function() {
                return this.ui instanceof ml
            }, ht([ol(), pt("design:type", Function), pt("design:paramtypes", [Object, Object, Object, Object]), pt("design:returntype", void 0)], yl.prototype, "upsert", null), ht([ol(), pt("design:type", Function), pt("design:paramtypes", ["function" == typeof(w = "undefined" != typeof T && T) ? w : Object]), pt("design:returntype", void 0)], yl.prototype, "toggleActive", null), yl),
            ml = (ut(gl, hl = fl), gl.prototype.setInitialEntityState = function(e) {
                this._akitaCreateEntityFn = e
            }, gl);

        function gl(e, t) {
            return hl.call(this, e = void 0 === e ? {} : e, t = void 0 === t ? {} : t) || this
        }

        function yl(e, t) {
            void 0 === t && (t = {});
            e = pl.call(this, ct({}, {
                entities: {},
                ids: [],
                loading: !0,
                error: null
            }, e = void 0 === e ? {} : e), t) || this;
            return e.options = t, e.entityActions = new Xt, e.entityIdChanges = new Xt, e
        }

        function vl() {
            return Is(function(e, t) {
                return e === t || !1 !== Fo(e) && !1 !== Fo(t) && (!(!Uo(e) || !Uo(t)) || !Sl(t, e) && !1 === Sl(e, t))
            })
        }

        function Sl(e, t) {
            return t.some(function(t) {
                return void 0 === e.find(function(e) {
                    return e === t
                })
            })
        }

        function bl(i, e) {
            for (var r, n, s, a = [], o = i.ids, l = i.entities, d = e.filterBy, t = e.limitTo, u = e.sortBy, e = e.sortByOrder, c = 0; c < o.length; c++) ! function(t) {
                var i = l[o[t]];
                if (!d) return a.push(i);
                Ro(d).every(function(e) {
                    return e(i, t)
                }) && a.push(i)
            }(c);
            u && (s = $o(u) ? u : (r = u, void 0 === (n = e) && (n = cl.ASC), function(e, t) {
                if (!e.hasOwnProperty(r) || !t.hasOwnProperty(r)) return 0;
                var i = "string" == typeof e[r] ? e[r].toUpperCase() : e[r],
                    e = "string" == typeof t[r] ? t[r].toUpperCase() : t[r],
                    t = 0;
                return e < i ? t = 1 : i < e && (t = -1), n == cl.DESC ? -1 * t : t
            }), a = a.sort(function(e, t) {
                return s(e, t, i)
            }));
            t = Math.min(t || a.length, a.length);
            return t === a.length ? a : a.slice(0, t)
        }

        function Tl(e) {
            return "string" == typeof e
        }

        function El(t, i) {
            return function(e) {
                e = e[t];
                if (!Vo(e)) return i ? Tl(i) ? e[i] : i(e) : e
            }
        }(vi = cl = cl || {}).ASC = "asc", vi.DESC = "desc";
        Il.prototype.select = function(t) {
            var e, n;
            if ($o(t)) e = t;
            else if (Tl(t)) e = function(e) {
                return e[t]
            };
            else {
                if (Array.isArray(t)) return this.store._select(function(e) {
                    return e
                }).pipe(Is((n = t, function(t, i) {
                    var r = $o(n[0]);
                    return !1 === n.some(function(e) {
                        return r ? e(t) !== e(i) : t[e] !== i[e]
                    })
                })), hr(function(i) {
                    return $o(t[0]) ? t.map(function(e) {
                        return e(i)
                    }) : t.reduce(function(e, t) {
                        return e[t] = i[t], e
                    }, {})
                }));
                e = function(e) {
                    return e
                }
            }
            return this.store._select(e)
        }, Il.prototype.selectLoading = function() {
            return this.select(function(e) {
                return e.loading
            })
        }, Il.prototype.selectError = function() {
            return this.select(function(e) {
                return e.error
            })
        }, Il.prototype.getValue = function() {
            return this.store._value()
        }, Il.prototype.selectHasCache = function() {
            return this.store._cache().asObservable()
        }, Il.prototype.getHasCache = function() {
            return this.store._cache().value
        }, Object.defineProperty(Il.prototype, "config", {
            get: function() {
                return this.constructor.akitaQueryConfig
            },
            enumerable: !0,
            configurable: !0
        }), bi = Il;

        function Il(e) {
            this.store = e, this.__store__ = e, _o && (tl[e.storeName] = this)
        }

        function wl(e) {
            return e.pipe(ln(function(e) {
                return null != e
            }))
        }
        var Al, Ol, kl = (ut(Ml, Ol = bi), Ml.prototype.selectAll = function(e) {
                var t = this;
                return void 0 === e && (e = {
                    asObject: !1
                }), this.select(function(e) {
                    return e.entities
                }).pipe(hr(function() {
                    return t.getAll(e)
                }))
            }, Ml.prototype.getAll = function(e) {
                return (e = void 0 === e ? {
                    asObject: !1,
                    filterBy: void 0,
                    limitTo: void 0
                } : e).asObject ? function(e, t) {
                    var r = {},
                        n = t.filterBy,
                        s = t.limitTo,
                        a = e.ids,
                        o = e.entities;
                    if (!n && !s) return o;
                    e = !1 === Po(s);
                    if (n && e)
                        for (var l = 0, i = 0, d = a.length; i < d && "break" !== function(t) {
                                if (l === s) return "break";
                                var e = a[t],
                                    i = o[e];
                                Ro(n).every(function(e) {
                                    return e(i, t)
                                }) && (r[e] = i, l++)
                            }(i); i++);
                    else
                        for (var u = Math.min(s || a.length, a.length), i = 0; i < u; i++) ! function(t) {
                            var e = a[t],
                                i = o[e];
                            if (!n) return r[e] = i;
                            Ro(n).every(function(e) {
                                return e(i, t)
                            }) && (r[e] = i)
                        }(i);
                    return r
                }(this.getValue(), e) : (t = e, i = this.config || this.options, t.sortBy = t.sortBy || i && i.sortBy, t.sortByOrder = t.sortByOrder || i && i.sortByOrder, bl(this.getValue(), e));
                var t, i
            }, Ml.prototype.selectMany = function(e, i) {
                return e && e.length ? this.select(function(e) {
                    return e.entities
                }).pipe(hr(function(t) {
                    return n = function(e) {
                        return El(e, i)(t)
                    }, e.reduce(function(e, t, i, r) {
                        t = n(t);
                        return void 0 !== t && e.push(t), e
                    }, []);
                    var n
                }), vl()) : $i([])
            }, Ml.prototype.selectEntity = function(e, t) {
                var i = e;
                return $o(e) && (i = function(e, t) {
                    var i, r;
                    try {
                        for (var n = ft(Object.keys(t)), s = n.next(); !s.done; s = n.next()) {
                            var a = s.value;
                            if (!0 === e(t[a])) return a
                        }
                    } catch (e) {
                        i = {
                            error: e
                        }
                    } finally {
                        try {
                            s && !s.done && (r = n.return) && r.call(n)
                        } finally {
                            if (i) throw i.error
                        }
                    }
                }(e, this.getValue().entities)), this.select(function(e) {
                    return e.entities
                }).pipe(hr(El(i, t)), Is())
            }, Ml.prototype.getEntity = function(e) {
                return this.getValue().entities[e]
            }, Ml.prototype.selectActiveId = function() {
                return this.select(function(e) {
                    return e.active
                })
            }, Ml.prototype.getActiveId = function() {
                return this.getValue().active
            }, Ml.prototype.selectActive = function(t) {
                var i = this;
                return Fo(this.getActive()) ? this.selectActiveId().pipe(La(function(e) {
                    return i.selectMany(e, t)
                })) : this.selectActiveId().pipe(La(function(e) {
                    return i.selectEntity(e, t)
                }))
            }, Ml.prototype.getActive = function() {
                var t = this,
                    e = this.getActiveId();
                return Fo(e) ? e.map(function(e) {
                    return t.getValue().entities[e]
                }) : Jo(e) ? this.getEntity(e) : void 0
            }, Ml.prototype.selectCount = function(e) {
                var t = this;
                return this.select(function(e) {
                    return e.entities
                }).pipe(hr(function() {
                    return t.getCount(e)
                }))
            }, Ml.prototype.getCount = function(e) {
                return ($o(e) ? this.getAll().filter(e) : this.getValue().ids).length
            }, Ml.prototype.selectLast = function(e) {
                return this.selectAt(function(e) {
                    return e[e.length - 1]
                }, e)
            }, Ml.prototype.selectFirst = function(e) {
                return this.selectAt(function(e) {
                    return e[0]
                }, e)
            }, Ml.prototype.selectEntityAction = function(e) {
                if (Po(e)) return this.store.selectEntityAction$;
                var t = Fo(e) ? function(e) {
                        return e
                    } : function(e) {
                        return e.ids
                    },
                    i = Ro(e);
                return this.store.selectEntityAction$.pipe(ln(function(e) {
                    e = e.type;
                    return i.includes(e)
                }), hr(function(e) {
                    return t(e)
                }))
            }, Ml.prototype.hasEntity = function(e) {
                var t = this;
                return Po(e) ? 0 < this.getValue().ids.length : $o(e) ? this.getAll().some(e) : Fo(e) ? e.every(function(e) {
                    return e in t.getValue().entities
                }) : e in this.getValue().entities
            }, Ml.prototype.hasActive = function(e) {
                var t = this.getValue().active,
                    i = Bo(e);
                return Array.isArray(t) ? i ? t.includes(e) : 0 < t.length : i ? t === e : Bo(t)
            }, Ml.prototype.createUIQuery = function() {
                this.ui = new Cl(this.__store__.ui)
            }, Ml.prototype.selectAt = function(e, t) {
                var i = this;
                return this.select(function(e) {
                    return e.ids
                }).pipe(hr(e), Is(), La(function(e) {
                    return i.selectEntity(e, t)
                }))
            }, Ml),
            Cl = (ut(Dl, Al = kl), Dl);

        function Dl(e) {
            return Al.call(this, e) || this
        }

        function Ml(e, t) {
            void 0 === t && (t = {});
            var i = Ol.call(this, e) || this;
            return i.options = t, i.__store__ = e, i
        }

        function xl(e, t) {
            return 1 === t.split(".").length ? e : t.split(".").slice(1).join(".").split(".").reduce(function(e, t) {
                return e && e[t]
            }, e)
        }

        function Pl(e, t, r) {
            var i = t.split(".");
            if (1 === i.length) return ct({}, e, r);
            e = ct({}, e);
            var n = i.length - 2;
            return t.split(".").slice(1).reduce(function(e, t, i) {
                return e[t] = i !== n ? ct({}, e[t]) : Array.isArray(e[t]) || !No(e[t]) ? r : ct({}, e[t], r), e && e[t]
            }, e), e
        }
        new Ji(1);
        var Rl, Ll, _l, Nl, A = (Bl.prototype.getQuery = function() {
                return this.query
            }, Bl.prototype.getStore = function() {
                return this.getQuery().__store__
            }, Bl.prototype.isEntityBased = Jo, Bl.prototype.selectSource = function(e, t) {
                var i = this;
                return this.isEntityBased(e) ? this.getQuery().selectEntity(e).pipe(wl) : t ? this.getQuery().select(function(e) {
                    return xl(e, i.withStoreName(t))
                }) : this.getQuery().select()
            }, Bl.prototype.getSource = function(e, t) {
                if (this.isEntityBased(e)) return this.getQuery().getEntity(e);
                e = this.getQuery().getValue();
                return t ? xl(e, this.withStoreName(t)) : e
            }, Bl.prototype.withStoreName = function(e) {
                return this.storeName + "." + e
            }, Object.defineProperty(Bl.prototype, "storeName", {
                get: function() {
                    return this.getStore().storeName
                },
                enumerable: !0,
                configurable: !0
            }), Bl.prototype.updateStore = function(t, e, i) {
                var r = this;
                this.isEntityBased(e) ? this.getStore().update(e, t) : i ? this.getStore()._setState(function(e) {
                    return Pl(e, r.withStoreName(i), t)
                }) : this.getStore()._setState(function(e) {
                    return ct({}, e, t)
                })
            }, Bl.prototype.onReset = function(i) {
                var r = this,
                    n = this.getStore().reset;
                this.getStore().reset = function() {
                    for (var e = [], t = 0; t < arguments.length; t++) e[t] = arguments[t];
                    setTimeout(function() {
                        n.apply(r.getStore(), e), i()
                    })
                }
            }, Bl),
            Fl = {
                pagesControls: !1,
                range: !1,
                startWith: 1,
                cacheTimeout: void 0,
                clearStoreWithCache: !0
            };

        function Bl(e, t) {
            this.query = e
        }

        function Ul(e, t, i) {
            void 0 === i && (i = {});
            var r = Rl.call(this, e) || this;
            return r.query = e, r.factoryFnOrPath = t, r.params = i, r.params = ct({
                debounceTime: 300,
                formKey: "akitaForm",
                emitEvent: !1,
                arrControlFactory: function(e) {
                    return r.builder.control(e)
                }
            }, i), r.isRootKeys = !1 === Jo(t), r.isKeyBased = Tl(t) || r.isRootKeys, r
        }

        function $l(e, t) {
            void 0 === t && (t = {});
            var i = Ll.call(this, e, {
                resetFn: function() {
                    i.initial = !1, i.destroy({
                        clearCache: !0,
                        currentPage: 1
                    })
                }
            }) || this;
            i.query = e, i.config = t, i.metadata = new Map, i.pages = new Map, i.pagination = {
                currentPage: 1,
                perPage: 0,
                total: 0,
                lastPage: 0,
                data: []
            }, i.initial = !0, i.isLoading$ = i.query.selectLoading().pipe(function(t) {
                void 0 === t && (t = ir);
                var i = as(0) ? 0 - t.now() : Math.abs(0);
                return function(e) {
                    return e.lift(new ls(i, t))
                }
            }()), i.config = Object.assign(Fl, t);
            e = i.config, t = e.startWith, e = e.cacheTimeout;
            return i.page = new yi(t), e && (e instanceof $t || "function" == typeof e.lift && "function" == typeof e.subscribe) && (i.clearCacheSubscription = e.subscribe(function() {
                return i.clearCache()
            })), i
        }
        ut($l, Ll = A), Object.defineProperty($l.prototype, "pageChanges", {
            get: function() {
                return this.page.asObservable()
            },
            enumerable: !0,
            configurable: !0
        }), Object.defineProperty($l.prototype, "currentPage", {
            get: function() {
                return this.pagination.currentPage
            },
            enumerable: !0,
            configurable: !0
        }), Object.defineProperty($l.prototype, "isFirst", {
            get: function() {
                return 1 === this.currentPage
            },
            enumerable: !0,
            configurable: !0
        }), Object.defineProperty($l.prototype, "isLast", {
            get: function() {
                return this.currentPage === this.pagination.lastPage
            },
            enumerable: !0,
            configurable: !0
        }), $l.prototype.withControls = function() {
            return this.config.pagesControls = !0, this
        }, $l.prototype.withRange = function() {
            return this.config.range = !0, this
        }, $l.prototype.setLoading = function(e) {
            void 0 === e && (e = !0), this.getStore().setLoading(e)
        }, $l.prototype.update = function(e) {
            this.pagination = e, this.addPage(e.data)
        }, $l.prototype.addPage = function(e) {
            var t = this;
            this.pages.set(this.currentPage, {
                ids: e.map(function(e) {
                    return e[t.getStore().idKey]
                })
            }), this.getStore().upsertMany(e)
        }, $l.prototype.clearCache = function(e) {
            void 0 === e && (e = {}), this.initial || (Do("@Pagination - Clear Cache"), !1 !== e.clearStore && (this.config.clearStoreWithCache || e.clearStore) && this.getStore().remove(), this.pages = new Map, this.metadata = new Map), this.initial = !1
        }, $l.prototype.clearPage = function(e) {
            this.pages.delete(e)
        }, $l.prototype.destroy = function(e) {
            var t = void 0 === e ? {} : e,
                e = t.clearCache,
                t = t.currentPage;
            this.clearCacheSubscription && this.clearCacheSubscription.unsubscribe(), e && this.clearCache(), Vo(t) || this.setPage(t), this.initial = !0
        }, $l.prototype.isPageActive = function(e) {
            return this.currentPage === e
        }, $l.prototype.setPage = function(e) {
            e === this.currentPage && this.hasPage(e) || this.page.next(this.pagination.currentPage = e)
        }, $l.prototype.nextPage = function() {
            this.currentPage !== this.pagination.lastPage && this.setPage(this.pagination.currentPage + 1)
        }, $l.prototype.prevPage = function() {
            1 < this.pagination.currentPage && this.setPage(this.pagination.currentPage - 1)
        }, $l.prototype.setLastPage = function() {
            this.setPage(this.pagination.lastPage)
        }, $l.prototype.setFirstPage = function() {
            this.setPage(1)
        }, $l.prototype.hasPage = function(e) {
            return this.pages.has(e)
        }, $l.prototype.getPage = function(e) {
            var t = this,
                i = this.pagination.currentPage;
            return this.hasPage(i) ? this.selectPage(i) : (this.setLoading(!0), Fr(e()).pipe(La(function(e) {
                return i = e.currentPage, al(function() {
                    t.setLoading(!1), t.update(e)
                }), t.selectPage(i)
            })))
        }, $l.prototype.getQuery = function() {
            return this.query
        }, $l.prototype.refreshCurrentPage = function() {
            !1 === Po(this.currentPage) && (this.clearPage(this.currentPage), this.setPage(this.currentPage))
        }, $l.prototype.getFrom = function() {
            return this.isFirst ? 1 : (this.currentPage - 1) * this.pagination.perPage + 1
        }, $l.prototype.getTo = function() {
            return this.isLast ? this.pagination.total : this.currentPage * this.pagination.perPage
        }, $l.prototype.selectPage = function(n) {
            var s = this;
            return this.query.selectAll({
                asObject: !0
            }).pipe(Ds(1), hr(function(t) {
                var e = ct({}, s.pagination, {
                        data: s.pages.get(n).ids.map(function(e) {
                            return t[e]
                        })
                    }),
                    i = s.config,
                    r = i.range,
                    i = i.pagesControls;
                return isNaN(s.pagination.total) && (1 === e.lastPage ? e.total = e.data ? e.data.length : 0 : e.total = e.perPage * e.lastPage, s.pagination.total = e.total), r && (e.from = s.getFrom(), e.to = s.getTo()), i && (e.pageControls = function(e, t) {
                    for (var i = Math.ceil(e / t), r = [], n = 0; n < i; n++) r.push(n + 1);
                    return r
                }(s.pagination.total, s.pagination.perPage)), e
            }))
        }, ht([(_l = "@Pagination - New Page", function(e, t, i) {
            var r = i.value;
            return i.value = function() {
                for (var e = [], t = 0; t < arguments.length; t++) e[t] = arguments[t];
                return Do(_l, Nl), r.apply(this, e)
            }, i
        }), pt("design:type", Function), pt("design:paramtypes", [Object]), pt("design:returntype", void 0)], $l.prototype, "update", null), ut(Ul, Rl = A), Ul.prototype.setForm = function(e, t) {
            return this.form = e, this.builder = t, this.activate(), this
        }, Ul.prototype.reset = function(e) {
            var r = this,
                e = e || (this.isKeyBased ? this.initialValue : this.factoryFnOrPath());
            this.isKeyBased && Object.keys(this.initialValue).forEach(function(i) {
                var e, t = r.initialValue[i];
                Array.isArray(t) && r.builder && (e = r.form.controls[i], r.cleanArray(e), t.forEach(function(e, t) {
                    r.form.get(i).insert(t, r.params.arrControlFactory(e))
                }))
            }), this.form.patchValue(e, {
                emitEvent: this.params.emitEvent
            });
            var t = this.isKeyBased ? Pl(this.getQuery().getValue(), this.getStore().storeName + "." + this.factoryFnOrPath, e) : ((t = {})[this.params.formKey] = e, t);
            this.updateStore(t)
        }, Ul.prototype.cleanArray = function(e) {
            for (; 0 !== e.length;) e.removeAt(0)
        }, Ul.prototype.resolveInitialValue = function(e, n) {
            var s = this;
            if (e) return Object.keys(e).reduce(function(e, i) {
                var r, t = n[i];
                return Array.isArray(t) && s.builder && (r = s.params.arrControlFactory, s.cleanArray(s.form.get(i)), t.forEach(function(e, t) {
                    s.form.get(i).insert(t, r(e))
                })), e[i] = n[i], e
            }, {})
        }, Ul.prototype.activate = function() {
            var i, e, t, r = this;
            this.isKeyBased ? (this.isRootKeys ? this.initialValue = this.resolveInitialValue(this.form.value, this.getQuery().getValue()) : (i = this.getStore().storeName + "." + this.factoryFnOrPath, e = xl(this.getQuery().getValue(), i), this.initialValue = this.resolveInitialValue(e, e)), this.form.patchValue(this.initialValue, {
                emitEvent: this.params.emitEvent
            })) : (this.getQuery().getValue()[this.params.formKey] || (Do("@PersistNgFormPlugin activate"), this.updateStore(((t = {})[this.params.formKey] = this.factoryFnOrPath(), t))), t = this.getQuery().getValue()[this.params.formKey], this.form.patchValue(t)), this.formChanges = this.form.valueChanges.pipe(Gn(this.params.debounceTime)).subscribe(function(t) {
                var e;
                Do("@PersistForm - Update"), e = r.isKeyBased ? r.isRootKeys ? function(e) {
                    return ct({}, e, t)
                } : function(e) {
                    return Pl(e, i, t)
                } : function() {
                    var e;
                    return (e = {})[r.params.formKey] = t, e
                }, r.updateStore(e(r.getQuery().getValue()))
            })
        }, Ul.prototype.destroy = function() {
            this.formChanges && this.formChanges.unsubscribe(), this.form = null, this.builder = null
        };
        var Vl, Kl, Vr = (jl.prototype.getEntity = function(e) {
                return this.entities.get(e)
            }, jl.prototype.hasEntity = function(e) {
                return this.entities.has(e)
            }, jl.prototype.removeEntity = function(e) {
                return this.destroy(e), this.entities.delete(e)
            }, jl.prototype.createEntity = function(e, t) {
                return this.entities.set(e, t)
            }, jl.prototype.getIds = function() {
                return Vo(this.entityIds) ? this.query.getValue().ids : Ro(this.entityIds)
            }, jl.prototype.resolvedIds = function(e) {
                return Vo(e) ? this.getIds() : Ro(e)
            }, jl.prototype.rebase = function(i, r) {
                var n = this;
                if (void 0 === r && (r = {}), Jo(i))
                    if (Vo(this.entityIds)) {
                        for (var e = 0, t = i.length; e < t; e++) {
                            var s, a = i[e];
                            !1 === this.hasEntity(a) && ($o(r.beforeAdd) && r.beforeAdd(a), s = this.instantiatePlugin(a), this.entities.set(a, s), $o(r.afterAdd) && r.afterAdd(s))
                        }
                        this.entities.forEach(function(e, t) {
                            -1 === i.indexOf(t) && ($o(r.beforeRemove) && r.beforeRemove(e), n.removeEntity(t))
                        })
                    } else
                        for (var o = Ro(this.entityIds), e = 0, t = o.length; e < t; e++) a = o[e], -1 < i.indexOf(a) && !1 === this.hasEntity(a) ? ($o(r.beforeAdd) && r.beforeAdd(a), s = this.instantiatePlugin(a), this.entities.set(a, s), $o(r.afterAdd) && r.afterAdd(s)) : this.entities.forEach(function(e, t) {
                            -1 === i.indexOf(t) && !0 === n.hasEntity(t) && ($o(r.beforeRemove) && r.beforeRemove(e), n.removeEntity(t))
                        });
                else this.getIds().forEach(function(e) {
                    n.hasEntity(e) || n.createEntity(e, n.instantiatePlugin(e))
                })
            }, jl.prototype.selectIds = function() {
                return this.query.select(function(e) {
                    return e.ids
                })
            }, jl.prototype.activate = function(e) {
                this.rebase(e)
            }, jl.prototype.forEachId = function(e, t) {
                for (var i = this.resolvedIds(e), r = 0, n = i.length; r < n; r++) {
                    var s = i[r];
                    this.hasEntity(s) && t(this.getEntity(s))
                }
            }, jl),
            ql = (ut(Hl, Vl = A), Object.defineProperty(Hl.prototype, "hasPast$", {
                get: function() {
                    return this._hasPast$
                },
                enumerable: !0,
                configurable: !0
            }), Object.defineProperty(Hl.prototype, "hasFuture$", {
                get: function() {
                    return this._hasFuture$
                },
                enumerable: !0,
                configurable: !0
            }), Object.defineProperty(Hl.prototype, "hasPast", {
                get: function() {
                    return 0 < this.history.past.length
                },
                enumerable: !0,
                configurable: !0
            }), Object.defineProperty(Hl.prototype, "hasFuture", {
                get: function() {
                    return 0 < this.history.future.length
                },
                enumerable: !0,
                configurable: !0
            }), Object.defineProperty(Hl.prototype, "property", {
                get: function() {
                    return this.params.watchProperty
                },
                enumerable: !0,
                configurable: !0
            }), Hl.prototype.updateHasHistory = function() {
                this.hasFutureSubject.next(this.hasFuture), this.hasPastSubject.next(this.hasPast)
            }, Hl.prototype.activate = function() {
                var r = this;
                this.hasPastSubject = new yi(!1), this._hasPast$ = this.hasPastSubject.asObservable().pipe(Is()), this.hasFutureSubject = new yi(!1), this._hasFuture$ = this.hasFutureSubject.asObservable().pipe(Is()), this.history.present = this.getSource(this._entityId, this.property), this.subscription = this.selectSource(this._entityId, this.property).pipe(ha()).subscribe(function(e) {
                    var t = mt(e, 2),
                        i = t[0],
                        e = t[1];
                    r.skip ? r.skip = !1 : (t = r.params.comparator(i, e), !r.skipUpdate && t && (r.history.past.length === r.params.maxAge && (r.history.past = r.history.past.slice(1)), r.history.past = gt(r.history.past, [i]), r.history.present = e, r.updateHasHistory()))
                })
            }, Hl.prototype.undo = function() {
                var e, t, i;
                0 < this.history.past.length && (e = (i = this.history).past, t = i.present, i = e[e.length - 1], this.history.past = e.slice(0, e.length - 1), this.history.present = i, this.history.future = gt([t], this.history.future), this.update())
            }, Hl.prototype.redo = function() {
                var e, t, i, r;
                0 < this.history.future.length && (e = (r = this.history).past, t = r.present, i = this.history.future[0], r = this.history.future.slice(1), this.history.past = gt(e, [t]), this.history.present = i, this.history.future = r, this.update("Redo"))
            }, Hl.prototype.jumpToPast = function(e) {
                var t, i, r, n;
                e < 0 || e >= this.history.past.length || (t = (r = this.history).past, n = r.future, i = r.present, r = t.slice(0, e), n = gt(t.slice(e + 1), [i], n), e = t[e], this.history.past = r, this.history.present = e, this.history.future = n, this.update())
            }, Hl.prototype.jumpToFuture = function(e) {
                var t, i, r;
                e < 0 || e >= this.history.future.length || (i = (r = this.history).past, t = r.future, i = gt(i, [r.present], t.slice(0, e)), r = t[e], e = t.slice(e + 1), this.history.past = i, this.history.present = r, this.history.future = e, this.update("Redo"))
            }, Hl.prototype.jump = function(e) {
                return 0 < e ? this.jumpToFuture(e - 1) : e < 0 ? this.jumpToPast(this.history.past.length + e) : void 0
            }, Hl.prototype.clear = function(e) {
                this.history = $o(e) ? e(this.history) : {
                    past: [],
                    present: null,
                    future: []
                }, this.updateHasHistory()
            }, Hl.prototype.destroy = function(e) {
                (e = void 0 === e ? !1 : e) && this.clear(), this.subscription.unsubscribe()
            }, Hl.prototype.ignoreNext = function() {
                this.skip = !0
            }, Hl.prototype.update = function(e) {
                void 0 === e && (e = "Undo"), this.skipUpdate = !0, Do("@StateHistory - " + e), this.updateStore(this.history.present, this._entityId, this.property), this.updateHasHistory(), this.skipUpdate = !1
            }, Hl);

        function Hl(e, t, i) {
            void 0 === t && (t = {});
            var r = Vl.call(this, e, {
                resetFn: function() {
                    return r.clear()
                }
            }) || this;
            return r.query = e, r.params = t, r._entityId = i, r.skip = !1, r.history = {
                past: [],
                present: null,
                future: []
            }, r.skipUpdate = !1, t.maxAge = t.maxAge || 10, t.comparator = t.comparator || function() {
                return !0
            }, r.activate(), r
        }

        function jl(e, t) {
            this.query = e, this.entityIds = t, this.entities = new Map
        }

        function Ql(e, t) {
            var i = Kl.call(this, e, (t = void 0 === t ? {} : t).entityIds) || this;
            return i.query = e, (i.params = t).maxAge = Jo(t.maxAge) ? t.maxAge : 10, i.activate(), i.selectIds().pipe(ka(1)).subscribe(function(e) {
                return i.activate(e)
            }), i
        }
        ut(Ql, Kl = Vr), Ql.prototype.redo = function(e) {
            this.forEachId(e, function(e) {
                return e.redo()
            })
        }, Ql.prototype.undo = function(e) {
            this.forEachId(e, function(e) {
                return e.undo()
            })
        }, Ql.prototype.hasPast = function(e) {
            if (this.hasEntity(e)) return this.getEntity(e).hasPast
        }, Ql.prototype.hasFuture = function(e) {
            if (this.hasEntity(e)) return this.getEntity(e).hasFuture
        }, Ql.prototype.jumpToFuture = function(e, t) {
            this.forEachId(e, function(e) {
                return e.jumpToFuture(t)
            })
        }, Ql.prototype.jumpToPast = function(e, t) {
            this.forEachId(e, function(e) {
                return e.jumpToPast(t)
            })
        }, Ql.prototype.clear = function(e) {
            this.forEachId(e, function(e) {
                return e.clear()
            })
        }, Ql.prototype.destroy = function(e, t) {
            void 0 === t && (t = !1), this.forEachId(e, function(e) {
                return e.destroy(t)
            })
        }, Ql.prototype.ignoreNext = function(e) {
            this.forEachId(e, function(e) {
                return e.ignoreNext()
            })
        }, Ql.prototype.instantiatePlugin = function(e) {
            return new ql(this.query, this.params, e)
        };
        var Wl = {
            comparator: function(e, t) {
                return JSON.stringify(e) !== JSON.stringify(t)
            }
        };

        function Gl(e, t) {
            return t.split(".").reduce(function(e, t) {
                return e && "undefined" !== e[t] ? e[t] : void 0
            }, e)
        }
        var zl, Xl, Yl = (ut(Jl, zl = A), Jl.prototype.reset = function(e) {
            var t = this.head;
            $o((e = void 0 === e ? {} : e).updateFn) && (t = this.isEntityBased(this._entityId) ? e.updateFn(this.head, this.getQuery().getEntity(this._entityId)) : e.updateFn(this.head, this.getQuery().getValue())), Do("@DirtyCheck - Revert"), this.updateStore(t, this._entityId), this._reset.next()
        }, Jl.prototype.setHead = function() {
            return this.active ? this.head = this._getHead() : (this.activate(), this.active = !0), this.updateDirtiness(!1), this
        }, Jl.prototype.isDirty = function() {
            return !!this.dirty.value
        }, Jl.prototype.hasHead = function() {
            return !!this.getHead()
        }, Jl.prototype.destroy = function() {
            this.head = null, this.subscription && this.subscription.unsubscribe(), this._reset && this._reset.complete()
        }, Jl.prototype.isPathDirty = function(e) {
            var t = this.getHead(),
                i = Gl(this.getQuery().getValue(), e),
                e = Gl(t, e);
            return this.params.comparator(i, e)
        }, Jl.prototype.getHead = function() {
            return this.head
        }, Jl.prototype.activate = function() {
            var i = this;
            this.head = this._getHead();
            var e = this.params.watchProperty ? this.params.watchProperty.map(function(t) {
                return i.query.select(function(e) {
                    return e[t]
                }).pipe(hr(function(e) {
                    return {
                        val: e,
                        __akitaKey: t
                    }
                }))
            }) : [this.selectSource(this._entityId)];
            this.subscription = Mr.apply(void 0, gt(e)).pipe(ka(1)).subscribe(function(e) {
                Vo(i.head) || (e = e.some(function(e) {
                    var t = e.__akitaKey ? i.head[e.__akitaKey] : i.head,
                        e = e.__akitaKey ? e.val : e;
                    return i.params.comparator(t, e)
                }), i.updateDirtiness(e))
            })
        }, Jl.prototype.updateDirtiness = function(e) {
            this.dirty.next(e)
        }, Jl.prototype._getHead = function() {
            var e = this.getSource(this._entityId);
            return e = this.params.watchProperty ? this.getWatchedValues(e) : e
        }, Jl.prototype.getWatchedValues = function(i) {
            return this.params.watchProperty.reduce(function(e, t) {
                return e[t] = i[t], e
            }, {})
        }, Jl);

        function Jl(e, t, i) {
            var r = zl.call(this, e) || this;
            return r.query = e, r.params = t, r._entityId = i, r.dirty = new yi(!1), r.active = !1, r._reset = new Xt, r.isDirty$ = r.dirty.asObservable().pipe(Is()), r.reset$ = r._reset.asObservable(), r.params = ct({}, Wl, t), r.params.watchProperty && (t = Ro(r.params.watchProperty), e instanceof kl && t.includes("entities") && !t.includes("ids") && t.push("ids"), r.params.watchProperty = t), r
        }

        function Zl() {
            return Math.random().toString(36).slice(2)
        }

        function ed(e) {
            return Mr(e).pipe($n(0))
        }

        function td(e, t) {
            var i = Xl.call(this, e, (t = void 0 === t ? {} : t).entityIds) || this;
            return i.query = e, i.params = t, i._someDirty = new Xt, i.someDirty$ = an(i.query.select(function(e) {
                return e.entities
            }), i._someDirty.asObservable()).pipe($n(0), hr(function() {
                return i.checkSomeDirty()
            })), i.params = ct({}, Wl, t), i.activate(), i.selectIds().pipe(ka(1)).subscribe(function(e) {
                Xl.prototype.rebase.call(i, e, {
                    afterAdd: function(e) {
                        return e.setHead()
                    }
                })
            }), i
        }
        ut(td, Xl = Vr), td.prototype.setHead = function(e) {
            if (this.params.entityIds && e) {
                var t = Ro(e);
                if (!1 === Ro(this.params.entityIds).some(function(e) {
                        return -1 < t.indexOf(e)
                    })) return this
            }
            return this.forEachId(e, function(e) {
                return e.setHead()
            }), this._someDirty.next(), this
        }, td.prototype.hasHead = function(e) {
            return !!this.entities.has(e) && this.getEntity(e).hasHead()
        }, td.prototype.reset = function(e, t) {
            void 0 === t && (t = {}), this.forEachId(e, function(e) {
                return e.reset(t)
            })
        }, td.prototype.isDirty = function(e, t) {
            if (void 0 === t && (t = !0), this.entities.has(e)) {
                e = this.getEntity(e);
                return t ? e.isDirty$ : e.isDirty()
            }
            return !1
        }, td.prototype.someDirty = function() {
            return this.checkSomeDirty()
        }, td.prototype.isPathDirty = function(e, t) {
            if (this.entities.has(e)) {
                var i = this.getEntity(e).getHead(),
                    e = Gl(this.query.getEntity(e), t),
                    t = Gl(i, t);
                return this.params.comparator(e, t)
            }
            return null
        }, td.prototype.destroy = function(e) {
            this.forEachId(e, function(e) {
                return e.destroy()
            }), e || this._someDirty.complete()
        }, td.prototype.instantiatePlugin = function(e) {
            return new Yl(this.query, this.params, e)
        }, td.prototype.checkSomeDirty = function() {
            var e, t, i = this.resolvedIds();
            try {
                for (var r = ft(i), n = r.next(); !n.done; n = r.next()) {
                    var s = n.value;
                    if (this.getEntity(s).isDirty()) return !0
                }
            } catch (t) {
                e = {
                    error: t
                }
            } finally {
                try {
                    n && !n.done && (t = r.return) && t.call(r)
                } finally {
                    if (e) throw e.error
                }
            }
            return !1
        }, (tu = tu || {}).Update = "UPDATE", {} [tu.Update] = "update", (vr = ru = ru || {}).Update = "UPDATE", vr.AddEntities = "ADD_ENTITIES", vr.SetEntities = "SET_ENTITIES", vr.UpdateEntities = "UPDATE_ENTITIES", vr.RemoveEntities = "REMOVE_ENTITIES", vr.UpsertEntities = "UPSERT_ENTITIES", vr.UpsertManyEntities = "UPSERT_MANY_ENTITIES", (iu = {})[ru.Update] = "update", iu[ru.AddEntities] = "add", iu[ru.SetEntities] = "set", iu[ru.UpdateEntities] = "update", iu[ru.RemoveEntities] = "remove", iu[ru.UpsertEntities] = "upsert", iu[ru.UpsertManyEntities] = "upsertMany";
        w = {};
        Object.defineProperty(w, "__esModule", {
            value: !0
        });
        var vi = "undefined" != typeof Symbol && "symbol" == typeof Symbol("x"),
            id = "undefined" != typeof Map,
            rd = "undefined" != typeof Set,
            nd = "undefined" != typeof Proxy && void 0 !== Proxy.revocable && "undefined" != typeof Reflect,
            sd = vi ? Symbol.for("immer-nothing") : ((nu = {})["immer-nothing"] = !0, nu),
            ad = vi ? Symbol.for("immer-draftable") : "__$immer_draftable",
            od = vi ? Symbol.for("immer-state") : "__$immer_state",
            ld = "undefined" != typeof Symbol && Symbol.iterator || "@@iterator",
            dd = {
                0: "Illegal state",
                1: "Immer drafts cannot have computed properties",
                2: "This object has been frozen and should not be mutated",
                3: function(e) {
                    return "Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? " + e
                },
                4: "An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.",
                5: "Immer forbids circular references",
                6: "The first or second argument to `produce` must be a function",
                7: "The third argument to `produce` must be a function or undefined",
                8: "First argument to `createDraft` must be a plain object, an array, or an immerable object",
                9: "First argument to `finishDraft` must be a draft returned by `createDraft`",
                10: "The given draft is already finalized",
                11: "Object.defineProperty() cannot be used on an Immer draft",
                12: "Object.setPrototypeOf() cannot be used on an Immer draft",
                13: "Immer only supports deleting array indices",
                14: "Immer only supports setting array indices and the 'length' property",
                15: function(e) {
                    return "Cannot apply patch, path doesn't resolve: " + e
                },
                16: 'Sets cannot have "replace" patches.',
                17: function(e) {
                    return "Unsupported patch operation: " + e
                },
                18: function(e) {
                    return "The plugin for '" + e + "' has not been loaded into Immer. To enable the plugin, import and call `enable" + e + "()` when initializing your application."
                },
                20: "Cannot use proxies if Proxy, Proxy.revocable or Reflect are not available",
                21: function(e) {
                    return "produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '" + e + "'"
                },
                22: function(e) {
                    return "'current' expects a draft, got: " + e
                },
                23: function(e) {
                    return "'original' expects a draft, got: " + e
                }
            };

        function ud(e) {
            for (var t = arguments.length, i = new Array(1 < t ? t - 1 : 0), r = 1; r < t; r++) i[r - 1] = arguments[r];
            var n = dd[e],
                e = n ? "function" == typeof n ? n.apply(null, i) : n : "unknown error nr: " + e;
            throw new Error("[Immer] " + e)
        }

        function cd(e) {
            return !!e && !!e[od]
        }

        function hd(t) {
            return !!t && (function() {
                if (!t || "object" != typeof t) return !1;
                var e = Object.getPrototypeOf(t);
                return !e || e === Object.prototype
            }() || Array.isArray(t) || !!t[ad] || !!t.constructor[ad] || Td(t) || Ed(t))
        }
        var pd = "undefined" != typeof Reflect && Reflect.ownKeys ? Reflect.ownKeys : void 0 !== Object.getOwnPropertySymbols ? function(e) {
                return Object.getOwnPropertyNames(e).concat(Object.getOwnPropertySymbols(e))
            } : Object.getOwnPropertyNames,
            fd = Object.getOwnPropertyDescriptors || function(t) {
                var i = {};
                return pd(t).forEach(function(e) {
                    i[e] = Object.getOwnPropertyDescriptor(t, e)
                }), i
            };

        function md(i, r, t) {
            void 0 === t && (t = !1), 0 === gd(i) ? (t ? Object.keys : pd)(i).forEach(function(e) {
                t && "symbol" == typeof e || r(e, i[e], i)
            }) : i.forEach(function(e, t) {
                return r(t, e, i)
            })
        }

        function gd(e) {
            var t = e[od];
            return t ? 3 < t.type_ ? t.type_ - 4 : t.type_ : Array.isArray(e) ? 1 : Td(e) ? 2 : Ed(e) ? 3 : 0
        }

        function yd(e, t) {
            return 2 === gd(e) ? e.has(t) : Object.prototype.hasOwnProperty.call(e, t)
        }

        function vd(e, t) {
            return 2 === gd(e) ? e.get(t) : e[t]
        }

        function Sd(e, t, i) {
            var r = gd(e);
            2 === r ? e.set(t, i) : 3 === r ? (e.delete(t), e.add(i)) : e[t] = i
        }

        function bd(e, t) {
            return e === t ? 0 !== e || 1 / e == 1 / t : e != e && t != t
        }

        function Td(e) {
            return id && e instanceof Map
        }

        function Ed(e) {
            return rd && e instanceof Set
        }

        function Id(e) {
            return e.copy_ || e.base_
        }

        function wd(e) {
            if (Array.isArray(e)) return Array.prototype.slice.call(e);
            var t = fd(e);
            delete t[od];
            for (var i = pd(t), r = 0; r < i.length; r++) {
                var n = i[r],
                    s = t[n];
                !1 === s.writable && (s.writable = !0, s.configurable = !0), (s.get || s.set) && (t[n] = {
                    configurable: !0,
                    writable: !0,
                    enumerable: s.enumerable,
                    value: e[n]
                })
            }
            return Object.create(Object.getPrototypeOf(e), t)
        }

        function Ad(e, t) {
            kd(e) || cd(e) || !hd(e) || (1 < gd(e) && (e.set = e.add = e.clear = e.delete = Od), Object.freeze(e), t && md(e, function(e, t) {
                return Ad(t, !0)
            }, !0))
        }

        function Od() {
            ud(2)
        }

        function kd(e) {
            return null == e || "object" != typeof e || Object.isFrozen(e)
        }
        var Cd, Dd = {};

        function Md(e) {
            var t = Dd[e];
            return t || ud(18, e), t
        }

        function xd(e, t) {
            Dd[e] || (Dd[e] = t)
        }

        function Pd() {
            return Cd || ud(0), Cd
        }

        function Rd(e, t) {
            t && (Md("Patches"), e.patches_ = [], e.inversePatches_ = [], e.patchListener_ = t)
        }

        function Ld(e) {
            _d(e), e.drafts_.forEach(Fd), e.drafts_ = null
        }

        function _d(e) {
            e === Cd && (Cd = e.parent_)
        }

        function Nd(e) {
            return Cd = {
                drafts_: [],
                parent_: Cd,
                immer_: e,
                canAutoFreeze_: !0,
                unfinalizedDrafts_: 0
            }
        }

        function Fd(e) {
            e = e[od];
            0 === e.type_ || 1 === e.type_ ? e.revoke_() : e.revoked_ = !0
        }

        function Bd(e, t) {
            t.unfinalizedDrafts_ = t.drafts_.length;
            var i = t.drafts_[0],
                r = void 0 !== e && e !== i;
            return t.immer_.useProxies_ || Md("ES5").willFinalizeES5_(t, e, r), r ? (i[od].modified_ && (Ld(t), ud(4)), hd(e) && (e = Ud(t, e), t.parent_ || Vd(t, e)), t.patches_ && Md("Patches").generateReplacementPatches_(i[od], e, t.patches_, t.inversePatches_)) : e = Ud(t, i, []), Ld(t), t.patches_ && t.patchListener_(t.patches_, t.inversePatches_), e !== sd ? e : void 0
        }

        function Ud(i, r, n) {
            if (kd(r)) return r;
            var s, a = r[od];
            return a ? a.scope_ !== i ? r : a.modified_ ? (a.finalized_ || (a.finalized_ = !0, a.scope_.unfinalizedDrafts_--, s = 4 === a.type_ || 5 === a.type_ ? a.copy_ = wd(a.draft_) : a.copy_, md(3 === a.type_ ? new Set(s) : s, function(e, t) {
                return $d(i, a, s, e, t, n)
            }), Vd(i, s, !1), n && i.patches_ && Md("Patches").generatePatches_(a, n, i.patches_, i.inversePatches_)), a.copy_) : (Vd(i, a.base_, !0), a.base_) : (md(r, function(e, t) {
                return $d(i, a, r, e, t, n)
            }, !0), r)
        }

        function $d(e, t, i, r, n, s) {
            if (n === i && ud(5), cd(n)) {
                s = Ud(e, n, s && t && 3 !== t.type_ && !yd(t.assigned_, r) ? s.concat(r) : void 0);
                if (Sd(i, r, s), !cd(s)) return;
                e.canAutoFreeze_ = !1
            }
            hd(n) && !kd(n) && (!e.immer_.autoFreeze_ && e.unfinalizedDrafts_ < 1 || (Ud(e, n), t && t.scope_.parent_ || Vd(e, n)))
        }

        function Vd(e, t, i) {
            void 0 === i && (i = !1), e.immer_.autoFreeze_ && e.canAutoFreeze_ && Ad(t, i)
        }
        var Kd = {
                get: function(e, t) {
                    if (t === od) return e;
                    var i, r, n = Id(e);
                    if (!yd(n, t)) return i = e, (r = jd(n, t)) ? "value" in r ? r.value : null === (r = r.get) || void 0 === r ? void 0 : r.call(i.draft_) : void 0;
                    n = n[t];
                    return !e.finalized_ && hd(n) && n === Hd(e.base_, t) ? (Wd(e), e.copy_[t] = zd(e.scope_.immer_, n, e)) : n
                },
                has: function(e, t) {
                    return t in Id(e)
                },
                ownKeys: function(e) {
                    return Reflect.ownKeys(Id(e))
                },
                set: function(e, t, i) {
                    var r = jd(Id(e), t);
                    if (null != r && r.set) return r.set.call(e.draft_, i), !0;
                    if (!e.modified_) {
                        var n = Hd(Id(e), t),
                            r = null == n ? void 0 : n[od];
                        if (r && r.base_ === i) return e.copy_[t] = i, !(e.assigned_[t] = !1);
                        if (bd(i, n) && (void 0 !== i || yd(e.base_, t))) return !0;
                        Wd(e), Qd(e)
                    }
                    return e.copy_[t] = i, e.assigned_[t] = !0
                },
                deleteProperty: function(e, t) {
                    return void 0 !== Hd(e.base_, t) || t in e.base_ ? (e.assigned_[t] = !1, Wd(e), Qd(e)) : delete e.assigned_[t], e.copy_ && delete e.copy_[t], !0
                },
                getOwnPropertyDescriptor: function(e, t) {
                    var i = Id(e),
                        r = Reflect.getOwnPropertyDescriptor(i, t);
                    return r && {
                        writable: !0,
                        configurable: 1 !== e.type_ || "length" !== t,
                        enumerable: r.enumerable,
                        value: i[t]
                    }
                },
                defineProperty: function() {
                    ud(11)
                },
                getPrototypeOf: function(e) {
                    return Object.getPrototypeOf(e.base_)
                },
                setPrototypeOf: function() {
                    ud(12)
                }
            },
            qd = {};

        function Hd(e, t) {
            var i = e[od];
            return (i ? Id(i) : e)[t]
        }

        function jd(e, t) {
            if (t in e)
                for (var i = Object.getPrototypeOf(e); i;) {
                    var r = Object.getOwnPropertyDescriptor(i, t);
                    if (r) return r;
                    i = Object.getPrototypeOf(i)
                }
        }

        function Qd(e) {
            e.modified_ || (e.modified_ = !0, e.parent_ && Qd(e.parent_))
        }

        function Wd(e) {
            e.copy_ || (e.copy_ = wd(e.base_))
        }
        md(Kd, function(e, t) {
            qd[e] = function() {
                return arguments[0] = arguments[0][0], t.apply(this, arguments)
            }
        }), qd.deleteProperty = function(e, t) {
            return isNaN(parseInt(t)) && ud(13), Kd.deleteProperty.call(this, e[0], t)
        }, qd.set = function(e, t, i) {
            return "length" !== t && isNaN(parseInt(t)) && ud(14), Kd.set.call(this, e[0], t, i, e[0])
        };
        (A = Gd.prototype).produce = function(e, s, t) {
            if ("function" == typeof e && "function" != typeof s) {
                var a = s;
                s = e;
                var o = this;
                return function(e) {
                    var t = this;
                    void 0 === e && (e = a);
                    for (var i = arguments.length, r = new Array(1 < i ? i - 1 : 0), n = 1; n < i; n++) r[n - 1] = arguments[n];
                    return o.produce(e, function(e) {
                        return s.call.apply(s, [t, e].concat(r))
                    })
                }
            }
            var i;
            if ("function" != typeof s && ud(6), void 0 !== t && "function" != typeof t && ud(7), hd(e)) {
                var r = Nd(this),
                    n = zd(this, e, void 0),
                    l = !0;
                try {
                    i = s(n), l = !1
                } finally {
                    (l ? Ld : _d)(r)
                }
                return "undefined" != typeof Promise && i instanceof Promise ? i.then(function(e) {
                    return Rd(r, t), Bd(e, r)
                }, function(e) {
                    throw Ld(r), e
                }) : (Rd(r, t), Bd(i, r))
            }
            if (!e || "object" != typeof e) return (i = s(e)) === sd ? void 0 : (void 0 === i && (i = e), this.autoFreeze_ && Ad(i, !0), i);
            ud(21, e)
        }, A.produceWithPatches = function(n, e, t) {
            var i, r, s = this;
            return "function" == typeof n ? function(e) {
                for (var t = arguments.length, i = new Array(1 < t ? t - 1 : 0), r = 1; r < t; r++) i[r - 1] = arguments[r];
                return s.produceWithPatches(e, function(e) {
                    return n.apply(void 0, [e].concat(i))
                })
            } : [this.produce(n, e, function(e, t) {
                i = e, r = t
            }), i, r]
        }, A.createDraft = function(e) {
            hd(e) || ud(8), cd(e) && (e = Xd(e));
            var t = Nd(this),
                e = zd(this, e, void 0);
            return e[od].isManual_ = !0, _d(t), e
        }, A.finishDraft = function(e, t) {
            e = e && e[od];
            e && e.isManual_ || ud(9), e.finalized_ && ud(10);
            e = e.scope_;
            return Rd(e, t), Bd(void 0, e)
        }, A.setAutoFreeze = function(e) {
            this.autoFreeze_ = e
        }, A.setUseProxies = function(e) {
            e && !nd && ud(20), this.useProxies_ = e
        }, A.applyPatches = function(e, t) {
            for (var i = t.length - 1; 0 <= i; i--) {
                var r = t[i];
                if (0 === r.path.length && "replace" === r.op) {
                    e = r.value;
                    break
                }
            }
            var n = Md("Patches").applyPatches_;
            return cd(e) ? n(e, t) : this.produce(e, function(e) {
                return n(e, t.slice(i + 1))
            })
        }, Vr = Gd;

        function Gd(e) {
            this.useProxies_ = nd, this.autoFreeze_ = !0, "boolean" == typeof(null == e ? void 0 : e.useProxies) && this.setUseProxies(e.useProxies), "boolean" == typeof(null == e ? void 0 : e.autoFreeze) && this.setAutoFreeze(e.autoFreeze), this.produce = this.produce.bind(this), this.produceWithPatches = this.produceWithPatches.bind(this)
        }

        function zd(e, t, i) {
            t = Td(t) ? Md("MapSet").proxyMap_(t, i) : Ed(t) ? Md("MapSet").proxySet_(t, i) : e.useProxies_ ? function(e, t) {
                var i = Array.isArray(e),
                    r = {
                        type_: i ? 1 : 0,
                        scope_: t ? t.scope_ : Pd(),
                        modified_: !1,
                        finalized_: !1,
                        assigned_: {},
                        parent_: t,
                        base_: e,
                        draft_: null,
                        copy_: null,
                        revoke_: null,
                        isManual_: !1
                    },
                    t = r,
                    e = Kd;
                i && (t = [r], e = qd);
                t = Proxy.revocable(t, e), e = t.revoke, t = t.proxy;
                return r.draft_ = t, r.revoke_ = e, t
            }(t, i) : Md("ES5").createES5Proxy_(t, i);
            return (i ? i.scope_ : Pd()).drafts_.push(t), t
        }

        function Xd(e) {
            return cd(e) || ud(22, e),
                function i(e) {
                    if (!hd(e)) return e;
                    var r, n = e[od],
                        t = gd(e);
                    if (n) {
                        if (!n.modified_ && (n.type_ < 4 || !Md("ES5").hasChanges_(n))) return n.base_;
                        n.finalized_ = !0, r = Yd(e, t), n.finalized_ = !1
                    } else r = Yd(e, t);
                    return md(r, function(e, t) {
                        n && vd(n.base_, e) === t || Sd(r, e, i(t))
                    }), 3 === t ? new Set(r) : r
                }(e)
        }

        function Yd(e, t) {
            switch (t) {
                case 2:
                    return new Map(e);
                case 3:
                    return Array.from(e)
            }
            return wd(e)
        }

        function Jd() {
            var r = {};

            function l(i, e) {
                var t = r[i];
                return t ? t.enumerable = e : r[i] = t = {
                    configurable: !0,
                    enumerable: e,
                    get: function() {
                        var e = this[od];
                        return a(e), Kd.get(e, i)
                    },
                    set: function(e) {
                        var t = this[od];
                        a(t), Kd.set(t, i, e)
                    }
                }, t
            }

            function n(e) {
                for (var t = e.length - 1; 0 <= t; t--) {
                    var i = e[t][od];
                    if (!i.modified_) switch (i.type_) {
                        case 5:
                            u(i) && Qd(i);
                            break;
                        case 4:
                            s(i) && Qd(i)
                    }
                }
            }

            function s(e) {
                for (var t = e.base_, i = e.draft_, r = pd(i), n = r.length - 1; 0 <= n; n--) {
                    var s = r[n];
                    if (s !== od) {
                        var a = t[s];
                        if (void 0 === a && !yd(t, s)) return !0;
                        var o = i[s],
                            s = o && o[od];
                        if (s ? s.base_ !== a : !bd(o, a)) return !0
                    }
                }
                e = !!t[od];
                return r.length !== pd(t).length + (e ? 0 : 1)
            }

            function u(e) {
                var t = e.draft_;
                if (t.length !== e.base_.length) return !0;
                t = Object.getOwnPropertyDescriptor(t, t.length - 1);
                return !(!t || t.get)
            }

            function a(e) {
                e.revoked_ && ud(3, JSON.stringify(Id(e)))
            }
            xd("ES5", {
                createES5Proxy_: function(e, t) {
                    var i = Array.isArray(e),
                        r = function(e, t) {
                            if (e) {
                                for (var i = new Array(t.length), r = 0; r < t.length; r++) Object.defineProperty(i, "" + r, l(r, !0));
                                return i
                            }
                            var n = fd(t);
                            delete n[od];
                            for (var s = pd(n), a = 0; a < s.length; a++) {
                                var o = s[a];
                                n[o] = l(o, e || !!n[o].enumerable)
                            }
                            return Object.create(Object.getPrototypeOf(t), n)
                        }(i, e),
                        e = {
                            type_: i ? 5 : 4,
                            scope_: t ? t.scope_ : Pd(),
                            modified_: !1,
                            finalized_: !1,
                            assigned_: {},
                            parent_: t,
                            base_: e,
                            draft_: r,
                            copy_: null,
                            revoked_: !1,
                            isManual_: !1
                        };
                    return Object.defineProperty(r, od, {
                        value: e,
                        writable: !0
                    }), r
                },
                willFinalizeES5_: function(e, t, i) {
                    i ? cd(t) && t[od].scope_ === e && n(e.drafts_) : (e.patches_ && function t(e) {
                        if (e && "object" == typeof e) {
                            var i = e[od];
                            if (i) {
                                var r = i.base_,
                                    n = i.draft_,
                                    s = i.assigned_;
                                if (4 === (e = i.type_)) md(n, function(e) {
                                    e !== od && (void 0 !== r[e] || yd(r, e) ? s[e] || t(n[e]) : (s[e] = !0, Qd(i)))
                                }), md(r, function(e) {
                                    void 0 !== n[e] || yd(n, e) || (s[e] = !1, Qd(i))
                                });
                                else if (5 === e) {
                                    if (u(i) && (Qd(i), s.length = !0), n.length < r.length)
                                        for (var a = n.length; a < r.length; a++) s[a] = !1;
                                    else
                                        for (var o = r.length; o < n.length; o++) s[o] = !0;
                                    for (var l = Math.min(n.length, r.length), d = 0; d < l; d++) void 0 === s[d] && t(n[d])
                                }
                            }
                        }
                    }(e.drafts_[0]), n(e.drafts_))
                },
                hasChanges_: function(e) {
                    return (4 === e.type_ ? s : u)(e)
                }
            })
        }

        function Zd() {
            var m = "replace",
                g = "add",
                y = "remove";

            function d(e) {
                if (!hd(e)) return e;
                if (Array.isArray(e)) return e.map(d);
                if (Td(e)) return new Map(Array.from(e.entries()).map(function(e) {
                    return [e[0], d(e[1])]
                }));
                if (Ed(e)) return new Set(Array.from(e).map(d));
                var t, i = Object.create(Object.getPrototypeOf(e));
                for (t in e) i[t] = d(e[t]);
                return i
            }

            function v(e) {
                return cd(e) ? d(e) : e
            }
            xd("Patches", {
                applyPatches_: function(l, e) {
                    return e.forEach(function(e) {
                        for (var t = e.path, i = e.op, r = l, n = 0; n < t.length - 1; n++) "object" != typeof(r = vd(r, t[n])) && ud(15, t.join("/"));
                        var s = gd(r),
                            a = d(e.value),
                            o = t[t.length - 1];
                        switch (i) {
                            case m:
                                switch (s) {
                                    case 2:
                                        return r.set(o, a);
                                    case 3:
                                        ud(16);
                                    default:
                                        return r[o] = a
                                }
                            case g:
                                switch (s) {
                                    case 1:
                                        return r.splice(o, 0, a);
                                    case 2:
                                        return r.set(o, a);
                                    case 3:
                                        return r.add(a);
                                    default:
                                        return r[o] = a
                                }
                            case y:
                                switch (s) {
                                    case 1:
                                        return r.splice(o, 1);
                                    case 2:
                                        return r.delete(o);
                                    case 3:
                                        return r.delete(e.value);
                                    default:
                                        return delete r[o]
                                }
                            default:
                                ud(17, i)
                        }
                    }), l
                },
                generatePatches_: function(c, e, t, i) {
                    switch (c.type_) {
                        case 0:
                        case 4:
                        case 2:
                            return d = e, u = t, h = i, p = c.base_, f = c.copy_, void md(c.assigned_, function(e, t) {
                                var i = vd(p, e),
                                    r = vd(f, e),
                                    t = t ? yd(p, e) ? m : g : y;
                                i === r && t == m || (e = d.concat(e), u.push(t == y ? {
                                    op: t,
                                    path: e
                                } : {
                                    op: t,
                                    path: e,
                                    value: r
                                }), h.push(t == g ? {
                                    op: y,
                                    path: e
                                } : t == y ? {
                                    op: g,
                                    path: e,
                                    value: v(i)
                                } : {
                                    op: m,
                                    path: e,
                                    value: v(i)
                                }))
                            });
                        case 5:
                        case 1:
                            return function(e, t, i) {
                                var r, n = c.base_,
                                    s = c.assigned_,
                                    a = c.copy_;
                                a.length < n.length && (n = (r = [a, n])[0], a = r[1], t = (r = [i, t])[0], i = r[1]);
                                for (var o, l = 0; l < n.length; l++) s[l] && a[l] !== n[l] && (o = e.concat([l]), t.push({
                                    op: m,
                                    path: o,
                                    value: v(a[l])
                                }), i.push({
                                    op: m,
                                    path: o,
                                    value: v(n[l])
                                }));
                                for (var d = n.length; d < a.length; d++) {
                                    var u = e.concat([d]);
                                    t.push({
                                        op: g,
                                        path: u,
                                        value: v(a[d])
                                    })
                                }
                                n.length < a.length && i.push({
                                    op: m,
                                    path: e.concat(["length"]),
                                    value: n.length
                                })
                            }(e, t, i);
                        case 3:
                            return r = e, n = t, s = i, a = c.base_, o = c.copy_, l = 0, a.forEach(function(e) {
                                var t;
                                o.has(e) || (t = r.concat([l]), n.push({
                                    op: y,
                                    path: t,
                                    value: e
                                }), s.unshift({
                                    op: g,
                                    path: t,
                                    value: e
                                })), l++
                            }), l = 0, void o.forEach(function(e) {
                                var t;
                                a.has(e) || (t = r.concat([l]), n.push({
                                    op: g,
                                    path: t,
                                    value: e
                                }), s.unshift({
                                    op: y,
                                    path: t,
                                    value: e
                                })), l++
                            })
                    }
                    var r, n, s, a, o, l, d, u, h, p, f
                },
                generateReplacementPatches_: function(e, t, i, r) {
                    i.push({
                        op: m,
                        path: [],
                        value: t
                    }), r.push({
                        op: m,
                        path: [],
                        value: e.base_
                    })
                }
            })
        }

        function eu() {
            var r = function(e, t) {
                return (r = Object.setPrototypeOf || {
                        __proto__: []
                    }
                    instanceof Array && function(e, t) {
                        e.__proto__ = t
                    } || function(e, t) {
                        for (var i in t) t.hasOwnProperty(i) && (e[i] = t[i])
                    })(e, t)
            };

            function i(e, t) {
                function i() {
                    this.constructor = e
                }
                r(e, t), e.prototype = (i.prototype = t.prototype, new i)
            }
            var n = function() {
                function e(e, t) {
                    return this[od] = {
                        type_: 2,
                        parent_: t,
                        scope_: t ? t.scope_ : Pd(),
                        modified_: !1,
                        finalized_: !1,
                        copy_: void 0,
                        assigned_: void 0,
                        base_: e,
                        draft_: this,
                        isManual_: !1,
                        revoked_: !1
                    }, this
                }
                i(e, Map);
                var t = e.prototype;
                return Object.defineProperty(t, "size", {
                    get: function() {
                        return Id(this[od]).size
                    }
                }), t.has = function(e) {
                    return Id(this[od]).has(e)
                }, t.set = function(e, t) {
                    var i = this[od];
                    return l(i), Id(i).has(e) && Id(i).get(e) === t || (s(i), Qd(i), i.assigned_.set(e, !0), i.copy_.set(e, t), i.assigned_.set(e, !0)), this
                }, t.delete = function(e) {
                    if (!this.has(e)) return !1;
                    var t = this[od];
                    return l(t), s(t), Qd(t), t.assigned_.set(e, !1), t.copy_.delete(e), !0
                }, t.clear = function() {
                    var t = this[od];
                    l(t), Id(t).size && (s(t), Qd(t), t.assigned_ = new Map, md(t.base_, function(e) {
                        t.assigned_.set(e, !1)
                    }), t.copy_.clear())
                }, t.forEach = function(r, n) {
                    var s = this;
                    Id(this[od]).forEach(function(e, t, i) {
                        r.call(n, s.get(t), t, s)
                    })
                }, t.get = function(e) {
                    var t = this[od];
                    l(t);
                    var i = Id(t).get(e);
                    if (t.finalized_ || !hd(i)) return i;
                    if (i !== t.base_.get(e)) return i;
                    i = zd(t.scope_.immer_, i, t);
                    return s(t), t.copy_.set(e, i), i
                }, t.keys = function() {
                    return Id(this[od]).keys()
                }, t.values = function() {
                    var e, t = this,
                        i = this.keys();
                    return (e = {})[ld] = function() {
                        return t.values()
                    }, e.next = function() {
                        var e = i.next();
                        return e.done ? e : {
                            done: !1,
                            value: t.get(e.value)
                        }
                    }, e
                }, t.entries = function() {
                    var e, i = this,
                        r = this.keys();
                    return (e = {})[ld] = function() {
                        return i.entries()
                    }, e.next = function() {
                        var e = r.next();
                        if (e.done) return e;
                        var t = i.get(e.value);
                        return {
                            done: !1,
                            value: [e.value, t]
                        }
                    }, e
                }, t[ld] = function() {
                    return this.entries()
                }, e
            }();

            function s(e) {
                e.copy_ || (e.assigned_ = new Map, e.copy_ = new Map(e.base_))
            }
            var a = function() {
                function e(e, t) {
                    return this[od] = {
                        type_: 3,
                        parent_: t,
                        scope_: t ? t.scope_ : Pd(),
                        modified_: !1,
                        finalized_: !1,
                        copy_: void 0,
                        base_: e,
                        draft_: this,
                        drafts_: new Map,
                        revoked_: !1,
                        isManual_: !1
                    }, this
                }
                i(e, Set);
                var t = e.prototype;
                return Object.defineProperty(t, "size", {
                    get: function() {
                        return Id(this[od]).size
                    }
                }), t.has = function(e) {
                    var t = this[od];
                    return l(t), t.copy_ ? !!t.copy_.has(e) || !(!t.drafts_.has(e) || !t.copy_.has(t.drafts_.get(e))) : t.base_.has(e)
                }, t.add = function(e) {
                    var t = this[od];
                    return l(t), this.has(e) || (o(t), Qd(t), t.copy_.add(e)), this
                }, t.delete = function(e) {
                    if (!this.has(e)) return !1;
                    var t = this[od];
                    return l(t), o(t), Qd(t), t.copy_.delete(e) || !!t.drafts_.has(e) && t.copy_.delete(t.drafts_.get(e))
                }, t.clear = function() {
                    var e = this[od];
                    l(e), Id(e).size && (o(e), Qd(e), e.copy_.clear())
                }, t.values = function() {
                    var e = this[od];
                    return l(e), o(e), e.copy_.values()
                }, t.entries = function() {
                    var e = this[od];
                    return l(e), o(e), e.copy_.entries()
                }, t.keys = function() {
                    return this.values()
                }, t[ld] = function() {
                    return this.values()
                }, t.forEach = function(e, t) {
                    for (var i = this.values(), r = i.next(); !r.done;) e.call(t, r.value, r.value, this), r = i.next()
                }, e
            }();

            function o(i) {
                i.copy_ || (i.copy_ = new Set, i.base_.forEach(function(e) {
                    var t;
                    hd(e) ? (t = zd(i.scope_.immer_, e, i), i.drafts_.set(e, t), i.copy_.add(t)) : i.copy_.add(e)
                }))
            }

            function l(e) {
                e.revoked_ && ud(3, JSON.stringify(Id(e)))
            }
            xd("MapSet", {
                proxyMap_: function(e, t) {
                    return new n(e, t)
                },
                proxySet_: function(e, t) {
                    return new a(e, t)
                }
            })
        }
        var tu = new Vr,
            vr = tu.produce,
            iu = tu.produceWithPatches.bind(tu),
            ru = tu.setAutoFreeze.bind(tu),
            nu = tu.setUseProxies.bind(tu),
            vi = tu.applyPatches.bind(tu),
            A = tu.createDraft.bind(tu),
            tu = tu.finishDraft.bind(tu);
        w.Immer = Vr, w.applyPatches = vi, w.castDraft = function(e) {
            return e
        }, w.castImmutable = function(e) {
            return e
        }, w.createDraft = A, w.current = Xd, w.default = vr, w.enableAllPlugins = function() {
            Jd(), eu(), Zd()
        }, w.enableES5 = Jd;
        A = w.enableMapSet = eu;
        w.enablePatches = Zd, w.finishDraft = tu, w.immerable = ad, w.isDraft = cd, w.isDraftable = hd, w.nothing = sd, w.original = function(e) {
            return cd(e) || ud(23, e), e[od].base_
        };
        var su = w.produce = vr;
        w.produceWithPatches = iu;
        var au = w.setAutoFreeze = ru;
        w.setUseProxies = nu;
        const ou = /^((?:[^\/;?#]+:)?)(\/\/[^\/\;?#]*)?(.*?)??(;.*?)?(\?.*?)?(#.*?)?$/,
            lu = /^([^\/;?#]*)(.*)$/,
            du = /(?:\/|^)\.(?=\/)/g,
            uu = /(?:\/|^)\.\.\/(?!\.\.\/).*?(?=\/)/g,
            cu = {
                buildAbsoluteURL: function(e, t, i) {
                    if (i = i || {}, e = e.trim(), !(t = t.trim())) {
                        if (!i.alwaysNormalize) return e;
                        const t = cu.parseURL(e);
                        if (!t) throw new Error("Error trying to parse base URL.");
                        return t.path = cu.normalizePath(t.path), cu.buildURLFromParts(t)
                    }
                    const r = cu.parseURL(t);
                    if (!r) throw new Error("Error trying to parse relative URL.");
                    if (r.scheme) return i.alwaysNormalize ? (r.path = cu.normalizePath(r.path), cu.buildURLFromParts(r)) : t;
                    const n = cu.parseURL(e);
                    if (!n) throw new Error("Error trying to parse base URL.");
                    if (!n.netLoc && n.path && "/" !== n.path[0]) {
                        const e = lu.exec(n.path);
                        n.netLoc = e[1], n.path = e[2]
                    }
                    n.netLoc && !n.path && (n.path = "/");
                    const s = {
                        scheme: n.scheme,
                        netLoc: r.netLoc,
                        path: null,
                        params: r.params,
                        query: r.query,
                        fragment: r.fragment
                    };
                    if (!r.netLoc && (s.netLoc = n.netLoc, "/" !== r.path[0]))
                        if (r.path) {
                            i.inheritQuery && (r.query || (s.query = n.query));
                            const e = n.path,
                                t = e.substring(0, e.lastIndexOf("/") + 1) + r.path;
                            s.path = cu.normalizePath(t)
                        } else s.path = n.path, r.params || (s.params = n.params, r.query || (s.query = n.query));
                    return null === s.path && (s.path = i.alwaysNormalize ? cu.normalizePath(r.path) : r.path), cu.buildURLFromParts(s)
                },
                parseURL: function(e) {
                    e = ou.exec(e);
                    return e ? {
                        scheme: e[1] || "",
                        netLoc: e[2] || "",
                        path: e[3] || "",
                        params: e[4] || "",
                        query: e[5] || "",
                        fragment: e[6] || ""
                    } : null
                },
                normalizePath: function(e) {
                    for (e = e.split("").reverse().join("").replace(du, ""); e.length !== (e = e.replace(uu, "")).length;);
                    return e.split("").reverse().join("")
                },
                buildURLFromParts: function(e) {
                    return e.scheme + e.netLoc + e.path + e.params + e.query + e.fragment
                },
                getHostName: function(e) {
                    let t;
                    return e && (t = -1 < e.indexOf("://") ? e.split("/")[2] : e.split("/")[0], t = t.split(":")[0], t = t.split("?")[0]), t
                }
            };
        var hu, pu, fu, mu, gu, yu, vu, Su, bu = cu;

        function Tu(e) {
            return null != e && !e.startsWith("http://") && !e.startsWith("https://")
        }

        function Eu(e) {
            return null == e || Tu(e) ? null : cu.getHostName(e)
        }
        const Iu = [".*.itunes.apple.com"],
            wu = {
                deviceName: "&xapdn=",
                deviceModel: "&xapdm=",
                language: "&xapdl=",
                dsid: "&xapdsid=",
                subs: "&xapsub="
            };

        function Au(e, t) {
            return !e || e === Eu(t)
        }(iu = hu = hu || {})[iu.DOVI = 4] = "DOVI", iu[iu.HEVC = 3] = "HEVC", iu[iu.VP09 = 2] = "VP09", iu[iu.AVC = 1] = "AVC", iu[iu.UNKNOWN = 0] = "UNKNOWN", (ru = pu = pu || {})[ru.PQ = 3] = "PQ", ru[ru.HLG = 2] = "HLG", ru[ru.SDR = 1] = "SDR", ru[ru.UNKNOWN = 0] = "UNKNOWN", (w = fu = fu || {})[w.ALAC = 7] = "ALAC", w[w.FLAC = 6] = "FLAC", w[w.EC3 = 5] = "EC3", w[w.AC3 = 4] = "AC3", w[w.XHEAAC = 3] = "XHEAAC", w[w.AAC = 2] = "AAC", w[w.MP3 = 1] = "MP3", w[w.UNKNOWN = 0] = "UNKNOWN", (nu = mu = mu || {})[nu.VALID = 1] = "VALID", nu[nu.INVALID = 0] = "INVALID";
        const Ou = ["via", "x-apple-request-uuid"],
            ku = {
                maxNumRetry: 4,
                retryDelayMs: 0,
                maxRetryDelayMs: 0
            },
            Cu = {
                maxNumRetry: 6,
                retryDelayMs: 1e3,
                maxRetryDelayMs: 8e3
            },
            Du = {
                maxNumRetry: 0,
                retryDelayMs: 0,
                maxRetryDelayMs: 0
            },
            Mu = {
                default: {
                    maxTimeToFirstByteMs: 5e3,
                    maxLoadTimeMs: 2e4,
                    autoRetry: !1,
                    timeoutRetry: Du,
                    errorRetry: Du
                },
                customURL: {
                    maxTimeToFirstByteMs: 1e4,
                    maxLoadTimeMs: 2e4,
                    autoRetry: !1,
                    timeoutRetry: Du,
                    errorRetry: Du
                }
            },
            xu = {
                maxNumRetry: 8,
                retryDelayMs: 1e3,
                maxRetryDelayMs: 2e4,
                backoff: "linear"
            },
            Pu = Object.assign(Object.assign({}, xu), {
                maxNumRetry: 1
            }),
            Ru = {
                autoStartLoad: !0,
                startPosition: NaN,
                defaultAudioCodec: void 0,
                defaultVideoCodec: void 0,
                debug: !1,
                debugLevel: "info",
                buildType: void 0,
                minFramesBeforeSwitchingLevel: 11,
                minTargetDurations: 3,
                maxBufferLength: 60,
                maxBufferHole: .5,
                maxSeekHole: 2,
                nudgeFromEventSeek: !0,
                jaggedSeekTolerance: 0,
                discontinuitySeekTolerance: 2,
                bufferedSegmentEjectionToleranceMs: .5,
                almostDryBufferSec: .5,
                maxTotalDurationTolerance: .1,
                lowBufferThreshold: .5,
                lowBufferWatchdogPeriod: .5,
                highBufferWatchdogPeriod: 3,
                seekWatchdogPeriod: 5,
                nudgeOffset: .1,
                nudgeMaxRetry: 3,
                maxFragLookUpTolerance: .2,
                initialLiveManifestSize: 1,
                liveSyncDurationCount: 3,
                liveMaxLatencyDurationCount: 1 / 0,
                liveSyncDuration: void 0,
                liveMaxLatencyDuration: void 0,
                liveFlushExpiredFrags: !0,
                liveMaxUnchangedPlaylistRefresh: 3,
                liveEdgeForZeroStartPositon: !1,
                livePlaylistUpdateStaleness: 2,
                livePlaylistDurationNudge: .001,
                allowFastSwitchUp: !1,
                minMatchGroupDuration: 5,
                desiredIframeFPS: 8,
                initialIframeFPS: 6,
                minRemainingTimeInMediaPipeline: 3,
                leftMediaTimeToAutoPause: 10,
                startTargetDurationFactor: .9,
                minRequiredStartDuration: 4,
                maxRequiredStartDuration: 15,
                enableWorker: !0,
                enableWebCrypto: !0,
                keySystemPreference: void 0,
                useMultipleKeySessions: !1,
                enablePlayReadyKeySystem: !1,
                useMediaKeySystemAccessFilter: !1,
                playReadyMessageFormat: "utf16",
                startLevel: void 0,
                livePlaylistRefreshDelay: 2500,
                liveMinPlayingBufferLen: 5,
                enableIFramePreloading: !0,
                useMediaCapabilities: !1,
                enableID3Cues: !0,
                certLoadPolicy: Mu,
                keyLoadPolicy: {
                    default: {
                        maxTimeToFirstByteMs: 5e3,
                        maxLoadTimeMs: 2e4,
                        autoRetry: !1,
                        timeoutRetry: Pu,
                        errorRetry: xu
                    },
                    customURL: {
                        maxTimeToFirstByteMs: 1e4,
                        maxLoadTimeMs: 2e4,
                        autoRetry: !1,
                        timeoutRetry: Pu,
                        errorRetry: xu
                    }
                },
                manifestLoadPolicy: {
                    default: {
                        maxTimeToFirstByteMs: 1e4,
                        maxLoadTimeMs: 2e4,
                        autoRetry: !1,
                        timeoutRetry: {
                            maxNumRetry: 2,
                            retryDelayMs: 0,
                            maxRetryDelayMs: 0
                        },
                        errorRetry: {
                            maxNumRetry: 1,
                            retryDelayMs: 1e3,
                            maxRetryDelayMs: 8e3
                        }
                    },
                    customURL: {
                        maxTimeToFirstByteMs: 1e4,
                        maxLoadTimeMs: 1e4,
                        autoRetry: !1,
                        timeoutRetry: {
                            maxNumRetry: 2,
                            retryDelayMs: 0,
                            maxRetryDelayMs: 0
                        },
                        errorRetry: {
                            maxNumRetry: 1,
                            retryDelayMs: 1e3,
                            maxRetryDelayMs: 8e3
                        }
                    }
                },
                trickPlaybackConfig: {
                    enabled: !0,
                    minIframeDuration: 8
                },
                playlistLoadPolicy: {
                    default: {
                        maxTimeToFirstByteMs: 1e4,
                        maxLoadTimeMs: 2e4,
                        autoRetry: !1,
                        timeoutRetry: {
                            maxNumRetry: 2,
                            retryDelayMs: 0,
                            maxRetryDelayMs: 0
                        },
                        errorRetry: {
                            maxNumRetry: 2,
                            retryDelayMs: 1e3,
                            maxRetryDelayMs: 8e3
                        }
                    },
                    customURL: {
                        maxTimeToFirstByteMs: 1e4,
                        maxLoadTimeMs: 1e4,
                        autoRetry: !1,
                        timeoutRetry: {
                            maxNumRetry: 2,
                            retryDelayMs: 0,
                            maxRetryDelayMs: 0
                        },
                        errorRetry: {
                            maxNumRetry: 2,
                            retryDelayMs: 1e3,
                            maxRetryDelayMs: 8e3
                        }
                    }
                },
                fragLoadPolicy: {
                    default: {
                        maxTimeToFirstByteMs: 5e3,
                        maxLoadTimeMs: 2e4,
                        autoRetry: !1,
                        timeoutRetry: ku,
                        errorRetry: Cu,
                        forceContentLenCheckIfNoHeader: !1,
                        reportCDNServer: !0
                    },
                    customURL: {
                        maxTimeToFirstByteMs: 1e4,
                        maxLoadTimeMs: 2e4,
                        autoRetry: !1,
                        timeoutRetry: ku,
                        errorRetry: Cu,
                        reportCDNServer: !0
                    }
                },
                steeringManifestLoadPolicy: {
                    default: {
                        maxTimeToFirstByteMs: 1e4,
                        maxLoadTimeMs: 2e4,
                        autoRetry: !1,
                        timeoutRetry: {
                            maxNumRetry: 2,
                            retryDelayMs: 0,
                            maxRetryDelayMs: 0
                        },
                        errorRetry: {
                            maxNumRetry: 1,
                            retryDelayMs: 1e3,
                            maxRetryDelayMs: 8e3
                        }
                    },
                    customURL: {
                        maxTimeToFirstByteMs: 1e4,
                        maxLoadTimeMs: 1e4,
                        autoRetry: !1,
                        timeoutRetry: {
                            maxNumRetry: 2,
                            retryDelayMs: 0,
                            maxRetryDelayMs: 0
                        },
                        errorRetry: {
                            maxNumRetry: 1,
                            retryDelayMs: 1e3,
                            maxRetryDelayMs: 8e3
                        }
                    }
                },
                maxNumAddLevelToPenaltyBox: 4,
                firstAudioMustOverlapVideoStart: !1,
                keyMinHoldTimeBeforeCleanup: 15e3,
                startFragPrefetch: !1,
                appendErrorMaxRetry: 3,
                alwaysResetOnNewCC: !1,
                fLoader: void 0,
                pLoader: void 0,
                xhrSetup: void 0,
                iframeMaxExitSeekDuration: 2e3,
                iframeStallMaxRetry: 5,
                audioPrimingDelay: 0,
                enableCEA708Captions: !0,
                customTextTrackCueRenderer: !1,
                enableWebVTT: !0,
                captionsTextTrack1Label: "English",
                captionsTextTrack1LanguageCode: "en",
                captionsTextTrack2Label: "Spanish",
                captionsTextTrack2LanguageCode: "es",
                enableDualTrackSelection: !1,
                condenseSubtitleTrack: !1,
                nativeTextTrackChangeHandling: !0,
                earlyFragTolerance: 7,
                vttConcurrentLoadCount: 1,
                trottleCheckInterval: 2e3,
                subtitleLeadTime: 30,
                lateTolerance: 2,
                stretchShortVideoTrack: !1,
                forceKeyFrameOnDiscontinuity: !0,
                useFirstLevelAtIncompatDiscontinuity: !0,
                abrBandwidthEstimator: "bandwidth-history-controller",
                abrEwmaDefaultEstimate: 5e5,
                abrDefaultEstimate: 5e5,
                abrBandWidthFactor: .95,
                abrBandWidthUpFactor: .9,
                abrMaxWithRealBitrate: !1,
                maxStarvationDelay: 4,
                maxLoadingDelay: 4,
                minAutoBitrate: 0,
                enableRtcReporting: !1,
                rtcIntervalTimeout: 3e5,
                rtcSender: "HLSJS",
                rtcSessionTag: "none",
                useHTTPPlaybackSessionId: !1,
                warmupCdms: !1,
                enablePerformanceLogging: !1,
                overridePlaybackRate: !1,
                nativeControlsEnabled: !1,
                useCustomMediaFunctions: !0,
                seekEventThrottleMs: 150,
                enableAdaptiveStartup: !0,
                bandwidthHistoryWindowSize: 12e4,
                bandwidthHistoryTTL: 6e5,
                bandwidthHistoryAggregationMethod: "quadratic-time-weighted",
                bandwidthHistoryGetEstimateThrottleMs: 1e3,
                defaultTargetDuration: 10,
                targetStartupMs: 4e3,
                adaptiveStartupMetricsOverride: {
                    maxValidHeight: 1080,
                    maxValidBitrate: 1 / 0,
                    maxPreferredBitrate: 1 / 0
                },
                bandwidthHistoryStorageKey: "AppleHLS-bandwidth-estimation",
                storageKeyPrefix: "AppleHLS-",
                storage: {
                    get: "undefined" == typeof localStorage ? void 0 : localStorage.getItem.bind(localStorage),
                    set: "undefined" == typeof localStorage ? void 0 : localStorage.setItem.bind(localStorage)
                },
                minFragmentCount: 10,
                minPlaylistCount: 5,
                enableCDNFallback: !0,
                enableQueryParamsForITunes: !1,
                gapless: !1,
                useViewportSizeForLevelCap: !1,
                statDefaults: {
                    playlistLoadTimeMs: 500,
                    playlistParseTimeMs: 50,
                    fragParseTimeMs: 50,
                    fragBufferCreationDelayMs: 200,
                    dataFragAppendMs: 50,
                    initFragAppendMs: 50
                },
                disableVideoCodecList: new Set([]),
                disableAudioCodecList: new Set([fu.ALAC, fu.FLAC, fu.XHEAAC]),
                useHighestVideoCodecPrivate: !0,
                sessionDataAutoLoad: {
                    "com.apple.hls.chapters": !0
                }
            },
            Lu = Object.assign(Object.assign({}, {
                itemId: "Nah",
                mediaOptionId: "Nah"
            }), {
                mediaOptionType: void 0
            }),
            _u = e => {
                var {
                    itemId: t,
                    mediaOptionId: e
                } = e;
                return "Nah" !== t && "Nah" !== e
            };
        (iu = gu = gu || {})[iu.Variant = 0] = "Variant", iu[iu.AltAudio = 1] = "AltAudio", iu[iu.Subtitle = 2] = "Subtitle";
        const Nu = ["variant", "altAudio", "subtitle"],
            Fu = [gu.Variant, gu.AltAudio, gu.Subtitle],
            Bu = [gu.Variant, gu.AltAudio];
        (ru = yu = yu || {})[ru.Variant = 0] = "Variant", ru[ru.AltAudio = 1] = "AltAudio";
        const Uu = ["variant", "altAudio"];

        function $u(e) {
            switch (e) {
                case gu.Variant:
                    return yu.Variant;
                case gu.AltAudio:
                    return yu.AltAudio;
                default:
                    return null
            }
        }

        function Vu(e) {
            return e === yu.Variant ? gu.Variant : gu.AltAudio
        }(w = vu = vu || {})[w.NO = 0] = "NO", w[w.YES = 1] = "YES", (nu = Su = Su || {}).UNKNOWN = "unkn", nu.VIDEO = "vide", nu.AUDIO = "soun", nu.SUBTITLE = "sbtl", nu.CLOSEDCAPTION = "clcp";
        const Ku = {
            search: function(e, t) {
                let i, r, n = 0,
                    s = (null == e ? void 0 : e.length) - 1;
                for (; n <= s;) {
                    var a = t(r = e[i = (n + s) / 2 | 0]);
                    if (0 < a) n = 1 + i;
                    else {
                        if (!(a < 0)) return r;
                        s = i - 1
                    }
                }
                return null
            }
        };
        var qu = Ku,
            Hu = {
                findFragmentBySNAndBuffer: function(e, t, i = 0, r = 0, n = 0) {
                    let s;
                    e = e ? t[e.mediaSeqNum - t[0].mediaSeqNum + 1] : null;
                    return s = i < r ? (r - n < i && (n = 0), e && !this.fragmentWithinToleranceTest(i, n, e) ? e : Ku.search(t, this.fragmentWithinToleranceTest.bind(null, i, n))) : t[t.length - 1], s
                },
                fragmentWithinToleranceTest: function(e, t, i) {
                    t = Math.min(t, i.duration);
                    return i.start + i.duration - t <= e ? 1 : i.start - t > e && i.start ? -1 : 0
                }
            };
        const ju = {
            startFragmentInCC: function(e, t, i) {
                let r = t - i.discoSeqNum;
                if (0 === r) {
                    const t = e[i.mediaSeqNum - e[0].mediaSeqNum - 1];
                    r = t && t.discoSeqNum === i.discoSeqNum ? -1 : 0
                }
                return r
            },
            endFragmentInCC: function(e, t, i) {
                let r = t - i.discoSeqNum;
                if (0 === r) {
                    const t = e[i.mediaSeqNum - e[0].mediaSeqNum + 1];
                    r = t && t.discoSeqNum === i.discoSeqNum ? 1 : 0
                }
                return r
            },
            findStartEndFragmentsInCC: function(e, t, i) {
                let r, n;
                return 0 < (null == e ? void 0 : e.length) && ne(t) && (r = Ku.search(e, ju.startFragmentInCC.bind(null, e, t)), n = Ku.search(e, ju.endFragmentInCC.bind(null, e, t))), r && !ne(r.discoSeqNum) && (r = void 0), n && !ne(n.discoSeqNum) && (n = void 0), {
                    startFrag: r,
                    endFrag: n
                }
            },
            getTimeRangeDictForCC: function(e, t, i) {
                var {
                    startFrag: t,
                    endFrag: i
                } = ju.findStartEndFragmentsInCC(e, t, i);
                return {
                    start: t.start,
                    end: i.start + i.duration
                }
            },
            getTimeRangeForCC: function(e, t, i) {
                var {
                    startFrag: t,
                    endFrag: i
                } = ju.findStartEndFragmentsInCC(e, t, i);
                let r = [];
                return t && i && (r = [t.start, i.start + i.duration]), r
            },
            snapToCCTimeRange: function(e, t, i, r) {
                r = ju.getTimeRangeForCC(t, i, r);
                return null != r && r.length ? Math.min(r[1], Math.max(r[0], e)) : e
            },
            getMinTimeForCC(e, t, i, r) {
                if (null == e || !e.length) return 0;
                let n = 0;
                if (ne(i) && e) {
                    e = ju.getTimeRangeForCC(e, i, r);
                    if (e) {
                        const s = ju.getTimeRangeForCC(t, i, r);
                        n = null != s && s.length ? Math.max(s[0], e[0]) : e[0]
                    }
                }
                return n
            },
            discoSeqNumForTime(e, t, i = 0) {
                i = Ku.search(e, Hu.fragmentWithinToleranceTest.bind(null, t, i));
                return null == i ? void 0 : i.discoSeqNum
            }
        };
        var Qu = ju;
        const Wu = $i(void 0);

        function Gu(e, t, i = 1) {
            return e.pipe(ln(t), Ds(i))
        }

        function zu(e, t) {
            var i = e.timeline;
            return {
                seconds: (e.seconds - i.rootTimeSeconds) / i.rate * t.rate + t.rootTimeSeconds,
                timeline: t
            }
        }
        class Xu {
            constructor() {
                this._timeline = null
            }
            get forward() {
                var e;
                return 0 < (null === (e = this.timeline) || void 0 === e ? void 0 : e.rate)
            }
            get isStarted() {
                return Boolean(this.hostClock)
            }
            start(e) {
                this.stopTime = null, this._timeline = Object.assign({}, e);
                const t = {
                    rootTimeSeconds: performance.now() / 1e3,
                    rate: 1
                };
                this.hostClock = {
                    timeline: t,
                    getCurrentTime: () => ({
                        seconds: performance.now() / 1e3,
                        timeline: t
                    })
                }
            }
            pause() {
                this.isStarted && (this.stopTime = this.getCurrentTime())
            }
            stop() {
                this.pause(), this.hostClock = null, this._timeline = null
            }
            get timeline() {
                return this._timeline
            }
            getCurrentTime() {
                return this.stopTime || zu(this.hostClock.getCurrentTime(), this.timeline)
            }
        }
        class Yu {
            constructor(e) {
                this._timeline = e, this.mediaRootTime = this.lastTimeSeconds = e.rootTimeSeconds
            }
            get timeline() {
                return Object.assign({}, this._timeline)
            }
            getCurrentTime() {
                return {
                    seconds: this.lastTimeSeconds,
                    timeline: Object.assign({}, this._timeline)
                }
            }
        }
        const Ju = {
            name: "ifm"
        };
        class Zu {
            constructor(e, t) {
                this.config = e, this.logger = t, this.scaledFragments = [], this.iframeClock = new Xu, this.hasMore$ = new yi(!0), this.logger = t.child(Ju)
            }
            destroy() {
                this.stop()
            }
            resetScaledSegments() {
                this.scaledFragments = []
            }
            get anchorFrag() {
                return this.scaledFragments.length ? this.scaledFragments[0] : null
            }
            get lastFrag() {
                return this.scaledFragments.length ? this.scaledFragments.slice(-1)[0] : null
            }
            get isStarted() {
                return Boolean(this.iframeClock.isStarted)
            }
            get iframeRate() {
                var e;
                return null !== (e = null === (e = this.iframeClock.timeline) || void 0 === e ? void 0 : e.rate) && void 0 !== e ? e : 0
            }
            get iframeClockTimeSeconds() {
                return Math.max(0, this.iframeClock.getCurrentTime().seconds)
            }
            get mediaAppendClockTimeSeconds() {
                var e;
                return null !== (e = null === (e = this.mediaAppendClock) || void 0 === e ? void 0 : e.getCurrentTime().seconds) && void 0 !== e ? e : 0
            }
            get mediaRootTime() {
                var e;
                return null === (e = this.mediaAppendClock) || void 0 === e ? void 0 : e.mediaRootTime
            }
            pause() {
                this.iframeClock.pause()
            }
            stop() {
                this.hasMore$.next(!0), this.iframeClock.stop(), this.mediaAppendClock = null, this.resetScaledSegments()
            }
            checkHasMore() {
                this.hasMore$.next(!0)
            }
            startClocksAndGetFirstFragment(e, t, i, r, n) {
                let s = Ku.search(e, Hu.fragmentWithinToleranceTest.bind(null, r, 1e-4));
                if (!s && r >= e[e.length - 1].start && (s = e[e.length - 1]), !s) return this.logger.error(`startClocksAndGetFirstFragment => no anchorFrag for time ${r}`), this.hasMore$.next(!1), null;
                var a = ne(n) ? n : s.discoSeqNum,
                    a = Qu.getMinTimeForCC(e, t, a, this.logger),
                    r = ne(n) && 1 < i ? a : r,
                    a = 1 < i ? Math.ceil(r) : Math.ceil(a);
                return this.iframeClock.start({
                    rootTimeSeconds: r,
                    rate: i
                }), this.mediaAppendClock = new Yu({
                    rootTimeSeconds: a,
                    rate: 1
                }), {
                    frag: s,
                    newMediaRootTime: a
                }
            }
            getNextFragment(e, t, i) {
                const r = this.lastFrag,
                    {
                        iframeClock: n,
                        mediaAppendClock: s
                    } = this,
                    a = n.timeline;
                s.lastTimeSeconds = t;
                var o = n.forward ? 1 : -1;
                let l, d = Math.max(0, Math.min(r.mediaSeqNum - e[0].mediaSeqNum + o, e.length - 1));
                if (r.mediaSeqNum !== e[d].mediaSeqNum)
                    do {
                        l = e[d];
                        const i = n.forward ? l.start : l.start + l.duration;
                        if (zu({
                                seconds: i,
                                timeline: a
                            }, s.timeline).seconds >= t && (n.forward && i >= this.iframeClockTimeSeconds || !n.forward && i <= this.iframeClockTimeSeconds)) break
                    } while (d += o, 0 < d && d < e.length);
                return l || (this.logger.error(`getNextFragment(bufferEnd: ${t}) => no more frags, but we should have found an end fragment, setting hasMore to false`), this.hasMore$.next(!1)), {
                    frag: l
                }
            }
            nextFragment(e, t, i, r) {
                let n, s;
                if (this.isStarted && i !== this.iframeRate && (s = this.iframeClockTimeSeconds, this.stop()), this.isStarted) {
                    if (n = this.getNextFragment(e, r, i), !n.frag) return;
                    if (n.frag.discoSeqNum !== this.anchorFrag.discoSeqNum) {
                        const a = this.iframeClockTimeSeconds;
                        this.stop();
                        const s = this.startClocksAndGetFirstFragment(e, t, i, a, n.frag.discoSeqNum)["newMediaRootTime"];
                        n.newMediaRootTime = s
                    }
                } else if (n = this.startClocksAndGetFirstFragment(e, t, i, null != s ? s : r), !n) return;
                var r = n["frag"],
                    r = this.handleNextFrag(e, r);
                return Object.assign(Object.assign({}, n), {
                    frag: r
                })
            }
            handleNextFrag(e, t) {
                const i = Object.assign(Object.assign({}, t), {
                        iframeMediaStart: NaN,
                        iframeMediaDuration: NaN
                    }),
                    {
                        mediaAppendClock: r,
                        iframeClock: n
                    } = this;
                this.iframeClockBounds = Qu.getTimeRangeDictForCC(e, i.discoSeqNum, this.logger);
                var s = r.getCurrentTime().seconds,
                    t = n.timeline.rate;
                return ne(i.iframeOriginalStart) || (i.iframeOriginalStart = i.start), i.start = i.iframeMediaStart = s, i.iframeMediaDuration = Math.max(i.duration / Math.abs(t), 1 / this.config.minIframeDuration), this.scaledFragments.push(i), this.isEndFrag(e, i) && this.hasMore$.next(!1), i
            }
            get hasMore() {
                return this.hasMore$.value
            }
            handleWaitForMore() {
                return this.isStarted ? (this.iframeClock.getCurrentTime(), Gu(this.hasMore$, e => !0 === e).pipe(Za(() => {}))) : Wu
            }
            isEndFrag(e, t) {
                var i = e[0],
                    r = e[e.length - 1],
                    e = this.iframeClock.forward;
                return !e && (null == i ? void 0 : i.mediaSeqNum) === t.mediaSeqNum || e && (null == r ? void 0 : r.mediaSeqNum) === t.mediaSeqNum
            }
        }

        function ec(e, t) {
            for (var i = 0; i < t.length; i++) {
                var r = t[i];
                r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
            }
        }

        function tc(t) {
            return function(e) {
                return e.lift(new nc(t))
            }
        }
        var ic, rc, nc = (ec(sc.prototype, [{
            key: "call",
            value: function(e, t) {
                return t.subscribe(e)
            }
        }]), sc);

        function sc(e) {
            ! function(e) {
                if (!(e instanceof sc)) throw new TypeError("Cannot call a class as a function")
            }(this), "tag" in this ? Object.defineProperty(this, "tag", {
                value: void 0,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : this.tag = void 0, this.tag = e
        }

        function ac(e) {
            const {
                method: t,
                isEncrypted: i,
                uri: r,
                format: n,
                formatversions: s
            } = e, a = {
                method: t,
                isEncrypted: i,
                uri: r,
                format: n,
                formatversions: s,
                iv: e.ivBuf ? new Uint8Array(e.ivBuf) : null
            };
            return e.keyIdBuf && (a.keyId = new Uint8Array(e.keyIdBuf)), e.keyBuf && (a.key = new Uint8Array(e.keyBuf)), e.psshBuf && (a.pssh = new Uint8Array(e.psshBuf)), a
        }(iu = ic = ic || {}).MustRequestResponse = "MustRequestResponse", iu.WaitingForKeyResponse = "WaitingForKeyResponse", iu.GotKeyResponse = "GotKeyResponse";
        class oc extends Error {
            constructor(e, t) {
                super(e), this.code = t
            }
        }
        class lc extends p {
            constructor(e, t, i, r, n, s) {
                super(o, e, t, i, n), this.code = r, this.isTimeout = s, this.response = n
            }
        }
        class dc extends lc {
            constructor(e, t, i, r, n) {
                super(n ? "manifestLoadTimeOut" : "manifestLoadError", e, t, i, r, n)
            }
        }
        class uc extends lc {
            constructor(e, t, i, r, n, s, a, o) {
                switch (super("", e, t, i, r, n), this.mediaOptionType = s, this.mediaOptionId = a, this.url = o, s) {
                    case gu.Variant:
                        this.details = n ? "levelLoadTimeOut" : N;
                        break;
                    case gu.AltAudio:
                        this.details = n ? "audioTrackLoadTimeOut" : "audioTrackLoadError";
                        break;
                    case gu.Subtitle:
                        this.details = n ? "subtitleTrackLoadTimeout" : "subtitleTrackLoadError"
                }
            }
        }
        class cc extends lc {
            constructor(e, t, i, r) {
                super("sessionDataLoadError", e, t, i, r, !1)
            }
        }
        class hc extends lc {
            constructor(e, t, i, r, n, s, a) {
                super(n ? "fragLoadTimeOut" : "fragLoadError", e, t, i, r, n), this.mediaOptionId = s.mediaOptionId, this.mediaOptionType = s.mediaOptionType, this.stats = a
            }
        }
        class pc extends dr {
            constructor(e, t, i) {
                super(), this.message = e, this.code = t, this.stats = i
            }
        }
        class fc extends lc {
            constructor(e, t, i) {
                super("fragAbortError", !1, "Fragment abort", 0, i, !1), this.candidateMediaOptionId = t, this.mediaOptionId = e.mediaOptionId, this.mediaOptionType = e.mediaOptionType
            }
        }
        class mc extends lc {
            constructor(e, t, i, r = []) {
                super("keyLoadTimeOut", !1, e, i.code, i, !0), this.keyuri = t, this.response = i, this.mediaOptionIds = r
            }
        }(ru = rc = rc || {})[ru.InvalidState = 0] = "InvalidState", ru[ru.Abort = 1] = "Abort", ru[ru.OutputRestricted = 2] = "OutputRestricted", ru[ru.AlreadyFailedKey = 3] = "AlreadyFailedKey", ru[ru.HttpError = 4] = "HttpError", ru[ru.InternalError = 5] = "InternalError", ru[ru.LicenseServerError = 6] = "LicenseServerError", ru[ru.InsufficientCPC = 7] = "InsufficientCPC";
        class gc extends lc {
            constructor(e, t, i, r, n, s, a = !1, o = []) {
                super("keyLoadError", a, e, i, r, !1), this.keyuri = t, this.isOkToRetry = n, this.keyErrorReason = s, this.mediaOptionIds = o
            }
        }
        class yc extends p {
            constructor(e, t, i, r, n) {
                super(s, "keySystemGenericError", !0, e, r), this.keyuri = t, this.code = i, this.response = r, this.keysystemstring = n
            }
        }

        function vc(e, t) {
            return e instanceof gc ? new gc(e.message, e.keyuri, e.code, e.response, e.isOkToRetry, e.keyErrorReason, e.fatal, t) : e instanceof mc ? new mc(e.message, e.keyuri, $.CryptResponseReceivedSlowly, t) : e ? new V(e.fatal, e.reason, $.InternalError) : null
        }
        const Sc = {
            id: "fairplaystreaming",
            systemStringPrefix: "com.apple.fps",
            keyFormatString: "com.apple.streamingkeydelivery",
            securityLevels: {
                AppleBaseline: 0,
                AppleMain: 1,
                Main: 1,
                Baseline: 0
            }
        };
        class bc extends kl {
            constructor(e) {
                super(e), this.store = e
            }
            get unresolvedUriLoading$() {
                return this.selectEntityAction(Eo.Add).pipe(hr(e => e.map(e => this.getEntity(e))))
            }
        }
        class Tc {
            constructor(e) {
                this.store = e
            }
            createUnresolvedUriLoading(e, t, i) {
                Do("loader.create.unresolvedUriLoading"), this.store.add({
                    uri: e,
                    responseType: t,
                    userAgent: i
                })
            }
            removeUnresolvedUriLoading(e) {
                Do("loader.remove.unresolvedUriLoading"), this.store.remove(e)
            }
        }
        const Ec = new class extends fl {
            constructor() {
                super({}, {
                    name: "loader",
                    producerFn: su,
                    idKey: "uri"
                })
            }
        };
        let Ic = null;
        class wc extends t {
            trigger(e, t) {
                try {
                    this.emit(e, e, t), "hlsFragLoadProgress" !== e.toString() && ("hlsInternalError" !== e && "hlsError" !== e || !t.length || JSON.stringify(t[0], ["fatal", "details", "reason"]), e.toString())
                } catch (t) {
                    Qe().warn(`error in event listener for ${e}: ${t.message}`)
                }
            }
        }
        class Ac {
            constructor(e, t) {
                this.target = e, this._this = t
            }
            eventWithOptions(e, t, i, r = this._this) {
                let n = rn(this.target, e, t);
                return this.target instanceof wc && (n = n.pipe(hr(([, e]) => e))), i && (r && (i = i.bind(r)), n = n.pipe(Za(i))), n
            }
            event(e, t, i = this._this) {
                return this.eventWithOptions(e, void 0, t, i)
            }
            listen(e, t, i, r = this._this) {
                return this.event(e, i, r).pipe(Va(t)).subscribe()
            }
        }

        function Oc(e, t) {
            return new Ac(e, t)
        }

        function kc(e, t, i) {
            var r;
            return {
                currentTarget: null !== (r = null == i ? void 0 : i.currentTarget) && void 0 !== r ? r : e,
                target: null !== (i = null == i ? void 0 : i.target) && void 0 !== i ? i : e,
                type: t
            }
        }

        function Cc(y, v) {
            return new $t(e => {
                const {
                    maxTimeToFirstByteMs: t,
                    maxLoadTimeMs: i
                } = v, r = new XMLHttpRequest, n = {
                    trequest: performance.now(),
                    tfirst: NaN,
                    tload: NaN,
                    loaded: 0,
                    total: NaN,
                    complete: !1
                }, s = Oc(r), a = s.event("progress").pipe(Aa(), ao(300, Ti, {
                    leading: !0,
                    trailing: !0
                }), hr(e => (isNaN(n.tfirst) && (n.tfirst = performance.now()), n.loaded = e.loaded, e.lengthComputable && (n.total = e.total), e.target)), ln(e => 3 <= e.readyState)), o = s.event("readystatechange").pipe(Aa(), hr(e => e.target), ln(e => 2 <= e.readyState), Za(e => {
                    isNaN(n.tfirst) && 3 <= e.readyState && (n.tfirst = performance.now())
                }));
                let l = Ii;
                isFinite(t) && 0 < t && (l = an(a, o).pipe(Ds(1), So(0 < y.extendMaxTTFB ? y.extendMaxTTFB : t), La(() => Ii)));
                let d = Ii;
                isFinite(i) && 0 < i && (d = o.pipe(ln(e => 4 <= e.readyState), Ds(1), So(i), La(() => Ii)));
                let u = Ii;
                y.onProgress && (u = an($i(r), a).pipe(hr(e => {
                    const {
                        getData: t,
                        cb: i
                    } = y.onProgress;
                    return i(y.url, e.status, n, t ? e.response : void 0)
                }), Wa(e => !e, !0)).pipe($a(Ii)));
                const c = an(a.pipe(La(() => Ii)), o, l, d, u).pipe(ln(e => 4 <= e.readyState), Ds(1), La(e => {
                        if (n.complete = !0, 200 <= e.status && e.status < 300) {
                            if (n.tload = performance.now(), n.contentType = e.getResponseHeader("Content-Type"), v.reportCDNServer && (n.cdnServer = e.getResponseHeader("CDN-Server")), n.contentLength = v.forceContentLenCheckIfNoHeader ? function(e) {
                                    let t;
                                    const i = e.getResponseHeader("Content-Encoding"),
                                        r = e.getResponseHeader("Transfer-Encoding"),
                                        n = !i || i && "identity" === i.toLowerCase(),
                                        s = !r || r && "identity" === r.toLowerCase();
                                    return n && s && (t = function(e) {
                                        e = /([0-9]+)\-([0-9]+)\/([0-9]+)/.exec(e);
                                        return e ? parseInt(e[2]) - parseInt(e[1]) + 1 : void 0
                                    }(e.getResponseHeader("Content-Range")), ne(t) || (t = parseInt(e.getResponseHeader("Content-Length")))), t
                                }(e) : null, i = e, (r = y).collectServerInstanceInfo && (r.serverInstanceInfo = {}, r.collectServerInstanceInfo.forEach(e => {
                                    var t = i.getResponseHeader(e);
                                    t && (r.serverInstanceInfo[e] = t)
                                })), "arraybuffer" === y.responseType ? n.loaded = e.response.byteLength : n.loaded = e.responseText.length, n.total = n.loaded, y.checkContentLength && (0 === n.total || ne(n.contentLength) && n.total != n.contentLength)) throw new oc("Network error", e.status);
                            return Nr($i([e, n]), Ti)
                        }
                        var i, r;
                        throw new oc("Network error", e.status)
                    }), Vn(e => {
                        if (e instanceof dr) throw new pc(e.message, 0, n);
                        if (!(e instanceof oc)) throw new oc(e.message, 0);
                        throw e
                    })).subscribe(e),
                    {
                        url: h,
                        method: p,
                        byteRangeOffset: f,
                        responseType: m,
                        body: g
                    } = y;
                y.mimeType && r.overrideMimeType(y.mimeType);
                try {
                    const v = y.xhrSetup;
                    if (v) try {
                        v(r, h)
                    } catch (e) {
                        r.open(p, y.url, !0), v(r, y.url)
                    }
                    r.readyState || r.open(p, y.url, !0)
                } catch (e) {
                    throw new oc(e.message, r.status)
                }
                if (r.responseType = m, f && ne(f.start) && ne(f.end) && 0 <= f.start && f.end > f.start) {
                    const {
                        start: y,
                        end: v
                    } = f;
                    r.setRequestHeader("Range", `bytes=${y}-${v-1}`)
                }
                if (y.headers)
                    for (const [v, e] of Object.entries(y.headers)) r.setRequestHeader(v, e);
                return "POST" === p && g ? r.send(g) : r.send(), () => {
                    r.abort(), c.unsubscribe()
                }
            })
        }
        const Dc = {
            name: "CustomUrlLoader"
        };
        class Mc {
            constructor(e) {
                this.loaderService = e, this.requestMap = {}, this.logger = Qe()
            }
            load(a, o) {
                return new $t(e => {
                    const t = a.url,
                        i = o["maxTimeToFirstByteMs"],
                        r = {
                            trequest: performance.now(),
                            tfirst: NaN,
                            tload: NaN,
                            loaded: 0,
                            total: NaN,
                            complete: !1
                        },
                        n = (this.requestMap[t] = new er).pipe(So(0 < a.extendMaxTTFB ? a.extendMaxTTFB : i), La(e => (r.tfirst = performance.now(), this.handleExternalResponse(e, a, o, r))), Vn(e => {
                            if (e instanceof dr) throw new pc(e.message, 0, r);
                            throw e
                        }), Vs(() => {
                            this.requestMap[t] = void 0, this.loaderService.removeUnresolvedUriLoading(t)
                        }));
                    a.onProgress && a.onProgress.cb(t, 0, r, void 0);
                    const s = n.subscribe(e);
                    return this.loaderService.createUnresolvedUriLoading(t, a.responseType, navigator.userAgent), () => {
                        s.unsubscribe(), this.requestMap[t] = void 0
                    }
                })
            }
            setCustomUrlResponse(e, t) {
                const i = this.requestMap[e];
                i && (i.next(t), i.complete(), this.requestMap[e] = void 0)
            }
            handleExternalResponse(e, t, i, r) {
                r.tload = performance.now();
                var n = e.response.status || 200;
                return 200 <= n && n < 300 ? ("arraybuffer" === t.responseType && e.response.data instanceof ArrayBuffer ? r.loaded = e.response.data.byteLength : r.loaded = e.response.data.toString().length, r.total = r.loaded, r.complete = !0, Nr($i({
                    status: n,
                    data: e,
                    stats: r
                }), Ti)) : 300 === n || 302 === n || 303 === n || 305 === n ? this.redirectRequest(e.response.uri, t, i, r) : (this.logger.warn(Dc, `unable to load custom url > uri=${le(e.response.uri)}, status=${n}`), Vi(new oc("Unable to load custom url", n)))
            }
            redirectRequest(e, t, i, n) {
                var {
                    maxLoadTimeMs: r,
                    maxTimeToFirstByteMs: s
                } = i, r = r - (performance.now() - n.trequest), s = 0 < t.extendMaxTTFB ? t.extendMaxTTFB : s - (performance.now() - n.trequest), i = Object.assign(Object.assign({}, i), {
                    maxLoadTimeMs: r,
                    maxTimeToFirstByteMs: s
                }), e = Object.assign(Object.assign({}, t), {
                    url: e
                });
                return r <= 0 || s <= 0 ? Vi(new dr) : Cc(e, i).pipe(hr(([e, t]) => {
                    var {
                        responseURL: i,
                        status: r
                    } = e, i = i || "", i = {
                        uri: i,
                        response: {
                            status: r,
                            uri: i,
                            data: e.response
                        }
                    };
                    return n.loaded = n.total = t.loaded, n.tload = performance.now(), n.complete = !0, {
                        status: e.status,
                        data: i,
                        stats: n
                    }
                }))
            }
        }
        let xc;

        function Pc(e) {
            return xc || (e = e || (Ic = Ic || new Tc(Ec), Ic), xc = new Mc(e)), xc
        }

        function Rc(e, t) {
            const i = Object.assign(Object.assign({}, e), {
                    method: "GET",
                    responseType: "arraybuffer"
                }),
                r = Pc();
            return Tu(i.url) ? r.load(i, t).pipe(hr(e => [e.data.response.data, e.stats, i.serverInstanceInfo])) : Cc(i, t).pipe(hr(([e, t]) => [e.response, t, i.serverInstanceInfo]))
        }

        function Lc(e, t) {
            return !e.url || Tu(e.url) ? t.customURL : t.default
        }

        function _c(e, t) {
            return e instanceof lc ? e.isTimeout ? t.timeoutRetry : t.errorRetry : null
        }

        function Nc(e) {
            var t = e.type,
                i = e.liveOrEvent;
            let r = "VOD";
            "EVENT" === t && i ? r = "EVENT" : t && 0 !== t.length && "LIVE" !== t || !i || (r = "LIVE"), e.type !== r && (e.type = r)
        }
        const Fc = {
                id: "playready",
                systemStringPrefix: "com.microsoft.playready",
                keyFormatString: "com.microsoft.playready",
                securityLevels: {
                    SL2000: 0,
                    SL3000: 1
                }
            },
            Bc = {
                id: "widevine",
                systemStringPrefix: "com.widevine.alpha",
                keyFormatString: "urn:uuid:edef8ba9-79d6-4ace-a3c8-27dcd51d21ed",
                securityLevels: {
                    WIDEVINE_SOFTWARE: 0,
                    WIDEVINE_HARDWARE: 1
                }
            };

        function Uc(e) {
            return e.replace(/\+/g, "-").replace(/\//g, "_").replace(/\=+$/, "")
        }
        class $c {
            static strToBase64Encode(e) {
                return btoa(e)
            }
            static base64DecodeToStr(e) {
                return atob(e)
            }
            static base64Encode(e) {
                return btoa(String.fromCharCode(...e))
            }
            static base64UrlEncode(e) {
                return Uc($c.base64Encode(e))
            }
            static base64Decode(e) {
                return Uint8Array.from(atob(e), e => e.charCodeAt(0))
            }
        }
        class Vc {
            static strToBase64Encode(e) {
                return l.Buffer.from(e).toString("base64")
            }
            static base64DecodeToStr(e) {
                return l.Buffer.from(e, "base64").toString()
            }
            static base64Encode(e) {
                return l.Buffer.from(e).toString("base64")
            }
            static base64UrlEncode(e) {
                return Uc(Vc.base64Encode(e))
            }
            static base64Decode(e) {
                e = l.Buffer.from(e, "base64");
                return new Uint8Array(e.buffer, e.byteOffset, e.byteLength)
            }
        }
        var Kc, qc = void 0 !== l.Buffer ? Vc : $c;
        const Hc = {
                avc1: "video/mp4",
                avc3: "video/mp4",
                dvav: "video/mp4",
                dva1: "video/mp4",
                hev1: "video/mp4",
                hvc1: "video/mp4",
                dvh1: "video/mp4",
                dvhe: "video/mp4"
            },
            jc = {
                mp4a: "audio/mp4",
                "ac-3": "audio/mp4",
                "ec-3": "audio/mp4"
            };

        function Qc(e) {
            const t = O.strToUtf8array(e).subarray(0, 16),
                i = new Uint8Array(16);
            return i.set(t, 16 - t.length), i
        }
        const Wc = {
            getCapabilities: function(e, t) {
                const i = {
                    videoCapabilities: [],
                    audioCapabilities: []
                };
                return e && e.forEach(e => {
                    var t = e.split(".")[0].trim();
                    t in Hc && i.videoCapabilities.push({
                        contentType: Hc[t] + ";codecs=" + e,
                        robustness: ""
                    })
                }), t && t.forEach(e => {
                    var t = e.split(".")[0].trim();
                    t in jc && i.audioCapabilities.push({
                        contentType: jc[t] + ";codecs=" + e,
                        robustness: ""
                    })
                }), i
            },
            changeEndianness: function(e) {
                function t(e, t, i) {
                    var r = e[t];
                    e[t] = e[i], e[i] = r
                }
                t(e, 0, 3), t(e, 1, 2), t(e, 4, 5), t(e, 6, 7)
            },
            getKeyIdBytes: Qc,
            convertDataUriToArrayBytes: function(e) {
                const t = e.split(":");
                let i = null;
                if ("data" === t[0] && 2 === t.length) {
                    const e = t[1].split(";"),
                        r = e[e.length - 1].split(",");
                    if (2 === r.length) {
                        const t = "base64" === r[0],
                            n = r[1];
                        i = t ? (e.splice(-1, 1), qc.base64Decode(n)) : Qc(n)
                    }
                }
                return i
            },
            makeKeyIdsInitData: function(e) {
                e = {
                    kids: e.map(qc.base64UrlEncode)
                };
                return O.strToUtf8array(JSON.stringify(e))
            },
            parsePSSHList: function(e) {
                const i = new DataView(e);
                let r = 0;
                const n = {};
                for (; r < i.buffer.byteLength;) {
                    const e = r,
                        t = i.getUint32(r);
                    r += 4;
                    var s = e + t;
                    if (1886614376 === i.getUint32(r)) {
                        switch (r += 4, i.getUint8(r)) {
                            case 0:
                            case 1:
                                r += 1;
                                break;
                            default:
                                r = s
                        }
                        r += 3;
                        let t = "";
                        for (let e = 0; e < 16; ++e, ++r) switch (t += i.getUint8(r).toString(16), e) {
                            case 4:
                            case 6:
                            case 8:
                            case 10:
                                t += "-"
                        }
                        r += 4, n[t] = i.buffer.slice(e, s)
                    } else r = s
                }
                return n
            }
        };
        let Gc = {};
        class zc {
            constructor(e, t, i, r, n) {
                if (this.method = e, this.uri = t, this.iv = i, this.format = r, this.formatversions = n, this.isEncrypted = this.method && "NONE" !== this.method, this.formatversions && 0 !== this.formatversions.length || (this.formatversions = [1]), this.key = void 0, this.keyId = void 0, this.isEncrypted) {
                    const a = Wc.convertDataUriToArrayBytes(this.uri);
                    if (a) switch (r) {
                        case Fc.keyFormatString: {
                            this.pssh = a;
                            const e = new Uint16Array(a.buffer, a.byteOffset, a.byteLength / 2),
                                t = String.fromCharCode.apply(null, Array.from(e)),
                                i = t.substring(t.indexOf("<"), t.length),
                                r = (new DOMParser).parseFromString(i, "text/xml").getElementsByTagName("KID")[0];
                            if (r) {
                                var s = null;
                                if (s = r.childNodes[0] ? r.childNodes[0].nodeValue : r.getAttribute("VALUE")) {
                                    const t = qc.base64Decode(s).subarray(0, 16);
                                    Wc.changeEndianness(t), this.keyId = t
                                }
                            }
                            break
                        }
                        case Bc.keyFormatString:
                            this.pssh = a, 22 <= a.length && (this.keyId = a.subarray(a.length - 22, a.length - 6));
                            break;
                        default: {
                            let e = a.subarray(0, 16);
                            if (16 !== e.length) {
                                const t = new Uint8Array(16);
                                t.set(e, 16 - e.length), e = t
                            }
                            this.keyId = e;
                            break
                        }
                    }
                    if (!this.keyId || 16 !== this.keyId.byteLength) {
                        let e = Gc[this.uri];
                        if (!e) {
                            const t = Object.keys(Gc).length % Number.MAX_SAFE_INTEGER;
                            e = new Uint8Array(16), new DataView(e.buffer, 12, 4).setUint32(0, t), Gc[this.uri] = e
                        }
                        this.keyId = e
                    }
                }
            }
            get keyTagInfo() {
                var {
                    method: e,
                    isEncrypted: t,
                    uri: i,
                    iv: r,
                    keyId: n,
                    key: s,
                    format: a,
                    formatversions: o
                } = this;
                return {
                    method: e,
                    isEncrypted: t,
                    uri: i,
                    iv: r,
                    keyId: n,
                    key: s,
                    format: a,
                    formatversions: o
                }
            }
            static clearKeyUriToKeyIdMap() {
                Gc = {}
            }
        }(w = Kc = Kc || {}).NONE = "NONE", w.GET_REQUEST_INFO = "GET_REQUEST_INFO", w.GET_CHALLENGE = "GET_CHALLENGE", w.GET_KEY_RESPONSE = "GET_KEY_RESPONSE", w.PROCESS_LICENSE = "PROCESS_LICENSE";
        class Xc {
            constructor(e, t, i, r) {
                this.session = e, this.onkeystatuseschange = t, this.onkeymessage = i, this.logger = r, this.isClosing$ = new yi(!1), this.closed$ = new yi(!1);
                const n = Oc(this.session);
                n.listen("keystatuseschange", this.isClosing$.pipe(ln(e => !0 === e)), this.onkeystatuseschange), n.listen("message", this.closed$.pipe(ln(e => !0 === e)), this.onkeymessage)
            }
            get isClosing() {
                return this.isClosing$.value
            }
            get isClosed() {
                return this.closed$.value
            }
            destroy() {
                this.isClosing$.next(!0);
                const e = this.session;
                return Fr(e.remove().catch(e => {}).then(() => e.close()).catch(e => {})).pipe(Za(() => {
                    this.isClosing$.next(!1), this.closed$.next(!0)
                }), Vs(() => {
                    this.isClosing$.next(!1), this.closed$.next(!0)
                }))
            }
        }
        class Yc {
            constructor(e, t = null) {
                this.decryptdata = e, this._requestState$ = new yi(Kc.NONE), this.destroy$ = new Xt, this.currentObservable = null, this.session = null, this.oldSessions = [], this.session = t
            }
            get requestState() {
                return this._requestState$.value
            }
            get onKeyRequestState$() {
                return this._requestState$
            }
            destroy() {
                this.destroy$.next()
            }
            abort() {
                var e;
                this.requestState !== Kc.NONE && (e = new gc("Aborted", this.decryptdata.uri, 0, $.KeySystemAbort, !0, rc.Abort), this.error(e))
            }
            setKeyRequestState(e) {
                if (this.currentObservable) {
                    const t = new gc(`Unexpected state transition ${this.requestState}->${e}`, this.decryptdata.uri, 0, $.KeySystemUnexpectedStateTransition, !0, rc.InvalidState);
                    this.error(t)
                }
                this._requestState$.next(e);
                const t = new er;
                return e === Kc.NONE ? (t.complete(), this.currentObservable = null) : this.currentObservable = t, t
            }
            resolveState(e, t) {
                if (this.currentObservable)
                    if (e === this.requestState)
                        if (t instanceof Error) this.error(t);
                        else {
                            const e = this.currentObservable;
                            this.currentObservable = null, e.next(t), e.complete()
                        }
                else {
                    const t = new gc(`Unexpected state ${this.requestState} != ${e}`, this.decryptdata.uri, 0, $.KeySystemUnexpectedState, !0, rc.InvalidState);
                    this.error(t)
                }
            }
            error(e) {
                if (this.currentObservable) {
                    const t = this.currentObservable;
                    this.currentObservable = null, t.error(e)
                }
                this.setKeyRequestState(Kc.NONE)
            }
        }

        function Jc(e) {
            return `uri=${le(e.uri)} keyId=${je(e.keyId)}`
        }
        class Zc {
            constructor(e, t, i, r, n, s, a) {
                this.mediaKeys = e, this.systemString = t, this.config = i, this.eventEmitter = r, this.useSingleKeySession = n, this.sessionHandler = s, this.logger = a, this.destroy$ = new Xt, this.setCert = !1, this.certificate$ = new yi(null), this._keyStatusChange$ = new Xt, this.shouldDestroyMediaKeys = !1, this.itemId = "", this.sessions = [], this.keyIdToKeyInfo = {}, this.keyUriToKeyInfo = {}, this.sessionIdToKeyUri = {}, this.onkeystatuseschange = this.handleKeyStatusesChange.bind(this), this.onkeymessage = this.handleKeyMessage.bind(this)
            }
            get keyStatusChange$() {
                return this._keyStatusChange$
            }
            destroy() {
                this.isDestroying = !0, this.destroy$.next();
                for (const e of Object.values(this.keyIdToKeyInfo)) this._abortKeyRequest(e);
                const e = this.sessions.map(e => e.destroy()),
                    t = nn(() => 0 === e.length, Wu, en(e)).pipe(Zs(void 0), Vs(() => {
                        this.mediaKeys = void 0, this.keyIdToKeyInfo = {}, this.keyUriToKeyInfo = {}, this.sessionIdToKeyUri = {}
                    }));
                return zc.clearKeyUriToKeyIdMap(), t
            }
            setServerCertificate(e = null) {
                return this.needsCert ? (e && this.certificate$.next(e), Gu(this.certificate$, e => null != e).pipe(So(1e4)).pipe(La(e => this.setCert ? $i(!0) : !this.setCertSubject || this.setCertSubject.isStopped ? (this.setCertSubject = new er, Fr(this.mediaKeys.setServerCertificate(e)).pipe(Za(e => {
                    e = void 0 === e || e;
                    this.setCert = e, this.setCertSubject.next(e), this.setCertSubject.complete()
                }), Vn(e => (this.setCert = !1, this.setCertSubject.error(e), Wu)), La(() => this.setCertSubject))) : this.setCertSubject), Vn(e => {
                    throw e
                }))) : $i(!0)
            }
            ensureKeyContext(e) {
                var t = e.uri;
                this.keyUriToKeyInfo[t] || (this.keyUriToKeyInfo[t] = new Yc(e));
                const i = this.keyUriToKeyInfo[t];
                if (i.session) return i;
                if (this.useSingleKeySession && 0 < this.sessions.length) return i.session = this.sessions[0].session, i;
                t = this.mediaKeys.createSession();
                return t && this.sessions.push(new Xc(t, this.onkeystatuseschange, this.onkeymessage, this.logger)), i.session = t, i
            }
            startKeyRequest(t) {
                const i = t.uri,
                    r = this.ensureKeyContext(t);
                if (null == r || !r.session) return Vi(new yc("Could not create key session", t.uri, 0, $.KeySystemFailedToCreateSession, this.systemString));
                var e = O.utf8arrayToStr(t.keyId);
                return this.keyIdToKeyInfo[e] = r, en([this.getKeyRequestInfo(r), this.setServerCertificate()]).pipe(hr(e => e[0]), La(e => {
                    var t;
                    return null === (t = this.sessionHandler) || void 0 === t || t.licenseChallengeSubmitted({
                        keyuri: i,
                        keyFormat: this.systemString
                    }), this.generateLicenseChallenge(r, e).pipe(Vn(e => {
                        var t;
                        throw null === (t = this.sessionHandler) || void 0 === t || t.licenseChallengeError({
                            keyuri: i
                        }), e
                    }))
                }), La(e => {
                    var t;
                    return null === (t = this.sessionHandler) || void 0 === t || t.licenseChallengeCreated({
                        keyuri: i,
                        cdmVersion: this.cdmVersion
                    }), this.getKeyRequestResponse(r, e)
                }), La(e => {
                    var t;
                    return null === (t = this.sessionHandler) || void 0 === t || t.licenseResponseSubmitted({
                        keyuri: i
                    }), this.handleParsedKeyResponse(r, e).pipe(Vn(e => {
                        var t;
                        throw null === (t = this.sessionHandler) || void 0 === t || t.licenseResponseError({
                            keyuri: i
                        }), e
                    }))
                }), hr(() => {
                    var e;
                    return null === (e = this.sessionHandler) || void 0 === e || e.licenseResponseProcessed({
                        keyuri: i
                    }), r.setKeyRequestState(Kc.NONE), this.removeSessions(r.decryptdata, !1).subscribe(), t
                }), Vn(e => {
                    throw this.handleKeyExchangeError(r, e), e
                }), Vs(() => {
                    this._abortKeyRequest(r)
                }))
            }
            _abortKeyRequest(e) {
                var t, i;
                e && (i = e.decryptdata.uri, O.utf8arrayToStr(e.decryptdata.keyId), e.requestState !== Kc.NONE && (null === (t = this.sessionHandler) || void 0 === t || t.keyAborted({
                    keyuri: i
                })), e.abort())
            }
            handleKeyExchangeError(e, t) {
                e.error(t), O.utf8arrayToStr(e.decryptdata.keyId)
            }
            updateItemId(e) {
                this.itemId = e
            }
            removeKey(e) {
                return this.removeKeyInternal(e)
            }
            removeKeyInternal(e) {
                const t = this.keyUriToKeyInfo[e.uri];
                if (t && t.session) {
                    var i = t.session;
                    t.abort(), t.destroy();
                    var r = O.utf8arrayToStr(e.keyId);
                    return this.keyIdToKeyInfo[r] = void 0, this.keyUriToKeyInfo[e.uri] = void 0, this.removeSession(i)
                }
            }
            removeSessions(e, t) {
                const i = this.keyUriToKeyInfo[e.uri];
                if (i) {
                    const r = i.oldSessions.map(e => this.removeSession(e));
                    return i.oldSessions = [], nn(() => 0 === r.length, Wu, en(r)).pipe(La(() => t ? this.removeKeyInternal(e) : Wu))
                }
                return Wu
            }
            removeSession(t) {
                const e = this.sessions.findIndex(e => e.session === t),
                    i = this.sessions[e];
                return -1 < e && this.sessions.splice(e, 1), this.sessionIdToKeyUri[t.sessionId] = void 0, i ? i.destroy() : Wu
            }
            getKeyRequestInfo(e) {
                var t = e.decryptdata,
                    i = t.uri,
                    e = e.setKeyRequestState(Kc.GET_REQUEST_INFO);
                return this.eventEmitter.trigger(x.KEY_REQUEST_STARTED, {
                    keyuri: i,
                    decryptdata: t,
                    timestamp: Date.now()
                }), e
            }
            setKeyRequestInfo(e, t) {
                const i = this.keyUriToKeyInfo[e];
                i && i.resolveState(Kc.GET_REQUEST_INFO, t)
            }
            sanitizeRequest(e) {
                return e
            }
            generateLicenseChallengeInternal(t, e, i) {
                const r = t.decryptdata,
                    n = t.session,
                    s = r.uri,
                    a = r.keyId;
                let o;
                var l = t.setKeyRequestState(Kc.GET_CHALLENGE);
                if (n.generateRequestPromise) o = Nr(n.generateRequestPromise, Ti).pipe(La(() => this.generateRequestInitialized(t, "usable" === i)));
                else {
                    const i = this.generateInitData(a, r, e);
                    n.generateRequestPromise = n.generateRequest(i.initDataType, i.initData), o = Nr(n.generateRequestPromise, Ti).pipe(Za(() => {
                        this.sessionIdToKeyUri[n.sessionId] = s
                    }), Vn(e => {
                        throw new yc(e.message, t.decryptdata.uri, 0, $.KeySystemFailedToGenerateLicenseRequest, this.systemString)
                    }))
                }
                return en([l, o]).pipe(hr(e => new Uint8Array(e[0])))
            }
            generateLicenseChallenge(e, t) {
                const i = e.decryptdata,
                    r = e.session,
                    n = i.uri,
                    s = i.keyId;
                let a, o;
                if (O.utf8arrayToStr(i.keyId), e.licenseChallenge && e.resolveState(Kc.GET_CHALLENGE, e.licenseChallenge), t = this.sanitizeRequest(t), e.requestInfo = t, this.sessionId = this.sessionId || t && t.sessionId || this.itemId, this.systemString === Fc.systemStringPrefix) {
                    const e = new Uint8Array(s);
                    Wc.changeEndianness(e), a = r.keyStatuses.get(e)
                } else a = r.keyStatuses.get(s);
                switch (a) {
                    case "status-pending":
                    case "usable":
                    case "expired":
                    case void 0:
                        o = this.generateLicenseChallengeInternal(e, t, a);
                        break;
                    default:
                        o = Vi(new yc(`Bad internal state state=${a}`, n, 0, $.KeySystemUnexpectedState, this.systemString))
                }
                return o
            }
            setParsedResponse(e, t) {
                const i = this.keyUriToKeyInfo[e];
                i && i.resolveState(Kc.GET_KEY_RESPONSE, t)
            }
            handleKeyStatusesChange(e) {
                e.target.keyStatuses.forEach((e, t, i) => {
                    t = new Uint8Array(t);
                    this.systemString === Fc.systemStringPrefix && Wc.changeEndianness(t);
                    t = O.utf8arrayToStr(t), t = this.keyIdToKeyInfo[t];
                    t && this.handleKeyStatusForKey(e, t)
                })
            }
            handleKeyStatusForKey(e, t) {
                if (t) {
                    var i = t.decryptdata,
                        r = i.uri;
                    switch (e) {
                        case "internal-error":
                            this.logger.error(`${this.systemString} internal-error for key ${Jc(i)}`), this._signalError(t, new gc("Got internal error from key system", r, 0, $.KeySystemInternalError, !1, rc.InternalError));
                            break;
                        case "usable":
                            t.requestState === Kc.PROCESS_LICENSE && t.resolveState(Kc.PROCESS_LICENSE, void 0);
                            break;
                        case "output-restricted":
                            this.logger.warn(`${this.systemString} output-restricted for key ${Jc(i)}`), t.session && this.removeSession(t.session).pipe(Va(this.destroy$)).subscribe(), this._signalError(t, new gc("output-restricted", r, 0, $.KeySystemOutputRestricted, !1, rc.OutputRestricted));
                            break;
                        case "expired":
                            this.logger.warn(`${this.systemString} expired for key ${Jc(i)}. Attempting renewal`), this._signalRenewal(t)
                    }
                }
            }
            _scheduleRenewal(e, t) {
                bn(t).pipe(Za(() => this._signalRenewal(e)), Va(fn(e.destroy$, this.destroy$, Gu(e.onKeyRequestState$, e => e === Kc.GET_REQUEST_INFO)))).subscribe()
            }
            _signalRenewal(e) {
                this._keyStatusChange$.next({
                    decryptdata: e.decryptdata,
                    status: "needs-renewal"
                })
            }
            _signalError(e, t) {
                this._keyStatusChange$.next({
                    decryptdata: e.decryptdata,
                    status: "error",
                    error: t
                }), e.error(t)
            }
        }
        const eh = "org.w3.clearkey",
            th = {
                id: "clearkey",
                systemStringPrefix: eh,
                keyFormatString: eh,
                securityLevels: {
                    NONE: 0
                }
            },
            ih = ["clearkey", "fairplaystreaming", "playready", "widevine"],
            rh = {
                initDataTypes: ["keyids", "cenc"]
            };
        var nh, nu = class extends Zc {
            constructor(e, t, i, r, n, s) {
                super(e, t, i, r, !1, n, s)
            }
            static get requestAccessConfig() {
                return rh
            }
            get needsCert() {
                return !1
            }
            getKeyRequestResponse(e, t) {
                return Rc({
                    url: e.decryptdata.uri,
                    xhrSetup: this.config.xhrSetup
                }, {
                    maxLoadTimeMs: 0,
                    maxTimeToFirstByteMs: 0,
                    autoRetry: !1,
                    timeoutRetry: null,
                    errorRetry: null
                }).pipe(hr(([e]) => {
                    e = new Uint8Array(e);
                    return {
                        response: this.parseResponse(t, e)
                    }
                }))
            }
            parseResponse(e, t) {
                t = {
                    kty: "oct",
                    kid: qc.base64UrlEncode(e),
                    k: qc.base64UrlEncode(t)
                };
                return O.strToUtf8array(JSON.stringify({
                    keys: [t]
                }))
            }
            handleParsedKeyResponse(i, e) {
                e = e.response;
                return en([i.setKeyRequestState(Kc.PROCESS_LICENSE), Fr(i.session.update(e)).pipe(Za(() => {
                    var e = i.decryptdata.keyId,
                        e = i.session.keyStatuses.get(e);
                    this.handleKeyStatusForKey(e, i)
                }), Vn(e => {
                    var t = {
                        code: e.code,
                        text: "Failed to update with key response"
                    };
                    throw new yc(e.message, i.decryptdata.uri, e.code, t, this.systemString)
                }))]).pipe(Zs(void 0))
            }
            generateInitData(e) {
                return {
                    initData: Wc.makeKeyIdsInitData([e]),
                    initDataType: "keyids"
                }
            }
            generateRequestInitialized() {
                return Wu
            }
            sanitizeRequest(e) {
                return e
            }
            handleKeyMessage(e) {
                if (!this.isDestroying && "license-request" === e.messageType) {
                    e = new Uint8Array(e.message), e = JSON.parse(O.utf8arrayToStr(e).trim());
                    if (1 === e.kids.length) {
                        const t = qc.base64Decode(e.kids[0]),
                            i = O.utf8arrayToStr(t),
                            r = this.keyIdToKeyInfo[i];
                        r && r.resolveState(Kc.GET_CHALLENGE, t)
                    }
                }
            }
        };
        const sh = {
                initDataTypes: ["cenc"]
            },
            ah = new Uint8Array([148, 206, 134, 251, 7, 255, 79, 67, 173, 184, 147, 210, 250, 150, 140, 162]);
        (iu = nh = nh || {})[iu.CENC = 1667591779] = "CENC", iu[iu.CBCS = 1667392371] = "CBCS";
        class oh extends Zc {
            constructor(e, t, i, r, n, s, a) {
                super(e, t, i, r, n, s, a), this._hasSetRenewal = !1
            }
            static get systemId() {
                return ah
            }
            static get requestAccessConfig() {
                return sh
            }
            get needsCert() {
                return !0
            }
            sanitizeRequest(e) {
                return {
                    assetId: e && e.assetId ? new Uint8Array(e.assetId) : void 0,
                    ssc: e && e.ssc ? new Uint8Array(e.ssc) : void 0,
                    sessionId: e && e.sessionId ? e.sessionId : void 0
                }
            }
            _scheduleRenewal(e, t) {
                this.useSingleKeySession ? this._hasSetRenewal || (this._hasSetRenewal = !0, bn(t).pipe(Za(() => {
                    var e = Object.values(this.keyUriToKeyInfo)[0];
                    e && this._signalRenewal(e)
                }), Vs(() => {
                    this._hasSetRenewal = !1
                }), Va(this.destroy$)).subscribe()) : super._scheduleRenewal(e, t)
            }
            handleParsedKeyResponse(t, e) {
                var i = t.decryptdata.uri,
                    r = e.statusCode,
                    n = e.ckc && 0 !== e.ckc.byteLength ? e.ckc : e.license && 0 !== e.license.byteLength ? e.license : void 0;
                if (0 === r && !n) return Vi(new gc("License request resulted in HTTP Error", i, r, {
                    code: r,
                    text: "HTTP Error"
                }, !0, rc.HttpError));
                if (0 !== r) return Vi(new gc("License server responded with error", i, r, {
                    code: r,
                    text: "Server Error"
                }, !1, rc.LicenseServerError));
                if (!n) return Vi(new gc("License server responded with invalid license", i, r, {
                    code: r,
                    text: "Invalid license"
                }, !1, rc.LicenseServerError));
                const s = e.renewalDate,
                    a = new Date,
                    o = s > a ? s.getTime() - a.getTime() : 0;
                0 < o && this._scheduleRenewal(t, o);
                const l = this.makeProcessLicenseRequestMessage(t, n, o),
                    d = t.session,
                    u = Fr(d.update(l)).pipe(Za(() => {
                        var e = t.decryptdata.keyId,
                            e = d.keyStatuses.get(e);
                        this.handleKeyStatusForKey(e, t)
                    }), Vn(e => {
                        throw new yc(e.message, t.decryptdata.uri, 0, $.KeySystemFailedToUpdateSession, this.systemString)
                    }));
                return en([t.setKeyRequestState(Kc.PROCESS_LICENSE), u]).pipe(Zs(void 0))
            }
            makeKeyRequests(e) {
                const t = [];
                for (const i of e) {
                    const e = i.decryptdata,
                        r = i.requestInfo,
                        n = e.keyId;
                    t.push({
                        keyId: n,
                        assetId: r ? r.assetId : void 0,
                        ssc: r ? r.ssc : void 0,
                        versionList: e.formatversions
                    })
                }
                return t
            }
            getSchemeAndFlags(e) {
                return {
                    scheme: "ISO-23001-7" === e.method ? nh.CENC : nh.CBCS,
                    flags: 0
                }
            }
            generateInitData(e, t, i) {
                var {
                    scheme: r,
                    flags: n
                } = this.getSchemeAndFlags(t), i = this.makeKeyRequests([{
                    decryptdata: t,
                    requestInfo: i
                }]);
                return {
                    initData: this.makeFpsKeySystemInitData(r, n, i),
                    initDataType: "cenc"
                }
            }
            generateRequestInitialized(t, e) {
                tc(`[Keys] challenge create start uri=${le(t.decryptdata.uri)} versions=${JSON.stringify(t.decryptdata.formatversions)}`);
                e = this.makeKeyRequestMessage(t, e);
                return e ? Fr(t.session.update(e)).pipe(Za(() => {
                    t.requestInfo = void 0
                }), Vn(e => {
                    throw tc(`[Keys] ${this.systemString} FAIL: generateRequestInitialized keyuri=${le(t.decryptdata.uri)} message=${e.message}`), new yc(e.message, t.decryptdata.uri, 0, $.KeySystemFailedToGenerateLicenseRenewal, this.systemString)
                })) : Vi(new gc("Unable to generate request using existing keySession", t.decryptdata.uri, 0, $.KeySystemFailedToGenerateLicenseRequest, !0, rc.InvalidState))
            }
            getKeyRequestResponse(e, t) {
                var i = e.decryptdata.uri,
                    e = e.setKeyRequestState(Kc.GET_KEY_RESPONSE);
                return this.eventEmitter.trigger(x.LICENSE_CHALLENGE_CREATED, {
                    keyuri: i,
                    licenseChallenge: t,
                    keysystem: this.systemString
                }), e
            }
            resolveSPCPromise(e, t) {
                e.resolveState(Kc.GET_CHALLENGE, t)
            }
        }
        const lh = {},
            dh = 1919710053;

        function uh(e, t, i) {
            if (!(i + 4 > e.byteLength)) {
                t = t.getUint32(i);
                if (!((i += 4) + t > e.byteLength)) {
                    e = e.slice(i, i + t);
                    return {
                        pos: i += t,
                        data: e
                    }
                }
            }
        }

        function ch(t) {
            const i = {},
                r = new DataView(t.buffer);
            let n = 4;
            const s = r.getUint32(n);
            n += 4;
            for (let e = 0; e < s && n < t.byteLength && !(n + 16 > t.byteLength); ++e) {
                const s = t.slice(n, n + 16);
                if (n += 16, n + 4 > t.byteLength) break;
                var a = uh(t, r, n);
                if (!a) break;
                n = a.pos, i[O.utf8arrayToStr(s)] = a.data
            }
            return i
        }

        function hh(e, t, i, r) {
            var n = r ? r.byteLength : 0;
            return t.setUint32(i, n), n && e.set(r, i + 4), i + (4 + n)
        }

        function ph(e) {
            let t = 4;
            for (const i of e) t += 28 + (i.assetId ? i.assetId.byteLength : 0) + (i.ssc ? i.ssc.byteLength : 0) + (i.versionList ? 4 * i.versionList.length : 0);
            return t
        }

        function fh(e, t, i, r) {
            t.setUint32(i, r.length), i += 4;
            for (const n of r)
                if (e.set(n.keyId, i), i = hh(e, t, i += 16, n.assetId), i = hh(e, t, i, n.ssc), t.setUint32(i, n.versionList ? n.versionList.length : 0), i += 4, n.versionList)
                    for (const e of n.versionList) t.setUint32(i, e), i += 4;
            return i
        }
        class mh extends oh {
            constructor(e, t, i, r, n, s) {
                super(e, t, i, r, void 0 === i.useMultipleKeySessions || !i.useMultipleKeySessions, n, s)
            }
            makeProcessLicenseRequestMessage(e, t, i) {
                t = new Uint8Array(t);
                return function(e) {
                    let t = 0;
                    for (const i of e) t += 24 + i.ckc.byteLength;
                    let i = 0;
                    const r = new Uint8Array(8 + t),
                        n = new DataView(r.buffer);
                    n.setUint32(0, 1667982195), n.setUint32(4, e.length), i += 8;
                    for (const t of e) r.set(t.keyId, i), i += 16, n.setUint32(i, t.expirySec), i += 4, i = hh(r, n, i, t.ckc);
                    return r
                }([{
                    keyId: e.decryptdata.keyId,
                    expirySec: i / 1e3,
                    ckc: t
                }])
            }
            makeFpsKeySystemInitData(e, t, i) {
                i = function(e, t, i) {
                    var r = ph(i);
                    const n = new Uint8Array(8 + r),
                        s = new DataView(n.buffer);
                    return s.setUint32(0, e), s.setUint32(4, 1 << 24 | 16777215 & t), fh(n, s, 8, i), n
                }(e, t, i);
                return ge.pssh(mh.systemId, [], i)
            }
            makeKeyRequestMessage(e) {
                return function(e) {
                    var t = ph(e);
                    const i = new Uint8Array(4 + t),
                        r = new DataView(i.buffer);
                    return r.setUint32(0, 1668442994), fh(i, r, 4, e), i
                }([{
                    keyId: e.decryptdata.keyId,
                    assetId: e.requestInfo ? e.requestInfo.assetId : void 0,
                    ssc: e.requestInfo ? e.requestInfo.ssc : void 0,
                    versionList: e.decryptdata.formatversions
                }])
            }
            handleKeyMessage(e) {
                if (e.message.byteLength < 4) this.logger.warn("Unexpected message");
                else {
                    const t = new Uint8Array(e.message),
                        i = new DataView(e.message),
                        r = i.getUint32(0);
                    if (this.isDestroying && r !== dh) this.logger.warn(`In the middle of destroying, ignore command: ${r.toString(16)}`);
                    else switch (r) {
                        case 1667592820:
                            this.logger.warn("Certificate not set!");
                            break;
                        case 1919837559: {
                            const e = ch(t);
                            for (const t in e)
                                if (Object.prototype.hasOwnProperty.call(e, t)) {
                                    const e = this.keyIdToKeyInfo[t];
                                    e && this._signalRenewal(e)
                                } break
                        }
                        case 1936745331: {
                            const e = ch(t);
                            for (const t in e)
                                if (Object.prototype.hasOwnProperty.call(e, t)) {
                                    const i = this.keyIdToKeyInfo[t],
                                        r = e[t];
                                    i && r && this.resolveSPCPromise(i, r)
                                } break
                        }
                        case dh:
                            this._handleLicenseRelease(t);
                            break;
                        case 1667525993: {
                            const e = uh(t, i, 4);
                            e && (this.cdmVersion = O.utf8arrayToStr(e.data));
                            break
                        }
                        default:
                            this.logger.warn(`Unrecognized command:'0x${r.toString(16)}'`)
                    }
                }
            }
            _handleLicenseRelease(e) {
                const t = {},
                    i = new DataView(e.buffer);
                switch (i.getUint32(4)) {
                    case 1936946288:
                        lh, 0, t[lh.SessionId] = this.sessionId;
                        var r;
                        if (e.byteLength < 12) break;
                        t[lh.APIProvider] = i.getUint32(8) === nh.CENC ? "EC396D13-FB13-4993-9D0D-71518ACF3D6F" : "F19BF03B-7470-41A4-9655-86D078307D59", 0;
                        var n = uh(e, i, 12);
                        if (!n) break;
                        if (r = n.pos, t[lh.MovieID] = O.utf8arrayToStr(n.data), !(n = uh(e, i, r))) break;
                        if (r = n.pos, t[lh.SecureStopSPC] = n.data, !(n = uh(e, i, r))) break;
                        n.pos, t[lh.SessionLifespanSPC] = n.data
                }
                this.eventEmitter.trigger(x.LICENSE_RELEASED, {
                    keysystem: this.systemString,
                    itemId: this.itemId,
                    releaseRecord: t
                })
            }
        }
        ru = mh;
        const gh = {
            fpsd: O.strToUtf8array("fpsd"),
            fpsi: O.strToUtf8array("fpsi"),
            fpsk: O.strToUtf8array("fpsk"),
            fkri: O.strToUtf8array("fkri"),
            fkai: O.strToUtf8array("fkai"),
            fkcx: O.strToUtf8array("fkcx"),
            fkvl: O.strToUtf8array("fkvl")
        };
        t = class extends oh {
            constructor(e, t, i, r, n, s) {
                super(e, t, i, r, !1, n, s), this.sessions = [], this.keyIdToKeyInfo = {}, this.keyUriToKeyInfo = {}, this.sessionIdToKeyUri = {}
            }
            static get needsCert() {
                return !0
            }
            handleKeyExchangeError(e, t) {
                this.removeKey(e.decryptdata).subscribe(), super.handleKeyExchangeError(e, t)
            }
            _abortKeyRequest(e) {
                return !this.isDestroying && e && e.requestState !== Kc.NONE && this.removeKey(e.decryptdata).subscribe(), super._abortKeyRequest(e)
            }
            makeFpsKeySystemInitData(e, t, i) {
                const r = [gh.fpsd, (n = e, e = t, t = new Uint8Array(4), ge.set32(n, t, 0), ge.box(gh.fpsi, new Uint8Array([0, e >> 16 & 255, e >> 8 & 255, 255 & e]), t))];
                var n;
                for (const s of i) r.push(function(t, e, i, r) {
                    const n = [gh.fpsk],
                        s = ge.box(gh.fkri, new Uint8Array([0, 0, 0, 0]), t);
                    if (n.push(s), e && e.byteLength && n.push(ge.box(gh.fkai, e)), i && i.byteLength && n.push(ge.box(gh.fkcx, i)), r && r.length) {
                        const t = new Uint8Array(4 * r.length);
                        let e = 0;
                        for (const i of r) ge.set32(i, t, e), e += 4;
                        n.push(ge.box(gh.fkvl, t))
                    }
                    return ge.box.apply(null, n)
                }(s.keyId, s.assetId, s.ssc, s.versionList));
                i = ge.box.apply(null, r);
                return ge.pssh(oh.systemId, null, i)
            }
            makeKeyRequestMessage(e, t) {
                if (t) return O.strToUtf8array("renew")
            }
            makeProcessLicenseRequestMessage(e, t, i) {
                t = JSON.stringify([{
                    keyID: qc.base64Encode(e.decryptdata.keyId),
                    payload: qc.base64Encode(new Uint8Array(t))
                }]);
                return O.strToUtf8array(t)
            }
            handleKeyMessage(e) {
                const t = e.target,
                    i = t.sessionId,
                    r = e.messageType,
                    n = this.sessionIdToKeyUri[i];
                let s;
                if (n) s = this.keyUriToKeyInfo[n];
                else
                    for (const e of Object.values(this.keyUriToKeyInfo)) e && e.session === t && (s = e);
                if (s) switch (r) {
                    case "license-request": {
                        const t = new Uint8Array(e.message),
                            i = O.utf8arrayToStr(t);
                        try {
                            JSON.parse(i).forEach(e => {
                                var t = qc.base64DecodeToStr(e.keyID),
                                    e = qc.base64Decode(e.payload),
                                    t = this.keyIdToKeyInfo[t];
                                t && this.resolveSPCPromise(t, e)
                            })
                        } catch (e) {
                            this.logger.warn("[Keys] got unexpected license-request format"), this.resolveSPCPromise(s, t)
                        }
                        break
                    }
                    case "license-renewal": {
                        const t = new Uint8Array(e.message);
                        this.resolveSPCPromise(s, t);
                        break
                    }
                    case "license-release":
                        this._handleLicenseRelease(t);
                        break;
                    default:
                        this.logger.warn(`[Keys] Unexpected messageType ${r}`)
                } else this.logger.warn("[Keys] No key associated with session")
            }
            _handleLicenseRelease(e) {
                e.update(O.strToUtf8array("acknowledged")).catch(e => {
                    this.logger.error(`Promise error: ${e.message}`)
                })
            }
        };
        const yh = {
                initDataTypes: ["cenc"]
            },
            vh = new Uint8Array([154, 4, 240, 121, 152, 64, 66, 134, 171, 146, 230, 91, 224, 136, 95, 149]);
        class Sh extends Zc {
            constructor(e, t, i, r, n, s) {
                super(e, t, i, r, !1, n, s), this.shouldDestroyMediaKeys = !0
            }
            static get systemId() {
                return vh
            }
            static get requestAccessConfig() {
                return yh
            }
            get needsCert() {
                return !1
            }
            generateInitData(e, t) {
                t = t.pssh;
                return {
                    initData: ge.pssh(Sh.systemId, [], t),
                    initDataType: "cenc"
                }
            }
            removeKey(e) {
                return super.removeSessions(e, !0)
            }
            ensureKeyContext(e) {
                const t = e.uri,
                    i = this.keyUriToKeyInfo[t];
                return null != i && i.session && (i.oldSessions.push(i.session), i.session = null), super.ensureKeyContext(e)
            }
            getKeyRequestResponse(e, t) {
                var i = e.decryptdata.uri,
                    r = e.setKeyRequestState(Kc.GET_KEY_RESPONSE);
                return this.eventEmitter.trigger(x.LICENSE_CHALLENGE_CREATED, {
                    keyuri: i,
                    licenseChallenge: t,
                    keysystem: this.systemString,
                    keyId: e.decryptdata.keyId
                }), r
            }
            generateRequestInitialized(e) {
                var t = e.licenseChallenge;
                return e.requestInfo = void 0, e.resolveState(Kc.GET_CHALLENGE, t), Wu
            }
            handleParsedKeyResponse(t, e) {
                const i = t.decryptdata.uri,
                    r = e.statusCode;
                if (0 !== r) return Vi(new gc("License server responded with error", i, r, {
                    code: r,
                    text: "Server error"
                }, !1, rc.LicenseServerError));
                if (!e.license || !e.license.byteLength) return Vi(new gc("License server responded with invalid license", i, r, {
                    code: r,
                    text: "Invalid license"
                }, !1, rc.LicenseServerError));
                if (e.renewalDate) {
                    const i = e.renewalDate,
                        r = new Date,
                        n = i > r ? i.getTime() - r.getTime() : 0;
                    0 < n && this._scheduleRenewal(t, n)
                }
                return en([t.setKeyRequestState(Kc.PROCESS_LICENSE), Fr(t.session.update(e.license)).pipe(Za(() => {
                    t.resolveState(Kc.PROCESS_LICENSE, void 0)
                }), Vn(e => {
                    throw this.logger.error(`${this.systemString} FAIL: Failed to update with key response message=${e.message}`), new yc(e.message, t.decryptdata.uri, 0, $.KeySystemFailedToUpdateSession, this.systemString)
                }))]).pipe(Zs(void 0))
            }
            handleKeyMessage(e) {
                if (this.isDestroying) this.logger.warn("In the middle of destroying, ignore key message");
                else {
                    const t = new DOMParser,
                        i = new("utf16" === this.config.playReadyMessageFormat ? Uint16Array : Uint8Array)(e.message.buffer || e.message),
                        r = String.fromCharCode.apply(null, Array.from(i)),
                        n = t.parseFromString(r, "application/xml").getElementsByTagName("PlayReadyKeyMessage")[0];
                    if (n && "LicenseAcquisition" === n.getAttribute("type")) {
                        const s = t.parseFromString(r, "application/xml").getElementsByTagName("Challenge")[0];
                        if (s && "base64encoded" === s.getAttribute("encoding") && 0 !== s.childNodes.length) {
                            const a = qc.base64Decode(s.childNodes[0].nodeValue),
                                o = O.utf8arrayToStr(a),
                                l = t.parseFromString(o, "application/xml").getElementsByTagName("KID")[0];
                            e = null, e = l.childNodes[0] ? l.childNodes[0].nodeValue : l.getAttribute("VALUE"), e = qc.base64Decode(e).subarray(0, 16);
                            Wc.changeEndianness(e);
                            const d = this.keyIdToKeyInfo[O.utf8arrayToStr(e)];
                            d && (d.licenseChallenge = a, d.resolveState(Kc.GET_CHALLENGE, a))
                        } else this.logger.warn(`${this.systemString} wrong challenge format or empty challenge`)
                    } else this.logger.warn(`${this.systemString} unrecognized message ignore it`)
                }
            }
        }
        w = Sh;
        const bh = {
                initDataTypes: ["cenc", "keyids"]
            },
            Th = new Uint8Array([237, 239, 139, 169, 121, 214, 74, 206, 163, 200, 39, 220, 213, 29, 33, 237]),
            Eh = {
                clearkey: th,
                fairplaystreaming: Sc,
                playready: Fc,
                widevine: Bc
            },
            Ih = {
                clearkey: [
                    ["org.w3.clearkey", nu]
                ],
                fairplaystreaming: [
                    ["com.apple.fps.3_0", t],
                    ["com.apple.fps", ru]
                ],
                playready: [
                    ["com.microsoft.playready.recommendation", w]
                ],
                widevine: [
                    ["com.widevine.alpha", class extends Zc {
                        constructor(e, t, i, r, n, s) {
                            super(e, t, i, r, !1, n, s), this.shouldDestroyMediaKeys = !0
                        }
                        static get systemId() {
                            return Th
                        }
                        static get requestAccessConfig() {
                            return bh
                        }
                        get needsCert() {
                            return !0
                        }
                        removeKey(e) {
                            return super.removeSessions(e, !0)
                        }
                        ensureKeyContext(e) {
                            const t = e.uri,
                                i = this.keyUriToKeyInfo[t];
                            return null != i && i.session && (i.oldSessions.push(i.session), i.session = null), super.ensureKeyContext(e)
                        }
                        getKeyRequestResponse(e, t) {
                            var i = e.decryptdata.uri,
                                r = e.setKeyRequestState(Kc.GET_KEY_RESPONSE);
                            return this.eventEmitter.trigger(x.LICENSE_CHALLENGE_CREATED, {
                                keyuri: i,
                                licenseChallenge: t,
                                keysystem: this.systemString,
                                keyId: e.decryptdata.keyId
                            }), r
                        }
                        handleParsedKeyResponse(t, e) {
                            t.licenseChallenge = void 0;
                            const i = t.decryptdata.uri,
                                r = e.statusCode;
                            if (0 !== r) return Vi(new gc("License server responded with error", i, r, {
                                code: r,
                                text: "Server error"
                            }, !1, rc.LicenseServerError));
                            if (!e.license || !e.license.byteLength) return Vi(new gc("License server responded with invalid license", i, r, {
                                code: r,
                                text: "Invalid license"
                            }, !1, rc.LicenseServerError));
                            if (e.renewalDate) {
                                const i = e.renewalDate,
                                    r = new Date,
                                    n = i > r ? i.getTime() - r.getTime() : 0;
                                0 < n && this._scheduleRenewal(t, n)
                            }
                            return en([t.setKeyRequestState(Kc.PROCESS_LICENSE), Fr(t.session.update(e.license)).pipe(Za(() => {
                                var e = t.decryptdata.keyId,
                                    e = t.session.keyStatuses.get(e);
                                this.handleKeyStatusForKey(e, t)
                            }), Vn(e => {
                                throw this.logger.error(`${this.systemString} FAIL: Failed to update with key response code=${e.code} message=${e.message}`), new yc(e.message, t.decryptdata.uri, e.code, {
                                    code: e.code,
                                    text: "Failed to update with key response"
                                }, this.systemString)
                            }))]).pipe(Zs(void 0))
                        }
                        generateInitData(e, t) {
                            return {
                                initData: t.pssh,
                                initDataType: "cenc"
                            }
                        }
                        generateRequestInitialized(e) {
                            var t = e.licenseChallenge;
                            return e.requestInfo = void 0, e.resolveState(Kc.GET_CHALLENGE, t), Wu
                        }
                        handleKeyMessage(i) {
                            if (this.isDestroying) this.logger.warn("In the middle of destroying, ignore key message");
                            else {
                                const r = i.target;
                                let e = null,
                                    t = null;
                                if (r.sessionId in this.sessionIdToKeyUri) e = this.sessionIdToKeyUri[r.sessionId], t = this.keyUriToKeyInfo[e];
                                else
                                    for (const [i, n] of Object.entries(this.keyUriToKeyInfo))
                                        if (n.session === r) {
                                            e = i, t = n;
                                            break
                                        } if (t) switch (i.messageType) {
                                    case "license-request": {
                                        const r = new Uint8Array(i.message);
                                        t.resolveState(Kc.GET_CHALLENGE, r);
                                        break
                                    }
                                } else this.logger.warn(`${this.systemString} empty keyuri and keyInfo`)
                            }
                        }
                    }]
                ]
            },
            wh = th.id;
        class Ah {
            createMediaKeys(t, e, i, r, n) {
                let s = Ah.idToMediaKeysInfoMap[t];
                if (!s) {
                    const a = Wc.getCapabilities(e, i),
                        o = new er;
                    Ah.requestKeySystemAccess(t, a, n, r).pipe(La(function(e) {
                        return Fr((Ah.idToMediaKeysInfoMap[t].keySystemAccess = e).createMediaKeys())
                    }), Za(e => {
                        o.next(e), o.complete()
                    }), Vn(e => (o.error(new yc(`could not initialize key system: ${e.message}`, void 0, 0, $.KeySystemFailedToInitialize, t)), Ii)), Va(Ah.destroy$)).subscribe(), s = Ah.idToMediaKeysInfoMap[t] = {
                        mediaKeys$: o,
                        keySystemAccess: null
                    }
                }
                return s.mediaKeys$
            }
            destroyMediaKeys() {
                Ah.destroy$.next(), Ah.idToMediaKeysInfoMap = {}
            }
            static getKeySystemIdForDecryptData(e) {
                let t;
                if (e) {
                    t = wh;
                    var i = e.format;
                    for (const e of ih) {
                        var r = Eh[e];
                        if ((null == r ? void 0 : r.keyFormatString) === i) {
                            t = e;
                            break
                        }
                    }
                }
                if (!t) throw Error("No matching key system");
                return t
            }
            static requestKeySystemAccess(e, t, i, r) {
                if ("undefined" == typeof navigator || void 0 === navigator.requestMediaKeySystemAccess) return Vi(new yc("navigator undefined", void 0, 0, $.KeySystemUndefinedNavigator, e));
                const n = Ih[e];
                let s = Vi(new yc("no key systems to try", void 0, 0, $.KeySystemNoKeySystemsToTry, e));
                for (const e of n) {
                    const n = e[0],
                        o = e[1],
                        l = (a = i) && "object" == typeof a ? i : o.requestAccessConfig,
                        d = [Object.assign({}, l, t)];
                    s = s.pipe(Vn(() => Ah.requestKeySystemInternal(n, d, r)))
                }
                var a;
                return s
            }
            static requestKeySystemInternal(e, t, i) {
                return Zr(() => Fr(navigator.requestMediaKeySystemAccess(e, t)))
            }
            make(e, t, i, r, n, s) {
                var a = null === (l = Ah.idToMediaKeysInfoMap[e]) || void 0 === l ? void 0 : l.keySystemAccess;
                if (!a) throw new yc(`No keySystemAccess for ${e}`, void 0, 0, $.KeySystemNoKeySystemAccess, e);
                let o;
                var l = Eh[e].systemStringPrefix;
                for (const t of Ih[e])
                    if (t[0] === a.keySystem) {
                        o = t[1];
                        break
                    } if (!o) throw new yc(`No constructor associated with ${e}`, void 0, 0, $.KeySystemNoConstructor, l);
                return new o(t, l, i, r, n, s)
            }
            static get availableKeySystems() {
                return Object.keys(Eh)
            }
            static getKeySystemFormat(e) {
                e = Eh[e];
                return e ? e.keyFormatString : ""
            }
            static getKeySystemSecurityLevel(e) {
                e = Eh[e];
                return e ? e.securityLevels : void 0
            }
        }
        Ah.idToMediaKeysInfoMap = {}, Ah.destroy$ = new Xt;
        const Oh = ["avc1.42E01E"],
            kh = ["mp4a.40.2"];

        function Ch(e, t, i) {
            if (t) {
                if (t instanceof dr) t = new mc("Key request timed out", e, $.KeySystemRequestTimedOut);
                else if (t instanceof yc) {
                    const i = (null == t ? void 0 : t.response) || $.InternalError;
                    t = new gc(t.message, e, 0, i, !1, rc.InternalError, !0)
                }
            } else t = new gc("Unknown error from CDM", e, 0, $.KeySystemCDMUnknownError, !1, rc.InternalError);
            return (t instanceof gc || t instanceof mc) && (t.mediaOptionIds = [...i]), t
        }
        class Dh {
            constructor(e, t, i, r, n, s, a, o = new Ah) {
                this.ksService = e, this.mediaSink = t, this.config = i, this.platformQuery = r, this.eventEmitter = n, this.sessionHandler = s, this.keySystemFactory = o, this.reset$ = new Xt, this.keyRequest$ = new Xt, this.abort$ = new Xt, this.keySystem$ = new yi(null), this._keyStatusChange$ = new Xt, this.protectionData = {}, this.keySystemId = null, this.keyUriToRequest = {}, this.ksQuery = e.getQuery(), this.logger = a.child({
                    name: "eme"
                }), this.config.warmupCdms && this.keySystemFactory.createMediaKeys(Sc.id, Oh, kh, this.logger, void 0).subscribe(), an(r.platformInfo$.pipe(Is((e, t) => e && t && e.requiresCDMAttachOnStart === t.requiresCDMAttachOnStart), La(e => null != e && e.requiresCDMAttachOnStart ? this.attachMediaKeys().pipe(Vn(e => (this.handleKeySystemError(e), Ii))) : Wu), $a(Ii)), this.keyRequest$.pipe(jr(e => e.pipe(Vn(() => Ii)))), this.keySystem$.pipe(La(e => e ? e.keyStatusChange$.pipe(Za(e => {
                    var t = e.decryptdata.uri,
                        i = this.ksQuery.getKeyInfo(t);
                    "needs-renewal" === e.status ? this.ksService.updateKeyRequestState(t, ic.MustRequestResponse, e => e === ic.GotKeyResponse) : (i = Ch(t, e.error, null !== (i = null == i ? void 0 : i.mediaOptionIds) && void 0 !== i ? i : []), this.ksService.setError(t, i)), this._keyStatusChange$.next(e)
                })) : Ii)), this.isKeyCleanupSupported() ? this.mediaSink.mediaQuery.bufferedSegmentsTuple$.pipe(jr(e => {
                    const [t, i] = e, r = new Set;
                    return t.forEach(e => {
                        e = null === (e = null === (e = e.frag) || void 0 === e ? void 0 : e.keyTagInfo) || void 0 === e ? void 0 : e.uri;
                        e && r.add(e)
                    }), i.forEach(e => {
                        e = null === (e = null === (e = e.frag) || void 0 === e ? void 0 : e.keyTagInfo) || void 0 === e ? void 0 : e.uri;
                        e && r.add(e)
                    }), this.handleKeyCleanup(r)
                })) : Wu).pipe(Va(this.reset$)).subscribe()
            }
            get keyStatusChange$() {
                return this._keyStatusChange$
            }
            get keySystem() {
                return this.keySystem$.value
            }
            destroy() {
                this.reset$.next(), this.ksService.removeAll(), this.keySystemId = null;
                const e = this.keySystem;
                let t = Wu;
                return e && (this.keySystem$.next(null), e.shouldDestroyMediaKeys && this.keySystemFactory.destroyMediaKeys(), t = e.destroy()), Mr([t, this.mediaSink.clearMediaKeys()]).pipe(Zs(void 0))
            }
            attachMediaKeys() {
                if (this.keySystem) return Wu;
                var e = this.config.keySystemPreference ? Ah.getKeySystemFormat(this.config.keySystemPreference) : Sc.keyFormatString;
                return this.makeKeySystem(new zc("NONE", null, null, e, [1])).pipe(Zs(void 0))
            }
            isKeyCleanupSupported() {
                return !0 === this.config.useMultipleKeySessions || "widevine" === this.config.keySystemPreference || "playready" === this.config.keySystemPreference
            }
            handleKeyCleanup(i) {
                if (this.ksQuery.getCount() < 6) return Wu;
                const r = performance.now(),
                    e = this.ksQuery.getAll().map(e => {
                        var t = e.keyUri;
                        if (!i.has(t)) {
                            const i = ac(e.decryptdata);
                            if ("AES-128" !== i.method && r > e.minHoldTime) return this._removeKey(t, i)
                        }
                        return Wu
                    });
                return e.length ? en(e).pipe($a(Wu)) : Wu
            }
            _removeKey(e, t) {
                return this.abort$.next(e), this.ksService.removeKey(e), this.keySystem.removeKey(t)
            }
            removeKeysForItems(i) {
                const r = [];
                return al(() => {
                    for (const e of i) {
                        this.ksService.removeAllKeysForItem(e);
                        const i = this.ksQuery.getAll({
                            filterBy: e => 0 === e.itemIds.length
                        });
                        for (const t of i) r.push(this._removeKey(t.keyUri, ac(t.decryptdata)))
                    }
                }), r.length ? en(r).pipe(La(() => Wu)) : Wu
            }
            get availableKeySystems() {
                return Ah.availableKeySystems
            }
            initialize(e) {
                var t = this.protectionData;
                this.protectionData = {};
                var i = this.config.keySystemPreference;
                for (const a of Ah.availableKeySystems) {
                    var r = e[a];
                    if (r)
                        if (i === a) {
                            var n, s = r.certificate,
                                r = r.serverCertUrl ? bu.buildAbsoluteURL(window.location.href, r.serverCertUrl) : void 0;
                            let e;
                            this.protectionData[a] = {
                                serverCertUrl: r,
                                certificate: s
                            }, s ? e = $i({
                                keysystem: a,
                                certificate: s
                            }) : r && (null === (n = null == t ? void 0 : t[a]) || void 0 === n ? void 0 : n.serverCertUrl) !== r && (n = Tu(r) ? this.config.certLoadPolicy.customURL : this.config.certLoadPolicy.default, e = Rc({
                                url: r,
                                xhrSetup: this.config.xhrSetup
                            }, n).pipe(hr(([e]) => ({
                                keysystem: a,
                                certificate: new Uint8Array(e)
                            })))), e && e.pipe(La(e => this.onServerCertificateLoaded(e)), Vn(e => {
                                throw this.logger.error(`Error loading cert: ${e.message}`), this.eventEmitter.trigger(x.INTERNAL_ERROR, {
                                    type: o,
                                    details: "certificateLoadError",
                                    fatal: !1,
                                    handled: !0,
                                    reason: "Error handling cert",
                                    response: $.KeySystemCertificateLoadError,
                                    message: e.message,
                                    name: "certificateLoadError"
                                }), e
                            }), Va(this.reset$)).subscribe()
                        } else this.logger.warn(`Key system ${a} does not match preference ${i}, ignoring`)
                }
            }
            generateRequest(e, t) {
                this.keySystem && this.keySystem.setKeyRequestInfo(e, t)
            }
            setLicenseResponse(e, t) {
                this.keySystem && this.keySystem.setParsedResponse(e, t)
            }
            getKeyFromDecryptData(e, t) {
                if (!e || !e.isEncrypted) return $i(e);
                let i;
                return al(() => {
                    i = this._getKeyFromDecryptData(e, t)
                }), i
            }
            _getKeyFromDecryptData(t, i) {
                let r = null,
                    n = null;
                i && (r = i.itemId, n = i.mediaOptionId);
                const s = t.uri,
                    e = this.ksQuery.getKeyInfo(s);
                if (e && null != i && this.ksService.addMediaOption(s, i), (null == e ? void 0 : e.error) instanceof gc && !1 === e.error.isOkToRetry) return Vi(e.error);
                if (e && e.requestState !== ic.MustRequestResponse) return e.requestState === ic.GotKeyResponse ? $i(ac(e.decryptdata)) : this.keyUriToRequest[s]; {
                    const o = performance.now() + this.config.keyMinHoldTimeBeforeCleanup;
                    let e;
                    this.abort$.next(s), this.ksService.upsertKey({
                        keyUri: s,
                        decryptdata: function(e) {
                            var {
                                method: t,
                                isEncrypted: i,
                                uri: r,
                                format: n,
                                formatversions: s
                            } = e;
                            return {
                                method: t,
                                isEncrypted: i,
                                uri: r,
                                format: n,
                                formatversions: s,
                                ivBuf: null !== (s = null === (s = e.iv) || void 0 === s ? void 0 : s.buffer) && void 0 !== s ? s : null,
                                keyIdBuf: null === (s = e.keyId) || void 0 === s ? void 0 : s.buffer,
                                keyBuf: null === (s = e.key) || void 0 === s ? void 0 : s.buffer,
                                psshBuf: null === (e = e.key) || void 0 === e ? void 0 : e.buffer
                            }
                        }(t),
                        minHoldTime: o,
                        mediaOptionIds: [n],
                        requestState: ic.WaitingForKeyResponse,
                        itemIds: [r]
                    });
                    var a = t.method;
                    switch (a) {
                        case "SAMPLE-AES":
                        case "ISO-23001-7":
                        case "SAMPLE-AES-CTR": {
                            const o = this.config.keyLoadPolicy.customURL;
                            e = this.fetchKeyEME(t).pipe(So(o.maxLoadTimeMs));
                            break
                        }
                        case "AES-128":
                            e = this.fetchKeyHTTP(t.uri, t, this.config.keyLoadPolicy);
                            break;
                        default:
                            return Vi(new V(!1, `Unexpected METHOD attribute ${a}`, $.KeySystemUnexpectedMETHOD))
                    }
                    i = this.keyUriToRequest[s] = e.pipe(hr(e => {
                        var t = e.decryptdata;
                        return this.ksService.updateKeyValue(s, t.key), this.eventEmitter.trigger(x.KEY_LOADED, e), e.decryptdata
                    }), Vn(e => {
                        var t = this.ksQuery.getKeyInfo(s);
                        return e = Ch(s, e, null !== (t = null == t ? void 0 : t.mediaOptionIds) && void 0 !== t ? t : []), this.ksService.setError(s, e), Vi(e)
                    }), Vs(() => {
                        this.ksService.updateKeyRequestState(s, ic.MustRequestResponse, e => e === ic.WaitingForKeyResponse), this.keyUriToRequest[s] = null
                    }), Aa(), Va(fn(this.abort$.pipe(ln(e => e === s)), this.reset$).pipe(Za(e => this.logger.warn(e ? `aborted ${le(e)}` : "got reset")))));
                    return this.keyRequest$.next(i), i
                }
            }
            fetchKeyEME(e) {
                return this.requestKey(e).pipe(hr(e => ({
                    timestamp: performance.now(),
                    keyuri: e.uri,
                    decryptdata: e
                })))
            }
            fetchKeyHTTP(e, t, i) {
                return Dh.fetchKeyHTTP(e, this.config, t, i)
            }
            static fetchKeyHTTP(t, e, i, r) {
                e = {
                    url: t,
                    xhrSetup: e.xhrSetup
                };
                return Rc(e, Lc(e, r)).pipe(hr(([e]) => (i.key = new Uint8Array(e), {
                    decryptdata: i,
                    keyuri: t,
                    timestamp: performance.now()
                })))
            }
            requestKey(t) {
                return this.makeKeySystem(t).pipe(La(e => e.startKeyRequest(t)))
            }
            ensureKeySystem(t) {
                return Zr(() => {
                    if (!this.keySystem && this.keySystemId) {
                        this.keySystem$.next(this.keySystemFactory.make(this.keySystemId, t, this.config, this.eventEmitter, this.sessionHandler, this.logger));
                        var e = this.protectionData && this.protectionData[this.keySystemId];
                        if (e) return this.keySystem.setServerCertificate(e.certificate).pipe(Zs(this.keySystem))
                    }
                    return $i(this.keySystem)
                })
            }
            makeKeySystem(e) {
                return this.ensureMediaKeys(e).pipe(La(e => this.mediaSink.setMediaKeys(e).pipe(La(() => this.ensureKeySystem(e)))))
            }
            ensureMediaKeys(e) {
                var t = Ah.getKeySystemIdForDecryptData(e);
                if (null == this.keySystemId) this.keySystemId = t;
                else if (this.keySystemId !== t) return Vi(new gc(`New key system string does not match existing ${t} !== ${this.keySystemId}`, e.uri, 0, $.KeySystemUnmatchedString, !1, rc.InternalError));
                return this.keySystemFactory.createMediaKeys(this.keySystemId, Oh, kh, this.logger, null === (e = this.platformQuery.platformInfo) || void 0 === e ? void 0 : e.keySystemConfig)
            }
            onServerCertificateLoaded(e) {
                var t = e.keysystem,
                    e = e.certificate;
                return this.protectionData[t].certificate = e, this.keySystem && this.keySystemId === t ? this.keySystem.setServerCertificate(e).pipe(Zs(void 0)) : Wu
            }
            handleKeySystemError(e) {
                e = new yc(e.message, void 0, void 0, $.KeySystemSetupError, void 0);
                this.eventEmitter.trigger(x.INTERNAL_ERROR, e)
            }
        }
        class Mh extends kl {
            constructor(e) {
                super(e)
            }
            getKeyInfo(e) {
                e = this.getEntity(e);
                return e ? Object.assign(Object.assign({}, e), {
                    error: vc(e.error, e.mediaOptionIds)
                }) : null
            }
            getKeyInfo$(e) {
                return this.selectEntity(e).pipe(hr(e => e ? Object.assign(Object.assign({}, e), {
                    error: vc(e.error, e.mediaOptionIds)
                }) : null))
            }
            getKeyRequestState$(e) {
                return this.selectEntity(e, e => null == e ? void 0 : e.requestState)
            }
            getKeyStatus$(e) {
                return this.selectEntity(e, e => null == e ? void 0 : e.status)
            }
            getKeyError$(e) {
                return this.selectEntity(e, e => vc(null == e ? void 0 : e.error, null == e ? void 0 : e.mediaOptionIds)).pipe(wl)
            }
        }
        class xh {
            constructor(e) {
                this.store = e
            }
            getQuery() {
                return new Mh(this.store)
            }
            upsertKey(i) {
                Do("keys.upsert", i.keyUri);
                const r = new Set(i.itemIds.filter(e => null != e)),
                    n = new Set(i.mediaOptionIds.filter(e => null != e));
                this.store.upsert(i.keyUri, e => {
                    const t = Object.assign(Object.assign({}, e), i);
                    if ("itemIds" in e)
                        for (const i of e.itemIds) r.add(i);
                    if (t.itemIds = Array.from(r), "mediaOptionIds" in e)
                        for (const i of e.mediaOptionIds) n.add(i);
                    return t.mediaOptionIds = Array.from(n), t
                }, () => Object.assign(Object.assign({}, i), {
                    itemIds: Array.from(r),
                    mediaOptionIds: Array.from(n)
                }))
            }
            removeKey(e) {
                Do("keys.removeKey", e), this.store.remove(e)
            }
            removeAllKeysForItem(i) {
                Do(`keys.removeAllKeysForItem ${i}`), this.store.update(null, e => {
                    var t = e.itemIds.findIndex(e => e === i);
                    0 <= t && e.itemIds.splice(t, 1)
                })
            }
            removeAll() {
                Do("keys.remove"), this.store.remove()
            }
            updateKeyValue(e, t) {
                Do("keys.updateKeyValue", e), this.store.update(e, e => {
                    null == e.decryptdata.keyBuf && null != t && (e.decryptdata.keyBuf = t.buffer), e.requestState = ic.GotKeyResponse
                })
            }
            updateKeyStatus(e, t) {
                Do(`keys.updateKeyStatus ${t}`, e), this.store.update(e, e => {
                    e.status = t
                })
            }
            updateKeyRequestState(e, t, i) {
                Do(`keys.updateKeyRequestState ${t}`, e), this.store.update(e, e => {
                    i && !i(e.requestState) || (e.requestState = t)
                })
            }
            addMediaOption(e, t) {
                const {
                    itemId: i,
                    mediaOptionId: r
                } = t;
                Do(`keys.addMediaOption itemId: ${i}, mediaOptionId: ${r}`, e), this.store.update(e, e => {
                    null != r && e.mediaOptionIds.every(e => e !== r) && e.mediaOptionIds.push(r), null != i && e.itemIds.every(e => e !== i) && e.itemIds.push(i)
                })
            }
            setError(e, t) {
                var i;
                Do(`keys.setError ${null===(i=null==t?void 0:t.constructor)||void 0===i?void 0:i.name}`, e), this.store.update(e, e => {
                    e.error = vc(t), e.requestState = ic.MustRequestResponse
                })
            }
        }
        const Ph = new class extends fl {
            constructor() {
                super({}, {
                    name: "key-system-store",
                    idKey: "keyUri",
                    producerFn: su
                })
            }
        };
        let Rh = null;

        function Lh(e) {
            let t = e;
            return Nh.hasOwnProperty(e) && (t = Nh[e]), String.fromCharCode(t)
        }

        function _h(t) {
            const i = [];
            for (let e = 0; e < t.length; e++) i.push(t[e].toString(16));
            return i
        }
        const Nh = {
                42: 225,
                92: 233,
                94: 237,
                95: 243,
                96: 250,
                123: 231,
                124: 247,
                125: 209,
                126: 241,
                127: 9608,
                128: 174,
                129: 176,
                130: 189,
                131: 191,
                132: 8482,
                133: 162,
                134: 163,
                135: 9834,
                136: 224,
                137: 32,
                138: 232,
                139: 226,
                140: 234,
                141: 238,
                142: 244,
                143: 251,
                144: 193,
                145: 201,
                146: 211,
                147: 218,
                148: 220,
                149: 252,
                150: 8216,
                151: 161,
                152: 42,
                153: 8217,
                154: 9473,
                155: 169,
                156: 8480,
                157: 8226,
                158: 8220,
                159: 8221,
                160: 192,
                161: 194,
                162: 199,
                163: 200,
                164: 202,
                165: 203,
                166: 235,
                167: 206,
                168: 207,
                169: 239,
                170: 212,
                171: 217,
                172: 249,
                173: 219,
                174: 171,
                175: 187,
                176: 195,
                177: 227,
                178: 205,
                179: 204,
                180: 236,
                181: 210,
                182: 242,
                183: 213,
                184: 245,
                185: 123,
                186: 125,
                187: 92,
                188: 94,
                189: 95,
                190: 124,
                191: 8764,
                192: 196,
                193: 228,
                194: 214,
                195: 246,
                196: 223,
                197: 165,
                198: 164,
                199: 9475,
                200: 197,
                201: 229,
                202: 216,
                203: 248,
                204: 9487,
                205: 9491,
                206: 9495,
                207: 9499
            },
            Fh = 100,
            Bh = {
                17: 1,
                18: 3,
                21: 5,
                22: 7,
                23: 9,
                16: 11,
                19: 12,
                20: 14
            },
            Uh = {
                17: 2,
                18: 4,
                21: 6,
                22: 8,
                23: 10,
                19: 13,
                20: 15
            },
            $h = {
                25: 1,
                26: 3,
                29: 5,
                30: 7,
                31: 9,
                24: 11,
                27: 12,
                28: 14
            },
            Vh = {
                25: 2,
                26: 4,
                29: 6,
                30: 8,
                31: 10,
                27: 13,
                28: 15
            },
            Kh = ["white", "green", "blue", "cyan", "red", "yellow", "magenta", "black", "transparent"],
            qh = {
                verboseFilter: {
                    DATA: 3,
                    DEBUG: 3,
                    INFO: 2,
                    WARNING: 2,
                    TEXT: 1,
                    ERROR: 0
                },
                time: null,
                verboseLevel: 0,
                setTime: function(e) {
                    this.time = e
                },
                log: function(e, t) {
                    var i = this.verboseFilter[e];
                    this.verboseLevel >= i && console.log(this.time + " [" + e + "] " + t)
                }
            };
        class Hh {
            constructor(e, t, i, r, n) {
                this.foreground = e || "white", this.underline = t || !1, this.italics = i || !1, this.background = r || "black", this.flash = n || !1
            }
            reset() {
                this.foreground = "white", this.underline = !1, this.italics = !1, this.background = "black", this.flash = !1
            }
            setStyles(e) {
                Object.assign(this, e)
            }
            isDefault() {
                return "white" === this.foreground && !this.underline && !this.italics && "black" === this.background && !this.flash
            }
            equals(e) {
                return this.foreground === e.foreground && this.underline === e.underline && this.italics === e.italics && this.background === e.background && this.flash === e.flash
            }
            copy(e) {
                this.foreground = e.foreground, this.underline = e.underline, this.italics = e.italics, this.background = e.background, this.flash = e.flash
            }
            toString() {
                return "color=" + this.foreground + ", underline=" + this.underline + ", italics=" + this.italics + ", background=" + this.background + ", flash=" + this.flash
            }
        }
        class jh {
            constructor(e, t, i, r, n, s) {
                this.uchar = e || " ", this.penState = new Hh(t, i, r, n, s)
            }
            reset() {
                this.uchar = " ", this.penState.reset()
            }
            setChar(e, t) {
                this.uchar = e, this.penState.copy(t)
            }
            setPenState(e) {
                this.penState.copy(e)
            }
            equals(e) {
                return this.uchar === e.uchar && this.penState.equals(e.penState)
            }
            copy(e) {
                this.uchar = e.uchar, this.penState.copy(e.penState)
            }
            isEmpty() {
                return " " === this.uchar && this.penState.isDefault()
            }
        }
        class Qh {
            constructor() {
                this.chars = [];
                for (let e = 0; e < Fh; e++) this.chars.push(new jh);
                this.pos = 0, this.currPenState = new Hh
            }
            equals(t) {
                let i = !0;
                for (let e = 0; e < Fh; e++)
                    if (!this.chars[e].equals(t.chars[e])) {
                        i = !1;
                        break
                    } return i
            }
            copy(t) {
                for (let e = 0; e < Fh; e++) this.chars[e].copy(t.chars[e])
            }
            isEmpty() {
                let t = !0;
                for (let e = 0; e < Fh; e++)
                    if (!this.chars[e].isEmpty()) {
                        t = !1;
                        break
                    } return t
            }
            setCursor(e) {
                this.pos !== e && (this.pos = e), this.pos < 0 ? (qh.log("ERROR", "Negative cursor position " + this.pos), this.pos = 0) : this.pos > Fh && (qh.log("ERROR", "Too large cursor position " + this.pos), this.pos = Fh)
            }
            moveCursor(e) {
                var t = this.pos + e;
                if (1 < e)
                    for (let e = this.pos + 1; e < t + 1; e++) this.chars[e].setPenState(this.currPenState);
                this.setCursor(t)
            }
            backSpace() {
                this.moveCursor(-1), this.chars[this.pos].setChar(" ", this.currPenState)
            }
            insertChar(e) {
                144 <= e && this.backSpace();
                var t = Lh(e);
                this.pos >= Fh ? qh.log("ERROR", "Cannot insert " + e.toString(16) + " (" + t + ") at position " + this.pos + ". Skipping it!") : (this.chars[this.pos].setChar(t, this.currPenState), this.moveCursor(1))
            }
            clearFromPos(e) {
                let t;
                for (t = e; t < Fh; t++) this.chars[t].reset()
            }
            clear() {
                this.clearFromPos(0), this.pos = 0, this.currPenState.reset()
            }
            clearToEndOfRow() {
                this.clearFromPos(this.pos)
            }
            getTextString() {
                const t = [];
                let i = !0;
                for (let e = 0; e < Fh; e++) {
                    var r = this.chars[e].uchar;
                    " " !== r && (i = !1), t.push(r)
                }
                return i ? "" : t.join("")
            }
            setPenStyles(e) {
                this.currPenState.setStyles(e), this.chars[this.pos].setPenState(this.currPenState)
            }
        }
        class Wh {
            constructor() {
                this.rows = [];
                for (let e = 0; e < 15; e++) this.rows.push(new Qh);
                this.currRow = 14, this.nrRollUpRows = null, this.reset()
            }
            reset() {
                for (let e = 0; e < 15; e++) this.rows[e].clear();
                this.currRow = 14
            }
            equals(t) {
                let i = !0;
                for (let e = 0; e < 15; e++)
                    if (!this.rows[e].equals(t.rows[e])) {
                        i = !1;
                        break
                    } return i
            }
            copy(t) {
                for (let e = 0; e < 15; e++) this.rows[e].copy(t.rows[e])
            }
            isEmpty() {
                let t = !0;
                for (let e = 0; e < 15; e++)
                    if (!this.rows[e].isEmpty()) {
                        t = !1;
                        break
                    } return t
            }
            backSpace() {
                this.rows[this.currRow].backSpace()
            }
            clearToEndOfRow() {
                this.rows[this.currRow].clearToEndOfRow()
            }
            insertChar(e) {
                this.rows[this.currRow].insertChar(e)
            }
            setPen(e) {
                this.rows[this.currRow].setPenStyles(e)
            }
            moveCursor(e) {
                this.rows[this.currRow].moveCursor(e)
            }
            setCursor(e) {
                qh.log("INFO", "setCursor: " + e), this.rows[this.currRow].setCursor(e)
            }
            setPAC(t) {
                qh.log("INFO", "pacData = " + JSON.stringify(t));
                let i = t.row - 1;
                if (this.nrRollUpRows && i < this.nrRollUpRows - 1 && (i = this.nrRollUpRows - 1), this.nrRollUpRows && this.currRow !== i) {
                    for (let e = 0; e < 15; e++) this.rows[e].clear();
                    const t = this.currRow + 1 - this.nrRollUpRows,
                        r = this.lastOutputScreen;
                    if (r) {
                        const e = r.rows[t].cueStartTime;
                        if (e && e < qh.time)
                            for (let e = 0; e < this.nrRollUpRows; e++) this.rows[i - this.nrRollUpRows + e + 1].copy(r.rows[t + e])
                    }
                }
                this.currRow = i;
                const r = this.rows[this.currRow];
                if (null !== t.indent) {
                    const i = t.indent,
                        e = Math.max(i - 1, 0);
                    r.setCursor(t.indent), t.color = r.chars[e].penState.foreground
                }
                const e = {
                    foreground: t.color,
                    underline: t.underline,
                    italics: t.italics,
                    background: "black",
                    flash: !1
                };
                this.setPen(e)
            }
            setBkgData(e) {
                qh.log("INFO", "bkgData = " + JSON.stringify(e)), this.backSpace(), this.setPen(e), this.insertChar(32)
            }
            setRollUpRows(e) {
                this.nrRollUpRows = e
            }
            rollUp() {
                if (null !== this.nrRollUpRows) {
                    qh.log("INFO", "TEXT " + this.getDisplayText());
                    const e = this.currRow + 1 - this.nrRollUpRows,
                        t = this.rows.splice(e, 1)[0];
                    t.clear(), this.rows.splice(this.currRow, 0, t), qh.log("INFO", "Rolling up")
                } else qh.log("DEBUG", "roll_up but nrRollUpRows not set yet")
            }
            getDisplayText(t) {
                t = t || !1;
                const i = [];
                let e = "",
                    r;
                for (let e = 0; e < 15; e++) {
                    const n = this.rows[e].getTextString();
                    n && (r = e + 1, t ? i.push("Row " + r + ": '" + n + "'") : i.push(n.trim()))
                }
                return 0 < i.length && (e = t ? "[" + i.join(" | ") + "]" : i.join("\n")), e
            }
            getTextAndFormat() {
                return this.rows
            }
        }
        class Gh {
            constructor(e, t) {
                this.chNr = e, this.outputFilter = t, this.mode = null, this.verbose = 0, this.displayedMemory = new Wh, this.nonDisplayedMemory = new Wh, this.lastOutputScreen = new Wh, this.currRollUpRow = this.displayedMemory.rows[14], this.writeScreen = this.displayedMemory, this.mode = null, this.cueStartTime = null
            }
            reset() {
                this.mode = null, this.displayedMemory.reset(), this.nonDisplayedMemory.reset(), this.lastOutputScreen.reset(), this.currRollUpRow = this.displayedMemory.rows[14], this.writeScreen = this.displayedMemory, this.mode = null, this.cueStartTime = null, this.lastCueEndTime = null
            }
            getHandler() {
                return this.outputFilter
            }
            setHandler(e) {
                this.outputFilter = e
            }
            setPAC(e) {
                this.writeScreen.setPAC(e)
            }
            setBkgData(e) {
                this.writeScreen.setBkgData(e)
            }
            setMode(e) {
                e !== this.mode && (this.mode = e, qh.log("INFO", "MODE=" + e), "MODE_POP-ON" === this.mode ? this.writeScreen = this.nonDisplayedMemory : (this.writeScreen = this.displayedMemory, this.writeScreen.reset()), "MODE_ROLL-UP" !== this.mode && (this.displayedMemory.nrRollUpRows = null, this.nonDisplayedMemory.nrRollUpRows = null), this.mode = e)
            }
            insertChars(t) {
                for (let e = 0; e < t.length; e++) this.writeScreen.insertChar(t[e]);
                var e = this.writeScreen === this.displayedMemory ? "DISP" : "NON_DISP";
                qh.log("INFO", e + ": " + this.writeScreen.getDisplayText(!0)), "MODE_PAINT-ON" !== this.mode && "MODE_ROLL-UP" !== this.mode || (qh.log("TEXT", "DISPLAYED: " + this.displayedMemory.getDisplayText(!0)), this.outputDataUpdate())
            }
            ccRCL() {
                qh.log("INFO", "RCL - Resume Caption Loading"), this.setMode("MODE_POP-ON")
            }
            ccBS() {
                qh.log("INFO", "BS - BackSpace"), "MODE_TEXT" !== this.mode && (this.writeScreen.backSpace(), this.writeScreen === this.displayedMemory && this.outputDataUpdate())
            }
            ccAOF() {}
            ccAON() {}
            ccDER() {
                qh.log("INFO", "DER- Delete to End of Row"), this.writeScreen.clearToEndOfRow(), this.outputDataUpdate()
            }
            ccRU(e) {
                qh.log("INFO", "RU(" + e + ") - Roll Up"), this.writeScreen = this.displayedMemory, this.setMode("MODE_ROLL-UP"), this.writeScreen.setRollUpRows(e)
            }
            ccFON() {
                qh.log("INFO", "FON - Flash On"), this.writeScreen.setPen({
                    flash: !0
                })
            }
            ccRDC() {
                qh.log("INFO", "RDC - Resume Direct Captioning"), this.setMode("MODE_PAINT-ON")
            }
            ccTR() {
                qh.log("INFO", "TR"), this.setMode("MODE_TEXT")
            }
            ccRTD() {
                qh.log("INFO", "RTD"), this.setMode("MODE_TEXT")
            }
            ccEDM() {
                qh.log("INFO", "EDM - Erase Displayed Memory"), this.displayedMemory.reset(), this.outputDataUpdate(!0)
            }
            ccCR() {
                qh.log("INFO", "CR - Carriage Return"), this.writeScreen.rollUp(), this.outputDataUpdate(!0)
            }
            ccENM() {
                qh.log("INFO", "ENM - Erase Non-displayed Memory"), this.nonDisplayedMemory.reset()
            }
            ccEOC() {
                var e;
                qh.log("INFO", "EOC - End Of Caption"), "MODE_POP-ON" === this.mode && (e = this.displayedMemory, this.displayedMemory = this.nonDisplayedMemory, this.nonDisplayedMemory = e, this.writeScreen = this.nonDisplayedMemory, qh.log("TEXT", "DISP: " + this.displayedMemory.getDisplayText())), this.outputDataUpdate(!0)
            }
            ccTO(e) {
                qh.log("INFO", "TO(" + e + ") - Tab Offset"), this.writeScreen.moveCursor(e)
            }
            ccMIDROW(e) {
                const t = {
                    flash: !1,
                    underline: !1,
                    italics: !1
                };
                t.underline = e % 2 == 1, t.italics = 46 <= e, t.italics ? t.foreground = "white" : (e = Math.floor(e / 2) - 16, t.foreground = ["white", "green", "blue", "cyan", "red", "yellow", "magenta"][e]), qh.log("INFO", "MIDROW: " + JSON.stringify(t)), this.writeScreen.setPen(t)
            }
            outputDataUpdate(e = !1) {
                var t = qh.time;
                null !== t && this.outputFilter && (this.outputFilter.updateData && this.outputFilter.updateData(t, this.displayedMemory), null !== this.cueStartTime || this.displayedMemory.isEmpty() ? this.displayedMemory.equals(this.lastOutputScreen) || (this.outputFilter.newCue && (this.outputFilter.newCue(this.cueStartTime, t, this.lastOutputScreen), !0 === e && this.outputFilter.dispatchCue && this.outputFilter.dispatchCue()), this.cueStartTime = this.displayedMemory.isEmpty() ? null : t) : this.cueStartTime = t, this.lastOutputScreen.copy(this.displayedMemory))
            }
            cueSplitAtTime(e) {
                this.outputFilter && (this.displayedMemory.isEmpty() || (this.outputFilter.newCue && this.outputFilter.newCue(this.cueStartTime, e, this.displayedMemory), this.cueStartTime = e))
            }
        }
        var zh = class {
            constructor(e = 1, t, i) {
                this.field = e, this.currChNr = -1, this.lastCmdA = null, this.lastCmdB = null, this.channels = [new Gh(1, t), new Gh(2, i)], this.dataCounters = {
                    padding: 0,
                    char: 0,
                    cmd: 0,
                    other: 0
                }
            }
            getHandler(e) {
                return this.channels[e].getHandler()
            }
            setHandler(e, t) {
                this.channels[e].setHandler(t)
            }
            addData(e, t) {
                let i, r, n, s = null;
                qh.setTime(e);
                for (let e = 0; e < t.length; e += 2) r = 127 & t[e], n = 127 & t[e + 1], 16 <= r && r <= 31 && r === this.lastCmdA && n === this.lastCmdB ? (this.lastCmdA = null, this.lastCmdB = null, qh.log("DEBUG", "Repeated command (" + _h([r, n]) + ") is dropped")) : 0 != r || 0 != n ? (qh.log("DATA", "[" + _h([t[e], t[e + 1]]) + "] -> (" + _h([r, n]) + ")"), i = this.parseCmd(r, n), i = i || this.parseMidrow(r, n), i = i || this.parsePAC(r, n), i = i || this.parseBackgroundAttributes(r, n), !i && (s = this.parseChars(r, n), s) && (this.currChNr && 0 <= this.currChNr ? this.channels[this.currChNr - 1].insertChars(s) : qh.log("WARNING", "No channel found yet. TEXT-MODE?")), i ? this.dataCounters.cmd += 2 : s ? this.dataCounters.char += 2 : (this.dataCounters.other += 2, qh.log("WARNING", "Couldn't parse cleaned data " + _h([r, n]) + " orig: " + _h([t[e], t[e + 1]])))) : this.dataCounters.padding += 2
            }
            parseCmd(e, t) {
                var i;
                if (!((20 === e || 21 === e || 28 === e || 29 === e) && 32 <= t && t <= 47 || (23 === e || 31 === e) && 33 <= t && t <= 35)) return !1;
                const r = this.channels[(i = 20 === e || 23 === e ? 1 : 2) - 1];
                return 20 === e || 21 === e || 28 === e || 29 === e ? 32 === t ? r.ccRCL() : 33 === t ? r.ccBS() : 34 === t ? r.ccAOF() : 35 === t ? r.ccAON() : 36 === t ? r.ccDER() : 37 === t ? r.ccRU(2) : 38 === t ? r.ccRU(3) : 39 === t ? r.ccRU(4) : 40 === t ? r.ccFON() : 41 === t ? r.ccRDC() : 42 === t ? r.ccTR() : 43 === t ? r.ccRTD() : 44 === t ? r.ccEDM() : 45 === t ? r.ccCR() : 46 === t ? r.ccENM() : 47 === t && r.ccEOC() : r.ccTO(t - 32), this.lastCmdA = e, this.lastCmdB = t, this.currChNr = i, !0
            }
            parseMidrow(e, t) {
                var i;
                if ((17 === e || 25 === e) && 32 <= t && t <= 47) {
                    if ((i = 17 === e ? 1 : 2) !== this.currChNr) return qh.log("ERROR", "Mismatch channel in midrow parsing"), !1;
                    const r = this.channels[i - 1];
                    return r.insertChars([32]), r.ccMIDROW(t), qh.log("DEBUG", "MIDROW (" + _h([e, t]) + ")"), this.lastCmdA = e, this.lastCmdB = t, !0
                }
                return !1
            }
            parsePAC(e, t) {
                if (!((17 <= e && e <= 23 || 25 <= e && e <= 31) && 64 <= t && t <= 127 || (16 === e || 24 === e) && 64 <= t && t <= 95)) return !1;
                var i = e <= 23 ? 1 : 2,
                    r = (64 <= t && t <= 95 ? 1 == i ? Bh : $h : 1 == i ? Uh : Vh)[e],
                    r = this.interpretPAC(r, t);
                return this.channels[i - 1].setPAC(r), this.lastCmdA = e, this.lastCmdB = t, this.currChNr = i, !0
            }
            interpretPAC(e, t) {
                var i;
                const r = {
                    color: null,
                    italics: !1,
                    indent: null,
                    underline: !1,
                    row: e
                };
                return i = 95 < t ? t - 96 : t - 64, r.underline = 1 == (1 & i), i <= 13 ? r.color = ["white", "green", "blue", "cyan", "red", "yellow", "magenta", "white"][Math.floor(i / 2)] : i <= 15 ? (r.italics = !0, r.color = "white") : r.indent = 4 * Math.floor((i - 16) / 2), r
            }
            parseChars(e, t) {
                let i = null,
                    r = null,
                    n = null;
                var s;
                if (n = 25 <= e ? (i = 2, e - 8) : (i = 1, e), 17 <= n && n <= 19 ? (s = t, s = 17 === n ? t + 80 : 18 === n ? t + 112 : t + 144, qh.log("INFO", "Special char '" + Lh(s) + "' in channel " + i), r = [s], this.lastCmdA = e, this.lastCmdB = t) : 32 <= e && e <= 127 && (r = 0 === t ? [e] : [e, t], this.lastCmdA = null, this.lastCmdB = null), r) {
                    const e = _h(r);
                    qh.log("DEBUG", `Char codes =  ${e.join(",")}`)
                }
                return r
            }
            parseBackgroundAttributes(e, t) {
                let i, r, n;
                return ((16 === e || 24 === e) && 32 <= t && t <= 47 || (23 === e || 31 === e) && 45 <= t && t <= 47) && (i = {
                    underline: !1
                }, 16 === e || 24 === e ? (r = Math.floor((t - 32) / 2), i.background = Kh[r], t % 2 == 1 && (i.background = i.background + "_semi")) : 45 === t ? i.background = "transparent" : (i.foreground = "black", 47 === t && (i.underline = !0)), n = this.channels[(e < 24 ? 1 : 2) - 1], n.setBkgData(i), this.lastCmdA = null, !(this.lastCmdB = null))
            }
            reset() {
                for (let e = 0; e < this.channels.length; e++) this.channels[e] && this.channels[e].reset();
                this.lastCmdA = null, this.lastCmdB = null
            }
            cueSplitAtTime(t) {
                for (let e = 0; e < this.channels.length; e++) this.channels[e] && this.channels[e].cueSplitAtTime(t)
            }
        };
        class Xh {
            constructor(e, t) {
                this.handler = e, this.track = t, this.startTime = null, this.endTime = null, this.screen = null
            }
            dispatchCue() {
                null !== this.startTime && (this.handler.addCues("cc" + this.track, this.startTime, this.endTime, this.screen), this.startTime = null)
            }
            newCue(e, t, i) {
                (null === this.startTime || this.startTime > e) && (this.startTime = e), this.endTime = t, this.screen = i, this.handler.createHTMLCaptionsTrack(this.track)
            }
        }
        var Yh = {},
            iu = {},
            nu = {},
            t = {};
        Object.defineProperty(t, "__esModule", {
            value: !0
        }), t.isValidPercentValue = function(e) {
            return "number" == typeof e && 0 <= e && e <= 100
        }, t.isValidAlignSetting = function(e) {
            return "string" == typeof e && ["start", "center", "end", "left", "right", "middle"].includes(e)
        }, t.isValidDirectionSetting = function(e) {
            return "string" == typeof e && ["", "rl", "lr"].includes(e)
        }, t.isValidLineAndPositionSetting = function(e) {
            return "number" == typeof e || "auto" === e
        }, t.isValidLineAlignSetting = function(e) {
            return "string" == typeof e && ["start", "center", "end"].includes(e)
        }, t.isValidPositionAlignSetting = function(e) {
            return "string" == typeof e && ["line-left", "center", "line-right", "auto", "left", "start", "middle", "end", "right"].includes(e)
        }, t.isValidScrollSetting = function(e) {
            return ["", "up"].includes(e)
        };
        ru = {};
        Object.defineProperty(ru, "__esModule", {
            value: !0
        });
        const Jh = {
                "&amp;": "&",
                "&lt;": "<",
                "&gt;": ">",
                "&lrm;": "",
                "&rlm;": "",
                "&nbsp;": " "
            },
            Zh = {
                c: "span",
                i: "i",
                b: "b",
                u: "u",
                ruby: "ruby",
                rt: "rt",
                v: "span",
                lang: "span"
            },
            ep = {
                v: "title",
                lang: "lang"
            },
            tp = {
                rt: "ruby"
            },
            ip = {
                "text-combine-upright": "-webkit-text-combine:horizontal; text-orientation: mixed;"
            };
        class rp {
            static parseTimeStamp(e) {
                function t(e) {
                    var [t, i, r, e] = e.map(e => e ? parseInt("" + e) : 0);
                    return 3600 * t + 60 * i + r + e / 1e3
                }
                const i = /^(\d+):(\d{2})(:\d{2})?\.(\d{3})/.exec(e);
                return i ? i[3] ? t([i[1], i[2], i[3].substring(1), i[4]]) : 59 < parseInt(i[1]) ? t([i[1], i[2], null, i[4]]) : t([null, i[1], i[2], i[4]]) : null
            }
            static parseContent(s, t, a) {
                let i = t.text;

                function e(e) {
                    return Jh[e]
                }
                const r = s.document.createElement("div"),
                    n = [];
                let o, l, d = r;
                for (; null !== (o = function() {
                        if (!i) return null;
                        var e = (e = /^([^<]*)(<[^>]+>?)?/.exec(i))[1] || e[2];
                        return i = i.substr(e.length), e
                    }());)
                    if ("<" !== o[0]) d.appendChild(s.document.createTextNode(o.replace(/&(amp|lt|gt|lrm|rlm|nbsp);/g, e)));
                    else {
                        if ("/" === o[1]) {
                            n.length && n[n.length - 1] === o.substr(2).replace(">", "") && (n.pop(), d = d.parentNode);
                            continue
                        }
                        const t = rp.parseTimeStamp(o.substr(1, o.length - 2));
                        let e;
                        if (t) {
                            e = s.document.createProcessingInstruction("timestamp", t.toString()), d.appendChild(e);
                            continue
                        }
                        if (!(l = /^<([^.\s/0-9>]+)(\.[^\s\\>]+)?([^>\\]+)?(\\?)>?$/.exec(o))) continue;
                        if (e = function(e, t, i) {
                                var r = Zh[e];
                                if (!r) return null;
                                const n = s.document.createElement(r);
                                if (n.dataset.localName = r, (e = ep[e]) && i && (n[e] = i.trim()), t)
                                    if (a[t]) {
                                        const s = function(e) {
                                            let t = "";
                                            for (const i in e) t += ip[i] || i + ":" + e[i] + ";";
                                            return t
                                        }(a[t]);
                                        n.setAttribute("style", s)
                                    } else console.info(`WebVTT: parseContent: Style referenced, but no style defined for '${t}'!`);
                                return n
                            }(l[1], l[2], l[3]), !e) continue;
                        if (u = d, c = e, tp[c.dataset.localName] && tp[c.dataset.localName] !== u.dataset.localName) continue;
                        n.push(l[1]), d.appendChild(e), d = e
                    } var u, c;
                return r
            }
        }
        ru.default = rp;
        w = e && e.__decorate || function(e, t, i, r) {
            var n, s = arguments.length,
                a = s < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, i) : r;
            if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, i, r);
            else
                for (var o = e.length - 1; 0 <= o; o--)(n = e[o]) && (a = (s < 3 ? n(a) : 3 < s ? n(t, i, a) : n(t, i)) || a);
            return 3 < s && a && Object.defineProperty(t, i, a), a
        };
        Object.defineProperty(nu, "__esModule", {
            value: !0
        });
        const np = t,
            sp = ru;
        w = w([function(e) {
            let t = e;
            return "undefined" != typeof window && null != window.VTTCue && (t = window.VTTCue, t.create = e.create, t.fromJSON = e.fromJSON, t.prototype.toJSON = e.prototype.toJSON), t
        }], w = class {
            constructor(e, t, i) {
                this._id = "", this._pauseOnExit = !1, this._region = null, this._vertical = "", this._snapToLines = !0, this._line = "auto", this._lineAlign = "start", this._position = "auto", this._positionAlign = "auto", this._size = 100, this._align = "center", this.hasBeenReset = !1, this._startTime = e, this._endTime = t, this._text = i
            }
            get id() {
                return this._id
            }
            set id(e) {
                this._id = "" + e
            }
            get pauseOnExit() {
                return this._pauseOnExit
            }
            set pauseOnExit(e) {
                this._pauseOnExit = !!e
            }
            get startTime() {
                return this._startTime
            }
            set startTime(e) {
                if ("number" != typeof e) throw new TypeError(`Start time must be set to a number: ${e}`);
                this._startTime = e, this.hasBeenReset = !0
            }
            get endTime() {
                return this._endTime
            }
            set endTime(e) {
                if ("number" != typeof e) throw new TypeError(`End time must be set to a number: ${e}`);
                this._endTime = e, this.hasBeenReset = !0
            }
            get text() {
                return this._text
            }
            set text(e) {
                this._text = "" + e, this.hasBeenReset = !0
            }
            get region() {
                return this._region
            }
            set region(e) {
                this._region = e, this.hasBeenReset = !0
            }
            get vertical() {
                return this._vertical
            }
            set vertical(e) {
                if (!np.isValidDirectionSetting(e)) throw new SyntaxError(`An invalid or illegal string was specified for vertical: ${e}`);
                this._vertical = e, this.hasBeenReset = !0
            }
            get snapToLines() {
                return this._snapToLines
            }
            set snapToLines(e) {
                this._snapToLines = !!e, this.hasBeenReset = !0
            }
            get line() {
                return this._line
            }
            set line(e) {
                if (!np.isValidLineAndPositionSetting(e)) throw new SyntaxError(`An invalid number or illegal string was specified for line: ${e}`);
                this._line = e, this.hasBeenReset = !0
            }
            get lineAlign() {
                return this._lineAlign
            }
            set lineAlign(e) {
                if (!np.isValidLineAlignSetting(e)) throw new SyntaxError(`An invalid or illegal string was specified for lineAlign: ${e}`);
                this._lineAlign = e, this.hasBeenReset = !0
            }
            get position() {
                return this._position
            }
            set position(e) {
                if (!np.isValidLineAndPositionSetting(e)) throw new Error(`Position must be between 0 and 100 or auto: ${e}`);
                this._position = e, this.hasBeenReset = !0
            }
            get positionAlign() {
                return this._positionAlign
            }
            set positionAlign(e) {
                if (!np.isValidPositionAlignSetting(e)) throw new SyntaxError(`An invalid or illegal string was specified for positionAlign: ${e}`);
                this._positionAlign = e, this.hasBeenReset = !0
            }
            get size() {
                return this._size
            }
            set size(e) {
                if (e < 0 || 100 < e) throw new Error(`Size must be between 0 and 100: ${e}`);
                this._size = e, this.hasBeenReset = !0
            }
            get align() {
                return this._align
            }
            set align(e) {
                if (!np.isValidAlignSetting(e)) throw new SyntaxError(`An invalid or illegal string was specified for align: ${e}`);
                this._align = e, this.hasBeenReset = !0
            }
            getCueAsHTML() {
                return sp.default.parseContent(window, this, {})
            }
            static create(t) {
                if (!t.hasOwnProperty("startTime") || !t.hasOwnProperty("endTime") || !t.hasOwnProperty("text")) throw new Error("You must at least have start time, end time, and text.");
                const i = new this(t.startTime, t.endTime, t.text);
                return Object.keys(t).forEach(e => {
                    i.hasOwnProperty(e) && (i[e] = t[e])
                }), i
            }
            static fromJSON(e) {
                return this.create(JSON.parse(e))
            }
            toJSON() {
                const t = {};
                return Object.keys(this).forEach(e => {
                    this.hasOwnProperty(e) && "getCueAsHTML" !== e && "hasBeenReset" !== e && "displayState" !== e && (t[e] = this[e])
                }), t
            }
        });
        nu.VTTCue = w;
        w = {}, e = e && e.__decorate || function(e, t, i, r) {
            var n, s = arguments.length,
                a = s < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, i) : r;
            if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, i, r);
            else
                for (var o = e.length - 1; 0 <= o; o--)(n = e[o]) && (a = (s < 3 ? n(a) : 3 < s ? n(t, i, a) : n(t, i)) || a);
            return 3 < s && a && Object.defineProperty(t, i, a), a
        };
        Object.defineProperty(w, "__esModule", {
            value: !0
        });
        const ap = t;
        e = e([function(e) {
            let t = e;
            return "undefined" != typeof window && null != window.VTTRegion && (t = window.VTTRegion, t.create = e.create, t.fromJSON = e.fromJSON, t.prototype.toJSON = e.prototype.toJSON), t
        }], e = class {
            constructor() {
                this._id = "", this._lines = 3, this._regionAnchorX = 0, this._regionAnchorY = 100, this._scroll = "", this._viewportAnchorX = 0, this._viewportAnchorY = 100, this._width = 100
            }
            get id() {
                return this._id
            }
            set id(e) {
                if ("string" != typeof e) throw new Error("ID must be a string.");
                this._id = e
            }
            get lines() {
                return this._lines
            }
            set lines(e) {
                if ("number" != typeof e) throw new TypeError("Lines must be set to a number.");
                this._lines = e
            }
            get regionAnchorX() {
                return this._regionAnchorX
            }
            set regionAnchorX(e) {
                if (!ap.isValidPercentValue(e)) throw new TypeError("RegionAnchorX must be between 0 and 100.");
                this._regionAnchorX = e
            }
            get regionAnchorY() {
                return this._regionAnchorY
            }
            set regionAnchorY(e) {
                if (!ap.isValidPercentValue(e)) throw new TypeError("RegionAnchorY must be between 0 and 100.");
                this._regionAnchorY = e
            }
            get scroll() {
                return this._scroll
            }
            set scroll(e) {
                if ("string" == typeof e) {
                    e = e.toLowerCase();
                    if (ap.isValidScrollSetting(e)) return void(this._scroll = e)
                }
                throw new SyntaxError("An invalid or illegal string was specified.")
            }
            get viewportAnchorX() {
                return this._viewportAnchorX
            }
            set viewportAnchorX(e) {
                if (!ap.isValidPercentValue(e)) throw new TypeError("ViewportAnchorX must be between 0 and 100.");
                this._viewportAnchorX = e
            }
            get viewportAnchorY() {
                return this._viewportAnchorY
            }
            set viewportAnchorY(e) {
                if (!ap.isValidPercentValue(e)) throw new TypeError("ViewportAnchorY must be between 0 and 100.");
                this._viewportAnchorY = e
            }
            get width() {
                return this._width
            }
            set width(e) {
                if (!ap.isValidPercentValue(e)) throw new TypeError("Width must be between 0 and 100.");
                this._lines = e
            }
            toJSON() {
                const t = {};
                return Object.keys(this).forEach(e => {
                    this.hasOwnProperty(e) && (t[e] = this[e])
                }), t
            }
            static create(t) {
                const i = new this;
                return Object.keys(t).forEach(e => {
                    i.hasOwnProperty(e) && (i[e] = t[e])
                }), i
            }
            static fromJSON(e) {
                return this.create(JSON.parse(e))
            }
        });
        w.VTTRegion = e, Object.defineProperty(iu, "__esModule", {
            value: !0
        });
        const op = nu;
        iu.VTTCue = op.VTTCue;
        const lp = w;
        iu.VTTRegion = lp.VTTRegion;
        const dp = ru;
        class up extends Error {
            constructor(e, t) {
                super(), this.name = "ParsingError", this.code = "number" == typeof e ? e : e.code, t ? this.message = t : e instanceof up && (this.message = e.message)
            }
        }(iu.ParsingError = up).Errors = {
            BadSignature: new up(0, "Malformed WebVTT signature."),
            BadTimeStamp: new up(1, "Malformed time stamp.")
        };
        class cp {
            constructor() {
                this.values = {}
            }
            set(e, t) {
                this.get(e) || "" === t || (this.values[e] = t)
            }
            get(e, t, i) {
                return "object" == typeof t && "string" == typeof i ? this.has(e) ? this.values[e] : t[i] : this.has(e) ? this.values[e] : t
            }
            has(e) {
                return e in this.values
            }
            alt(t, i, r) {
                for (let e = 0; e < r.length; ++e)
                    if (i === r[e]) {
                        this.set(t, i);
                        break
                    }
            }
            integer(e, t) {
                /^-?\d+$/.test(t) && this.set(e, parseInt(t, 10))
            }
            percent(e, t) {
                if (t.match(/^([\d]{1,3})(\.[\d]*)?%$/)) try {
                    var i = parseFloat(t);
                    if (0 <= i && i <= 100) return this.set(e, i), !0
                } catch (e) {
                    return !1
                }
                return !1
            }
        }
        class hp {
            constructor(e, t, i) {
                this.window = e, this.state = "INITIAL", this.styleCollector = "", this.buffer = "", this.decoder = t || new TextDecoder("utf8"), this.regionList = [], this.onStylesParsedCallback = i, this._styles = {}
            }
            static StringDecoder() {
                return {
                    decode: e => {
                        if (!e) return "";
                        if ("string" != typeof e) throw new Error("Error - expected string data.");
                        return decodeURIComponent(encodeURIComponent(e))
                    }
                }
            }
            reportOrThrowError(e) {
                if (!(e instanceof up && "function" == typeof this.onparsingerror)) throw e;
                this.onparsingerror(e)
            }
            parseOptions(e, t, i, r) {
                e = r ? e.split(r) : [e];
                for (const n of e)
                    if ("string" == typeof n) {
                        const r = n.split(i);
                        2 === r.length && t(r[0], r[1])
                    }
            }
            parseCue(t, e, a) {
                const i = t,
                    r = () => {
                        var e = dp.default.parseTimeStamp(t);
                        if (null === e) throw new up(up.Errors.BadTimeStamp, "Malformed timestamp: " + i);
                        return t = t.replace(/^[^\sa-zA-Z-]+/, ""), e
                    },
                    n = () => {
                        t = t.replace(/^\s+/, "")
                    };
                if (n(), e.startTime = r(), n(), "--\x3e" !== t.substr(0, 3)) throw new up(up.Errors.BadTimeStamp, `Malformed time stamp (time stamps must be separated by '--\x3e'): ${i}`);
                t = t.substr(3), n(), e.endTime = r(), n(), ((e, t) => {
                    const s = new cp;
                    this.parseOptions(e, (t, i) => {
                        let e, r;
                        switch (t) {
                            case "region":
                                for (let e = a.length - 1; 0 <= e; e--)
                                    if (a[e].id === i) {
                                        s.set(t, a[e].region);
                                        break
                                    } break;
                            case "vertical":
                                s.alt(t, i, ["rl", "lr"]);
                                break;
                            case "line":
                                e = i.split(","), r = e[0], s.integer(t, r), s.percent(t, r) && s.set("snapToLines", !1), s.alt(t, r, ["auto"]), 2 === e.length && s.alt("lineAlign", e[1], ["start", "center", "end"]);
                                break;
                            case "position":
                                e = i.split(","), s.percent(t, e[0]), 2 === e.length && (n = ["line-left", "line-right", "center", "auto", "left", "start", "middle", "end", "right"], s.alt("positionAlign", e[1], n));
                                break;
                            case "size":
                                s.percent(t, i);
                                break;
                            case "align":
                                var n = ["start", "center", "end", "left", "right", "middle"];
                                s.alt(t, i, n)
                        }
                    }, /:/, /\s/), t.region = s.get("region", null), t.vertical = s.get("vertical", ""), t.line = s.get("line", void 0 === t.line ? "auto" : t.line), t.lineAlign = s.get("lineAlign", "start"), t.snapToLines = s.get("snapToLines", !0), t.size = s.get("size", 100);
                    e = s.get("align", "center");
                    t.align = "middle" === e ? "center" : e, t.position = s.get("position", "auto");
                    e = s.get("positionAlign", {
                        start: "start",
                        left: "start",
                        center: "center",
                        right: "end",
                        end: "end"
                    }, t.align);
                    t.positionAlign = {
                        start: "start",
                        "line-left": "start",
                        left: "start",
                        center: "center",
                        middle: "center",
                        "line-right": "end",
                        right: "end",
                        end: "end"
                    } [e]
                })(t, e)
            }
            parseRegion(e) {
                const n = new cp;
                if (this.parseOptions(e, (e, t) => {
                        switch (e) {
                            case "id":
                                n.set(e, t);
                                break;
                            case "width":
                                n.percent(e, t);
                                break;
                            case "lines":
                                n.integer(e, t);
                                break;
                            case "regionanchor":
                            case "viewportanchor": {
                                var i = t.split(",");
                                if (2 !== i.length) break;
                                const r = new cp;
                                if (r.percent("x", i[0]), r.percent("y", i[1]), !r.has("x") || !r.has("y")) break;
                                n.set(e + "X", r.get("x")), n.set(e + "Y", r.get("y"));
                                break
                            }
                            case "scroll":
                                n.alt(e, t, ["up"])
                        }
                    }, /=/, /\s/), n.has("id")) {
                    const e = new lp.VTTRegion;
                    e.width = n.get("width", 100), e.lines = n.get("lines", 3), e.regionAnchorX = n.get("regionanchorX", 0), e.regionAnchorY = n.get("regionanchorY", 100), e.viewportAnchorX = n.get("viewportanchorX", 0), e.viewportAnchorY = n.get("viewportanchorY", 100), e.scroll = n.get("scroll", ""), this.onregion && this.onregion(e), this.regionList.push({
                        id: n.get("id"),
                        region: e
                    })
                }
            }
            parseStyle(i) {
                const e = i.split("}");
                e.pop();
                for (const i of e) {
                    let e = null,
                        t = null;
                    const r = i.split("{");
                    r[0] && (e = r[0].trim()), r[1] && (t = (e => {
                        const t = {},
                            i = e.split(";");
                        for (let e = 0; e < i.length; e++)
                            if (i[e].includes(":")) {
                                const r = i[e].split(":", 2),
                                    n = r[0].trim(),
                                    s = r[1].trim();
                                "" !== n && "" !== s && (t[n] = s)
                            } return t
                    })(r[1])), e && t && (this._styles[e] = t)
                }
                this.onStylesParsedCallback && this.onStylesParsedCallback(this._styles)
            }
            parseHeader(e) {
                this.parseOptions(e, function(e, t) {
                    "Region" === e && this.parseRegion(t)
                }, /:/)
            }
            parse(i) {
                i && (this.buffer += this.decoder.decode(i, {
                    stream: !0
                }));
                const r = () => {
                    const e = this.buffer;
                    let t = 0;
                    let i = {
                        start: e.length,
                        length: 0
                    };
                    for (; t < e.length;) {
                        const r = ((t, i) => {
                            const r = {
                                start: -1,
                                length: -1
                            };
                            if ("\r" === t[i]) r.start = i, r.length = 1;
                            else if ("\n" === t[i]) r.start = i, r.length = 1;
                            else if ("<" === t[i] && i + 1 < t.length && "b" === t[i + 1] && i + 2 < t.length && "r" === t[i + 2]) {
                                let e = i + 2;
                                for (; e < t.length && ">" !== t[e++];);
                                r.start = i, r.length = e - i
                            }
                            return r
                        })(e, t);
                        if (0 < r.length) {
                            i = r;
                            break
                        }++t
                    }
                    const r = e.substr(0, i.start);
                    return this.buffer = e.substr(i.start + i.length), r
                };
                try {
                    let e;
                    if ("INITIAL" === this.state) {
                        if (!/\r\n|\n/.test(this.buffer)) return this;
                        e = r();
                        var n = /^()?WEBVTT([ \t].*)?$/.exec(e);
                        if (!n || !n[0]) throw new up(up.Errors.BadSignature);
                        this.state = "HEADER"
                    }
                    let t = !1;
                    for (; this.buffer;) {
                        if (!/\r\n|\n/.test(this.buffer)) return this;
                        switch (t ? t = !1 : e = r(), this.state) {
                            case "HEADER":
                                e.includes(":") ? this.parseHeader(e) : e || (this.state = "ID");
                                continue;
                            case "NOTE":
                                e || (this.state = "ID");
                                continue;
                            case "STYLE":
                                e ? this.styleCollector += e : (this.parseStyle(this.styleCollector), this.state = "ID", this.styleCollector = "");
                                continue;
                            case "ID":
                                if (/^NOTE($|[ \t])/.test(e)) {
                                    this.state = "NOTE";
                                    break
                                }
                                if (/^STYLE($|[ \t])/.test(e)) {
                                    this.state = "STYLE";
                                    break
                                }
                                if (!e) continue;
                                if (this.cue = new op.VTTCue(0, 0, ""), this.state = "CUE", !e.includes("--\x3e")) {
                                    this.cue.id = e;
                                    continue
                                }
                            case "CUE":
                                try {
                                    this.parseCue(e, this.cue, this.regionList)
                                } catch (i) {
                                    this.reportOrThrowError(i), this.cue = null, this.state = "BADCUE";
                                    continue
                                }
                                this.state = "CUETEXT";
                                continue;
                            case "CUETEXT": {
                                const r = e.includes("--\x3e");
                                if (!e || r) {
                                    t = !0, this.oncue && this.oncue(this.cue), this.cue = null, this.state = "ID";
                                    continue
                                }
                                this.cue.text && (this.cue.text += "\n"), this.cue.text += e;
                                continue
                            }
                            case "BADCUE":
                                e || (this.state = "ID");
                                continue
                        }
                    }
                } catch (i) {
                    this.reportOrThrowError(i), "CUETEXT" === this.state && this.cue && this.oncue && this.oncue(this.cue), this.cue = null, this.state = "INITIAL" === this.state ? "BADWEBVTT" : "BADCUE"
                }
                return this
            }
            flush() {
                try {
                    if (this.buffer += this.decoder.decode(), !this.cue && "HEADER" !== this.state || (this.buffer += "\n\n", this.parse()), "INITIAL" === this.state) throw new up(up.Errors.BadSignature)
                } catch (e) {
                    this.reportOrThrowError(e)
                }
                return this.onflush && this.onflush(), this
            }
            styles() {
                return this._styles
            }
        }
        iu.default = hp, iu.WebVTTParser = hp;
        var pp, w = {};
        Object.defineProperty(w, "__esModule", {
            value: !0
        });
        const fp = nu;
        w.VTTCue = fp.VTTCue;
        const mp = ru,
            gp = [/^(::cue\()(\..*)(\))/, /^(::cue\()(#.*)(\))/, /^(::cue\()(c|i|b|u|ruby|rt|v|lang)(\))/],
            yp = [
                [1470, 1470],
                [1472, 1472],
                [1475, 1475],
                [1478, 1478],
                [1488, 1514],
                [1520, 1524],
                [1544, 1544],
                [1547, 1547],
                [1549, 1549],
                [1563, 1563],
                [1566, 1610],
                [1645, 1647],
                [1649, 1749],
                [1765, 1766],
                [1774, 1775],
                [1786, 1805],
                [1807, 1808],
                [1810, 1839],
                [1869, 1957],
                [1969, 1969],
                [1984, 2026],
                [2036, 2037],
                [2042, 2042],
                [2048, 2069],
                [2074, 2074],
                [2084, 2084],
                [2088, 2088],
                [2096, 2110],
                [2112, 2136],
                [2142, 2142],
                [2208, 2208],
                [2210, 2220],
                [8207, 8207],
                [64285, 64285],
                [64287, 64296],
                [64298, 64310],
                [64312, 64316],
                [64318, 64318],
                [64320, 64321],
                [64323, 64324],
                [64326, 64449],
                [64467, 64829],
                [64848, 64911],
                [64914, 64967],
                [65008, 65020],
                [65136, 65140],
                [65142, 65276],
                [67584, 67589],
                [67592, 67592],
                [67594, 67637],
                [67639, 67640],
                [67644, 67644],
                [67647, 67669],
                [67671, 67679],
                [67840, 67867],
                [67872, 67897],
                [67903, 67903],
                [67968, 68023],
                [68030, 68031],
                [68096, 68096],
                [68112, 68115],
                [68117, 68119],
                [68121, 68147],
                [68160, 68167],
                [68176, 68184],
                [68192, 68223],
                [68352, 68405],
                [68416, 68437],
                [68440, 68466],
                [68472, 68479],
                [68608, 68680],
                [126464, 126467],
                [126469, 126495],
                [126497, 126498],
                [126500, 126500],
                [126503, 126503],
                [126505, 126514],
                [126516, 126519],
                [126521, 126521],
                [126523, 126523],
                [126530, 126530],
                [126535, 126535],
                [126537, 126537],
                [126539, 126539],
                [126541, 126543],
                [126545, 126546],
                [126548, 126548],
                [126551, 126551],
                [126553, 126553],
                [126555, 126555],
                [126557, 126557],
                [126559, 126559],
                [126561, 126562],
                [126564, 126564],
                [126567, 126570],
                [126572, 126578],
                [126580, 126583],
                [126585, 126588],
                [126590, 126590],
                [126592, 126601],
                [126603, 126619],
                [126625, 126627],
                [126629, 126633],
                [126635, 126651],
                [1114109, 1114109]
            ];
        class vp {
            applyStyles(e, t) {
                t = t || this.div;
                for (const i in e) e.hasOwnProperty(i) && (t.style[i] = e[i])
            }
            formatStyle(e, t) {
                return 0 === e ? "0" : e + t
            }
        }
        w.StyleBox = vp;
        class Sp extends vp {
            constructor(e, t, i, r, n) {
                super();
                let s = {
                    textAlign: {
                        start: "left",
                        "line-left": "left",
                        left: "left",
                        center: "center",
                        middle: "center",
                        "line-right": "right",
                        right: "right",
                        end: "right"
                    } [(this.cue = t).positionAlign] || t.align,
                    whiteSpace: "pre-line",
                    position: "absolute"
                };
                s.direction = this.determineBidi(this.cueDiv), s.writingMode = this.directionSettingToWritingMode(t.vertical), s.unicodeBidi = "plaintext", this.div = e.document.createElement("div"), this.applyStyles(s), s = {
                    backgroundColor: r.backgroundColor,
                    display: "inline-block"
                }, this.parseOpacity(s.backgroundColor) && (s.padding = "5px", s.borderRadius = "5px"), this.backgroundDiv = e.document.createElement("div"), this.applyStyles(s, this.backgroundDiv), s = {
                    color: i.color,
                    backgroundColor: i.backgroundColor,
                    textShadow: i.textShadow,
                    fontSize: i.fontSize,
                    fontFamily: i.fontFamily,
                    position: "relative",
                    left: "0",
                    right: "0",
                    top: "0",
                    bottom: "0",
                    display: "inline-block",
                    textOrientation: "upright"
                }, s.writingMode = this.directionSettingToWritingMode(t.vertical), s.unicodeBidi = "plaintext", this.cueDiv = mp.default.parseContent(e, t, n), this.applyStyles(s, this.cueDiv), this.backgroundDiv.appendChild(this.cueDiv), this.div.appendChild(this.backgroundDiv);
                let a = 0;
                if ("number" == typeof t.position) {
                    n = t.positionAlign || t.align;
                    if (n) switch (n) {
                        case "start":
                        case "left":
                            a = t.position;
                            break;
                        case "center":
                        case "middle":
                            a = t.position - t.size / 2;
                            break;
                        case "end":
                        case "right":
                            a = t.position - t.size
                    }
                }
                "" === t.vertical ? this.applyStyles({
                    left: this.formatStyle(a, "%"),
                    width: this.formatStyle(t.size, "%")
                }) : this.applyStyles({
                    top: this.formatStyle(a, "%"),
                    height: this.formatStyle(t.size, "%")
                })
            }
            determineBidi(e) {
                let t = [],
                    i = "";
                if (!e || !e.childNodes) return "ltr";

                function n(t, i) {
                    for (let e = i.childNodes.length - 1; 0 <= e; e--) t.push(i.childNodes[e])
                }
                for (n(t, e); i = function e(t) {
                        if (!t || !t.length) return null;
                        let i = t.pop(),
                            r = i.textContent || i.innerText;
                        if (r) {
                            const i = /^.*(\n|\r)/.exec(r);
                            return i ? i[t.length = 0] : r
                        }
                        return "ruby" === i.tagName ? e(t) : i.childNodes ? (n(t, i), e(t)) : void 0
                    }(t);)
                    for (let e = 0; e < i.length; e++)
                        if (function(e, t) {
                                for (const i of t)
                                    if (e >= i[0] && e <= i[1]) return 1
                            }(i.charCodeAt(e), yp)) return "rtl";
                return "ltr"
            }
            parseOpacity(e) {
                if (!e || "string" != typeof e) return null;
                e = (e = e.replace(/ /g, "").replace("rgba(", "").replace(")", "")).split(",");
                return e && 4 <= e.length ? e[3] : null
            }
            directionSettingToWritingMode(e) {
                return "" === e ? "horizontal-tb" : "lr" === e ? "vertical-lr" : "vertical-rl"
            }
            move(e) {
                this.applyStyles({
                    top: this.formatStyle(e.top, "px"),
                    bottom: this.formatStyle(e.bottom, "px"),
                    left: this.formatStyle(e.left, "px"),
                    right: this.formatStyle(e.right, "px"),
                    height: this.formatStyle(e.height, "px"),
                    width: this.formatStyle(e.width, "px")
                })
            }
        }
        w.CueStyleBox = Sp;
        class bp {
            constructor(e) {
                var t;
                let i, r, n, s, a, o;
                if (e instanceof Sp && e.cue ? (t = e.cue) && "" !== t.vertical ? this.property = "width" : this.property = "height" : e instanceof bp && (this.property = e.property || "height"), e instanceof Sp && e.div) {
                    n = e.div.offsetHeight, s = e.div.offsetWidth, a = e.div.offsetTop;
                    const t = e.div.firstChild;
                    if (o = (t || e.div).getBoundingClientRect(), i = o && o[this.property] || null, t && t.firstChild) {
                        const e = t.firstChild;
                        e && "string" == typeof e.textContent && (r = i / this.calculateNewLines(e.textContent))
                    }
                } else e instanceof bp && (o = e);
                this.left = o.left, this.right = o.right, this.top = o.top || a, this.height = o.height || n, this.bottom = o.bottom || a + (o.height || n), this.width = o.width || s, this.lineHeight = null !== i ? i : o.lineHeight, this.singleLineHeight = null !== r ? r : o.singleLineHeight, this.singleLineHeight || (this.singleLineHeight = 41)
            }
            calculateNewLines(t) {
                let i = 1;
                for (let e = 0; e < t.length; e++) "\n" === t[e] && i++;
                return i
            }
            move(e, t) {
                switch (t = void 0 !== t ? t : this.singleLineHeight, e) {
                    case "+x":
                        this.left += t, this.right += t;
                        break;
                    case "-x":
                        this.left -= t, this.right -= t;
                        break;
                    case "+y":
                        this.top += t, this.bottom += t;
                        break;
                    case "-y":
                        this.top -= t, this.bottom -= t
                }
            }
            overlaps(e) {
                return this.left < e.right && this.right > e.left && this.top < e.bottom && this.bottom > e.top
            }
            overlapsAny(e) {
                for (const t of e)
                    if (this.overlaps(t)) return !0;
                return !1
            }
            within(e) {
                return this.top >= e.top && this.bottom <= e.bottom && this.left >= e.left && this.right <= e.right
            }
            moveIfOutOfBounds(e, t) {
                switch (t) {
                    case "+x":
                        this.left < e.left && (this.left = e.left, this.right = this.left + this.width);
                        break;
                    case "-x":
                        this.right > e.right && (this.right = e.right, this.left = this.right - this.width);
                        break;
                    case "+y":
                        this.top < e.top && (this.top = e.top, this.bottom = this.top + this.height);
                        break;
                    case "-y":
                        this.bottom > e.bottom && (this.bottom = e.bottom, this.top = this.bottom - this.height)
                }
            }
            toCSSCompatValues(e) {
                return {
                    top: this.top - e.top,
                    bottom: e.bottom - this.bottom,
                    left: this.left - e.left,
                    right: e.right - this.right,
                    height: this.height,
                    width: this.width
                }
            }
            static getSimpleBoxPosition(e) {
                let t = null;
                e instanceof vp && e.div ? t = e.div : e instanceof HTMLElement && (t = e);
                let i = t.offsetHeight || 0,
                    r = t.offsetWidth || 0,
                    n = t.offsetTop || 0,
                    s = n + i,
                    a = t.getBoundingClientRect();
                var {
                    left: o,
                    right: e
                } = a;
                return a.top && (n = a.top), a.height && (i = a.height), a.width && (r = a.width), a.bottom && (s = a.bottom), {
                    left: o,
                    right: e,
                    top: n,
                    height: i,
                    bottom: s,
                    width: r
                }
            }
            static getBoxPosition(r, n) {
                if (r && 0 < r.length) {
                    let t = 0,
                        i = r[0][n];
                    for (let e = 0; e < r.length; e++) n in ["top", "right"] ? r[e][n] > i && (t = e, i = r[e][n]) : n in ["bottom", "left"] && r[e][n] < i && (t = e, i = r[e][n]);
                    return r[t]
                }
                return null
            }
            static moveToMinimumDistancePlacement(e, t, i) {
                "height" === e.property ? "+y" === t ? (e.top = i.topMostBoxPosition.bottom + 0, e.bottom = e.top + e.height) : "-y" === t && (e.bottom = +i.bottomMostBoxPosition.top, e.top = e.bottom - e.height) : "width" === e.property && ("+x" === t ? (e.left = i.rightMostBoxPosition.right + 0, e.right = e.left + e.width) : "-x" === t && (e.right = +i.leftMostBoxPosition.left, e.left = e.right - e.width))
            }
            static moveBoxToLinePosition(e, a, o) {
                var n = e.cue;
                let i, r = new bp(e),
                    s = function() {
                        if ("number" == typeof n.line && (n.snapToLines || 0 <= n.line && n.line <= 100)) return n.line;
                        if (!n.track || !n.track.textTrackList || !n.track.textTrackList.mediaElement) return -1;
                        let t = 0;
                        var i = n.track,
                            r = i.textTrackList;
                        for (let e = 0; e < r.length && r[e] !== i; e++) "showing" === r[e].mode && t++;
                        return -1 * ++t
                    }(),
                    l = [];
                if (n.snapToLines) {
                    let t = 0;
                    switch (n.vertical) {
                        case "":
                            l = ["+y", "-y"], i = "height";
                            break;
                        case "rl":
                            l = ["+x", "-x"], i = "width";
                            break;
                        case "lr":
                            l = ["-x", "+x"], i = "width"
                    }
                    const o = r.lineHeight,
                        d = a[i] + o,
                        u = l[0];
                    if (s < 0) {
                        let e = 0;
                        switch (n.vertical) {
                            case "":
                                e = a.height - o - .05 * a.height;
                                break;
                            case "rl":
                            case "lr":
                                e = -a.width + o + .05 * a.width
                        }
                        t = e, l = l.reverse()
                    } else {
                        switch (n.vertical) {
                            case "":
                                t = o * Math.round(s);
                                break;
                            case "rl":
                                t = a.width - o * Math.round(s);
                                break;
                            case "lr":
                                t = o * Math.round(s)
                        }
                        Math.abs(t) > d && (t = t < 0 ? -1 : 1, t *= Math.ceil(d / o) * o)
                    }
                    r.move(u, t)
                } else {
                    const o = "" === n.vertical ? a.height : a.width,
                        i = r.lineHeight / o * 100;
                    switch (n.lineAlign) {
                        case "center":
                            s -= i / 2;
                            break;
                        case "end":
                            s -= i
                    }
                    switch (n.vertical) {
                        case "":
                            e.applyStyles({
                                top: e.formatStyle(s, "%")
                            });
                            break;
                        case "rl":
                            e.applyStyles({
                                right: e.formatStyle(s, "%")
                            });
                            break;
                        case "lr":
                            e.applyStyles({
                                left: e.formatStyle(s, "%")
                            })
                    }
                    l = ["+y", "-y", "+x", "-x"], "+y" === n.axis ? l = ["+y", "-y", "+x", "-x"] : "-y" === n.axis && (l = ["-y", "+y", "+x", "-x"]), r = new bp(e)
                }
                const d = function(r, n) {
                    let s;
                    for (let i = 0; i < n.length; i++) {
                        r.moveIfOutOfBounds(a, n[i]);
                        let e = 0,
                            t = !1;
                        for (; r.overlapsAny(o) && !(9 < e);) t ? r.move(n[i]) : (o && 0 < o.length && (s = s || {
                            topMostBoxPosition: bp.getBoxPosition(o, "top"),
                            bottomMostBoxPosition: bp.getBoxPosition(o, "bottom"),
                            leftMostBoxPosition: bp.getBoxPosition(o, "left"),
                            rightMostBoxPosition: bp.getBoxPosition(o, "right")
                        }, bp.moveToMinimumDistancePlacement(r, n[i], s)), t = !0), e++
                    }
                    return r
                }(r, l);
                e.move(d.toCSSCompatValues(a))
            }
        }
        w.BoxPosition = bp;
        class Tp {
            constructor(e, t, i = !0) {
                if (!e) return null;
                this.window = e, this.overlay = t, this.loggingEnabled = i, this.foregroundStyleOptions = {
                    fontFamily: "Helvetica",
                    fontSize: "36px",
                    color: "rgba(255, 255, 255, 1)",
                    textShadow: "",
                    backgroundColor: "rgba(0, 0, 0, 0)"
                }, this.backgroundStyleOptions = {
                    backgroundColor: "rgba(0, 0, 0, 0.5)"
                }, this.globalStyleCollection = {};
                const r = e.document.createElement("div");
                r.style.position = "absolute", r.style.left = "0", r.style.right = "0", r.style.top = "0", r.style.bottom = "0", r.style.margin = "1.5%", this.paddedOverlay = r, t.appendChild(this.paddedOverlay), this.initSubtitleCSS()
            }
            initSubtitleCSS() {
                var e = [new fp.VTTCue(0, 0, "String to init CSS - Won't be visible to user")];
                this.paddedOverlay.style.opacity = "0", this.processCues(e), this.processCues([]), this.paddedOverlay.style.opacity = "1"
            }
            convertCueToDOMTree(e) {
                return e ? mp.default.parseContent(this.window, e, this.globalStyleCollection) : null
            }
            setStyles(i) {
                function r(e, t, i) {
                    for (const r in t) t.hasOwnProperty(r) && (!0 === i && void 0 !== e[r] || !1 === i) && (e[r] = t[r])
                }
                for (const a in i) {
                    let t = !1,
                        e = null;
                    "::cue" === a ? (e = this.foregroundStyleOptions, t = !0) : "::-webkit-media-text-track-display" === a && (e = this.backgroundStyleOptions, t = !0);
                    var n = i[a];
                    if (!0 === t) r(e, n, t);
                    else
                        for (let e = 0; e < gp.length; e++) {
                            var s = gp[e].exec(a);
                            if (s && 4 === s.length) {
                                const i = s[2],
                                    o = {};
                                r(o, n, t), this.globalStyleCollection[i] = o
                            }
                        }
                }
                this.initSubtitleCSS(), this.loggingEnabled && (console.log("WebVTTRenderer setStyles foregroundStyleOptions: " + JSON.stringify(this.foregroundStyleOptions)), console.log("WebVTTRenderer setStyles backgroundStyleOptions: " + JSON.stringify(this.backgroundStyleOptions)), console.log("WebVTTRenderer setStyles globalStyleCollection: " + JSON.stringify(this.globalStyleCollection)))
            }
            processCues(r) {
                if (r) {
                    for (; this.paddedOverlay.firstChild;) this.paddedOverlay.removeChild(this.paddedOverlay.firstChild);
                    if (function(t) {
                            for (let e = 0; e < t.length; e++)
                                if (t[e].hasBeenReset || !t[e].displayState) return 1
                        }(r)) {
                        const n = [],
                            s = bp.getSimpleBoxPosition(this.paddedOverlay);
                        1 < r.length && (r = function(t) {
                            const i = [];
                            let r = 0;
                            for (let e = 0; e < t.length; e++) {
                                var n = t[e];
                                if ("number" != typeof n.line) return t;
                                r += n.line, i.push(n)
                            }
                            return r /= t.length, 50 < r ? (i.forEach(function(e) {
                                e.axis = "-y"
                            }), i.sort((e, t) => t.line - e.line)) : (i.forEach(function(e) {
                                e.axis = "+y"
                            }), i.sort((e, t) => e.line - t.line)), i
                        }(r));
                        for (let i = 0; i < r.length; i++) {
                            let e = r[i],
                                t = new Sp(this.window, e, this.foregroundStyleOptions, this.backgroundStyleOptions, this.globalStyleCollection);
                            this.paddedOverlay.appendChild(t.div), bp.moveBoxToLinePosition(t, s, n), e.displayState = t.div, n.push(bp.getSimpleBoxPosition(t))
                        }
                    } else
                        for (let e = 0; e < r.length; e++) this.paddedOverlay.appendChild(r[e].displayState)
                }
            }
            setSize(e, t) {
                e && (this.overlay.style.width = e + "px"), t && (this.overlay.style.height = t + "px")
            }
            getOverlay() {
                return this.overlay
            }
        }

        function Ep(e) {
            for (var t in e) pp.hasOwnProperty(t) || (pp[t] = e[t])
        }
        w.default = Tp, w.WebVTTRenderer = Tp, pp = Yh, Object.defineProperty(pp, "__esModule", {
            value: !0
        }), Ep(iu), Ep(w);

        function Ip(e, t, i) {
            return e.substr(i || 0, t.length) === t
        }

        function wp(e) {
            let t = 5381,
                i = e.length;
            for (; i;) t = 33 * t ^ e.charCodeAt(--i);
            return (t >>> 0).toString()
        }

        function Ap(e) {
            var t = Math.floor(e),
                i = t + .5,
                r = t + 1;
            return i <= e ? r - e <= e - i ? r : i : i - e <= e - t ? i : t
        }

        function Op(e, t = 0, i = 8589934592) {
            if (!Number.isFinite(t)) return e;
            var r = i / 2,
                n = Math.abs(e - t) % i;
            return t + (t < e ? -1 : 1) * (r < n ? i - n : -n)
        }
        var kp, Cp, Dp, Mp = function(e, t, i, r, n, s, a, o) {
                const l = O.utf8arrayToStr(new Uint8Array(e)).trim().replace(/\r\n|\n\r|\n|\r/g, "\n").split("\n"),
                    d = {
                        baseTime: Math.floor(9e4 * t.baseTime / t.timescale),
                        timescale: 9e4
                    };
                let u = 0,
                    c = 0;
                const h = [];
                let p = null,
                    f = !0;
                const m = new Yh.WebVTTParser(window, Yh.WebVTTParser.StringDecoder(), a);
                m.oncue = function(e) {
                    var t = S({
                        baseTime: Op(Op(u) - d.baseTime, 9e4 * i),
                        timescale: 9e4
                    });
                    e.startTime = Op(e.startTime + t - c, 0, 95443.7176888889), e.endTime = Op(e.endTime + t - c, 0, 95443.7176888889), e.id = wp(Ap(e.startTime).toString()) + wp(Ap(e.endTime - e.startTime).toString()) + wp(e.text), e.text = decodeURIComponent(encodeURIComponent(e.text)), 0 < e.endTime && h.push(e)
                }, m.onparsingerror = function(e) {
                    p = e
                }, m.onflush = function() {
                    p && s ? s(p) : n(h)
                }, l.forEach(a => f && Ip(a, "X-TIMESTAMP-MAP=") ? (f = !1, void a.substr(16).split(",").forEach(e => {
                    if (Ip(e, "LOCAL:")) {
                        let t;
                        try {
                            t = (i = e.substr(6), r = parseInt(i.substr(-3)), n = parseInt(i.substr(-6, 2)), s = parseInt(i.substr(-9, 2)), i = 9 < i.length ? parseInt(i.substr(0, i.indexOf(":"))) : 0, ne(r) && ne(n) && ne(s) && ne(i) ? (r += 1e3 * n, r += 6e4 * s, r += 36e5 * i) : -1)
                        } catch (e) {
                            t = -1
                        } - 1 !== t ? c = t / 1e3 : p = new Error(`Malformed X-TIMESTAMP-MAP: ${a}`)
                    } else Ip(e, "MPEGTS:") && (u = parseInt(e.substr(7)));
                    var i, r, n, s
                })) : void m.parse(a + "\n")), m.flush()
            },
            xp = {
                newCue: function(e, t, i, r, n) {
                    let s, a, o, l, d;
                    var u, c, h = {
                        foreground: !1,
                        background: !1,
                        italics: !1,
                        underline: !1,
                        flash: !1,
                        styleStack: []
                    };
                    for ([u, c] of r.rows.entries())
                        if (a = !0, o = 0, l = "", !c.isEmpty()) {
                            for (let e = 0; e < c.chars.length; e++) c.chars[e].uchar.match(/\s/) && a ? o++ : (l += this.getFormattedChar(c.chars[e], h), a = !1);
                            (c.cueStartTime = t) === i && (i += 1e-4), l = l.trim().replace(/<br(?: \/)?>/gi, "\n"), l += this.closeStyles(h), s = new Yh.VTTCue(t, i, l), 16 <= o ? o-- : o++, d = !navigator.userAgent.match(/Firefox\//) && 7 < u ? u : u + 1, s.snapToLines = !1, s.line = 10 + 5.33 * d, s.align = "left", s.position = this.getPosition(o, n), e.addCue(s)
                        }
                },
                getPosition: function(e, t) {
                    let i = 1.3333333333333333;
                    t && t.offsetWidth && t.offsetHeight && 1.6 <= t.offsetWidth / t.offsetHeight && (i = 1.7777777777777777);
                    let r = 10 + e / 32 * 80,
                        n = 10,
                        s = 90;
                    return 1.7777777777777777 === i && (r = 12.5 + .75 * r, n = 20, s = 80), Math.max(n, Math.min(s, r + (navigator.userAgent.match(/Firefox\//) ? 50 : 0)))
                },
                getRootStyleTag: function(e) {
                    var t = e[0];
                    return "c" === t ? t : e
                },
                closeStyles: function(t) {
                    let i = "";
                    for (let e = t.styleStack.length - 1; 0 <= e; --e) i += "</" + this.getRootStyleTag(t.styleStack[e]) + ">", t.styleStack.pop();
                    return i
                },
                beginStyleAndBalance: function(e, t) {
                    let i = "";
                    return "c" === t[0] && (i += this.closeStyleAndBalance(e, "c")), i += "<" + t + ">", e.styleStack.push(t), i
                },
                closeStyleAndBalance: function(t, i) {
                    var r = t.styleStack.length;
                    let n = 0,
                        s = "";
                    for (let e = r - 1; 0 <= e; --e) {
                        var a = t.styleStack[e],
                            o = this.getRootStyleTag(a);
                        if (i[0] === a[0]) {
                            s += "</" + o + ">", t.styleStack.splice(r - 1 - n);
                            break
                        }
                        "c" === o[0] ? (t.background = "", t.foreground = "", t.flash = !1, s += "</c>") : "u" === o[0] ? (t.underline = !1, s += "</u>") : "i" === o[0] && (t.italics = !1, s += "</i>"), n++
                    }
                    return s
                },
                getFormattedChar: function(e, t) {
                    let i = "",
                        r = e.uchar,
                        n = "";
                    var s = e.penState.foreground !== t.foreground,
                        a = e.penState.background !== t.background,
                        o = e.penState.flash !== t.flash;
                    return (s || a || o) && (n = "." + e.penState.foreground, n += ".bg_" + e.penState.background, e.penState.flash && o && (n += ".blink"), e.penState.foreground || e.penState.background || e.penState.blink ? i += this.beginStyleAndBalance(t, "c" + n) : i += this.closeStyleAndBalance(t, "c"), s && (t.foreground = e.penState.foreground), a && (t.background = e.penState.background), o && (t.flash = e.penState.flash)), e.penState.underline !== t.underline && (i += e.penState.underline ? this.beginStyleAndBalance(t, "u") : this.closeStyleAndBalance(t, "u"), t.underline = e.penState.underline), e.penState.italics !== t.italics && (i += e.penState.italics ? this.beginStyleAndBalance(t, "i") : this.closeStyleAndBalance(t, "i"), t.italics = e.penState.italics), i + r
                }
            };
        (w = kp = kp || {}).CloseEnough = "CloseEnough", w.TooFar = "TooFar", w.Unknown = "Unknown";
        const Pp = e => "cc1" === e || "cc2" === e;

        function Rp(t) {
            const i = [];
            for (let e = 0; e < t.length; e++) {
                var r = t[e];
                ("captions" === r.kind || "subtitles" === r.kind || "metadata" === r.kind && r.customTextTrackCueRenderer) && i.push(r)
            }
            return i
        }

        function Lp(e) {
            if (e && e.cues)
                for (; 0 < e.cues.length;) e.removeCue(e.cues[0])
        }
        class _p extends $t {
            constructor(e, t, i, r) {
                super(e => {
                    const t = Oc(this.hls, this);
                    if (e.add(t.event(x.INLINE_STYLES_PARSED, this.onInlineStylesParsed).pipe(Vs(() => this.destroy())).subscribe()), e.add(bn(0, this.config.trottleCheckInterval).pipe(La(() => (this.checkReadyToLoadNextSubtitleFragment(), Wu))).subscribe()), this.config.nativeTextTrackChangeHandling)
                        if (this.mediaSink.textTracks && "onchange" in this.mediaSink.textTracks) {
                            const t = Oc(this.mediaSink.textTracks, this);
                            e.add(t.event("change", this._onTextTracksChanged).subscribe())
                        } else e.add(bn(0, 500).pipe(La(() => (this._onTextTracksChanged(), Wu))).subscribe())
                }), this.config = t, this.hls = i, this.logger = r.child({
                    name: "legible"
                }), this.mediaSink = e, this.id3Track = e.id3TextTrack, this.enableCaption = !0, this.Cues = xp, this.tracks = [], this.cueRanges = [], this.channelToTrackMap = {}, this.htmlTextTrackMap = new Map, this.lastCueEndTime = 0, this.gotTracks = !1, this.tryAgain$ = new yi(!0), this.needNextSubtitle$ = new yi(!0)
            }
            destroy() {
                Lp(this.textTrack1), Lp(this.textTrack2), this.mediaSink = void 0, this.nativeSubtitleTrackChange$ = void 0
            }
            convertCuesIntoSubtitleFragInfo(t) {
                const i = {};
                if (null != t && 0 < t.length)
                    for (let e = 0; e < t.length; e++) {
                        var r = t[e];
                        if (ne(r.fragSN)) {
                            const n = i[r.fragSN];
                            n ? (n.count++, n.startTime = Math.min(r.startTime, n.startTime), n.endTime = Math.max(r.endTime, n.endTime)) : i[r.fragSN] = {
                                count: 1,
                                startTime: r.startTime,
                                endTime: r.endTime
                            }
                        }
                    }
                return i
            }
            checkReadyToLoadNextSubtitleFragment() {
                let e = !1;
                this.mediaSink.mediaQuery.currentTime >= this.lastCueEndTime - this.config.subtitleLeadTime && (e = !0), this.needNextSubtitle$.next(e)
            }
            checkReadyToLoadNextSubtitleFragment$(e, t) {
                return e.mediaSeqNum === (null === (t = t[0]) || void 0 === t ? void 0 : t.mediaSeqNum) ? $i(!0) : (this.checkReadyToLoadNextSubtitleFragment(), this.needNextSubtitle$)
            }
            getNextFragment(e, t) {
                t = t.mediaSeqNum + 1;
                return t < e.fragments.length ? e.fragments[t - e.startSN] : null
            }
            calculateFragInfoMap(e, t, i, r) {
                var n = this.convertCuesIntoSubtitleFragInfo(t);
                let s = {
                        len: 0,
                        start: e,
                        end: e
                    },
                    a = e,
                    o = e,
                    l = null,
                    d = null;
                for (const t in n)
                    if (Object.prototype.hasOwnProperty.call(n, t)) {
                        var u = Number(t);
                        if (ne(u)) {
                            var c = n[u];
                            if (this.isFragmentCompleteOrEmpty(u, c.count, i))
                                if (u === r.startSN && e < c.startTime && (a = o = s.start = s.end = e = c.startTime), e >= c.startTime && (a === e || ne(l) && 1 < u - l) && (a = o = c.startTime), e >= c.startTime) o = c.endTime, l = u;
                                else {
                                    if (!ne(l) || u - l != 1) {
                                        d = u;
                                        break
                                    }
                                    o = c.endTime, l = u
                                }
                        } else this.logger.warn(`$fragInfoMap has invalid key ${u}`)
                    } return s = {
                    len: o - a,
                    start: a,
                    end: o
                }, {
                    fragInfoMap: n,
                    bufferInfo: s,
                    prevFragSN: l,
                    nextFragSN: d
                }
            }
            findFrags$(t, i) {
                return this.tryAgain$.pipe(ji(tr), La(() => {
                    var e = this.findFragmentsForPosition(this.mediaSink.mediaQuery.currentTime, i, t);
                    return e.foundFrags ? (this.lastCueEndTime = 0, this.needNextSubtitle$.next(!0), $i(e)) : Ii
                }))
            }
            reviewParsedFrag(e, i, r) {
                var n = e.frag,
                    s = e.cueRange,
                    t = i.subtitleBufferInfo,
                    a = i.subtitleParsedInfo,
                    o = this.mediaSink.mediaQuery.currentTime,
                    e = i.foundFrags;
                let l = !0;
                if (n.mediaSeqNum === e[0].mediaSeqNum) {
                    if (!i.timelineEstablished) return kp.TooFar;
                    if (!s) return this.logger.warn(`[subtitle] 1st frag sn ${n.mediaSeqNum} has no cue; details ${r.fragments.length} frags`), kp.Unknown;
                    if (s.startTime < o) {
                        const d = r.fragments,
                            i = n.mediaSeqNum - r.startSN;
                        let e = i,
                            t = s.startTime;
                        for (; e < d.length && (t += d[e].duration, !(t >= o)); ++e);
                        l = e - i + 1 <= this.config.earlyFragTolerance
                    } else if (s.startTime > o && n.mediaSeqNum !== r.startSN) {
                        const d = s.startTime - o,
                            i = t.prevFragSN;
                        l = n.mediaSeqNum === i + 1 && (null === (t = t.fragInfoMap[i]) || void 0 === t ? void 0 : t.count) === (null === (a = a[i]) || void 0 === a ? void 0 : a.count) || d <= this.config.lateTolerance
                    }
                }
                return l ? kp.CloseEnough : kp.TooFar
            }
            isFragmentEmpty(e) {
                return e && !ne(e.startTime) && 0 === e.count
            }
            isFragmentCompleteOrEmpty(e, t, i) {
                e = i ? i[e] : null;
                return (null == e ? void 0 : e.count) === t || this.isFragmentEmpty(e)
            }
            getEarlierFragmentInSameDisco(e, t, i) {
                var r = t.mediaSeqNum - e.startSN - 1;
                if (r < 0 || r > e.fragments.length - 1) return this.logger.error(`[subtitle] getEarlierFragmentInSameDisco index ${r} out of range`), t;
                r = e.fragments[r];
                return r && r.discoSeqNum === t.discoSeqNum && !i[t.mediaSeqNum] ? r : t
            }
            inferSubtitleFragmentForPosition(i, r, t, n, s) {
                let a, o, e, l, d;
                if (ne(n.prevFragSN) && (o = n.prevFragSN - s.startSN, e = t[n.prevFragSN]), ne(n.nextFragSN) && (l = n.nextFragSN - s.startSN, d = t[n.nextFragSN]), ne(o) && 0 <= o && o < s.fragments.length && e) {
                    let t = e.startTime;
                    const n = ne(l) ? l : s.fragments.length;
                    for (let e = o; e < n; ++e) {
                        const l = s.fragments[e];
                        if (!ne(r) || l.discoSeqNum === r) {
                            if (e === n - 1) {
                                a = {
                                    foundFrag: l,
                                    timelineEstablished: !0
                                };
                                break
                            }
                            if (t + l.duration > i && e > o) {
                                a = {
                                    foundFrag: l,
                                    timelineEstablished: !0
                                };
                                break
                            }
                            t += l.duration
                        }
                    }
                } else if (ne(l) && 0 <= l && l < s.fragments.length && d) {
                    let t = d.startTime;
                    for (let e = l - 1; 0 <= e; --e) {
                        const o = s.fragments[e];
                        if (!ne(r) || o.discoSeqNum === r) {
                            if (t <= i) {
                                a = {
                                    foundFrag: o,
                                    timelineEstablished: !0
                                };
                                break
                            }
                            t -= o.duration
                        }
                    }
                } else
                    for (let e = 0; e < s.fragments.length; ++e) {
                        const t = s.fragments[e];
                        if (ne(r) && t.discoSeqNum === r) {
                            a = {
                                foundFrag: t,
                                timelineEstablished: !1
                            };
                            break
                        }
                    }
                return a
            }
            generateFragmentBatch(t, i, e, r, n, s) {
                var a;
                const o = [],
                    l = null == e ? void 0 : e.foundFrag;
                if (!l) return {
                    foundFrags: void 0,
                    subtitleParsedInfo: void 0,
                    subtitleBufferInfo: void 0,
                    timelineEstablished: null == e ? void 0 : e.timelineEstablished
                };
                for (let e = l ? l.mediaSeqNum - s.startSN : s.fragments.length; e < s.fragments.length && o.length < t; ++e) {
                    const t = s.fragments[e];
                    if (t.discoSeqNum === i) {
                        const l = null === (a = n.fragInfoMap[t.mediaSeqNum]) || void 0 === a ? void 0 : a.count;
                        this.isFragmentCompleteOrEmpty(t.mediaSeqNum, null != l ? l : 0, r) || o.push(t)
                    }
                }
                return {
                    foundFrags: o,
                    subtitleParsedInfo: r,
                    subtitleBufferInfo: n,
                    timelineEstablished: null == e ? void 0 : e.timelineEstablished
                }
            }
            findFragmentsForPosition(e, t, i) {
                var r = this.mediaSink.mediaQuery.getParsedSubtitleRecordsForMediaOption(this.selectedTrack.persistentID),
                    n = this.getCuesOfEnabledTrack(this.selectedMediaOption.mediaOptionId, !1),
                    s = this.calculateFragInfoMap(e, n, r, i),
                    n = s.bufferInfo,
                    n = Math.max(e, n.end),
                    n = this.inferSubtitleFragmentForPosition(n, t, r, s, i);
                return this.generateFragmentBatch(1 / 0, t, n, r, s, i)
            }
            get selectedMediaOption() {
                return this.selectedTrack || this._disabledMediaOption
            }
            set selectedMediaOption(e) {
                this.selectedTrack = "groupId" in e ? e : void 0
            }
            get selectedTrack() {
                return this._selectedMediaOption
            }
            set selectedTrack(e) {
                e !== this._selectedMediaOption && (this._selectedMediaOption = e, this.updateTextTrackState())
            }
            getTrack(t) {
                return this._availableMediaOptions.find(e => e.mediaOptionId === t)
            }
            updateTextTrackState() {
                if (this.mediaSink.textTracks) {
                    const i = this.selectedTrack ? this.getExistingHTMLTextTrack(this.selectedTrack) : void 0,
                        r = Rp(this.mediaSink.textTracks);
                    for (let e = 0; e < r.length; e++) {
                        var t = r[e];
                        t === i && "showing" !== r[e].mode ? r[e].mode = "showing" : t !== i && "hidden" !== r[e].mode && (r[e].mode = "hidden")
                    }
                }
            }
            mapHTMLTextTrackIndexToMediaOptionId(e) {
                const i = this.mediaSink.textTracks[e];
                let r;
                return this.htmlTextTrackMap.forEach((e, t) => {
                    i === e && (r = t)
                }), r
            }
            get mediaSelectionOptions() {
                return this._availableMediaOptions
            }
            _makeDisableOption(e) {
                return {
                    itemId: e.itemId,
                    mediaOptionType: e.mediaOptionType,
                    mediaOptionId: "Nah"
                }
            }
            _onTextTracksChanged() {
                if (this.mediaSink) {
                    let t, i = !1;
                    const r = Rp(this.mediaSink.textTracks);
                    for (let e = 0; e < r.length; e++) r[e].seen ? "showing" === r[e].mode && (t = r[e].persistentId) : (r[e].seen = !0, i = !0);
                    if (!i) {
                        const e = this.selectedTrack;
                        if ((null == e ? void 0 : e.persistentID) !== t) {
                            const e = this.mediaSelectionOptions.find(function(e) {
                                return e.persistentID === t
                            });
                            this.nativeSubtitleTrackChange$.next(e || this._disabledMediaOption)
                        }
                    }
                }
            }
            addCues(e, t, i, r) {
                const n = this.cueRanges;
                let s = !1;
                for (let e = n.length; e--;) {
                    const r = n[e],
                        d = (a = r[0], o = r[1], l = t, Math.min(o, i) - Math.max(a, l));
                    if (0 <= d && (r[0] = Math.min(r[0], t), r[1] = Math.max(r[1], i), s = !0, .5 < d / (i - t))) return
                }
                var a, o, l;
                s || n.push([t, i]), this.Cues.newCue(this.channelToTrackMap[e], t, i, r, this.mediaSink)
            }
            getExistingHTMLTextTrackWithChannelNumber(t) {
                var i = this.mediaSink;
                if (i)
                    for (let e = 0; e < i.textTracks.length; e++) {
                        var r = i.textTracks[e],
                            n = "cc" + t;
                        if (Pp(n) && !0 === r[n]) return r
                    }
                return null
            }
            sendAddTrackEvent(e, t) {
                let i = null;
                try {
                    i = new window.Event("addtrack")
                } catch (e) {
                    i = document.createEvent("Event"), i.initEvent("addtrack", !1, !1)
                }
                i.track = e, t.dispatchEvent(i)
            }
            createHTMLCaptionsTrackGuts(e, t, i, r) {
                var n = "cc" + e;
                if (!this.channelToTrackMap[n]) {
                    e = this.getExistingHTMLTextTrackWithChannelNumber(e);
                    if (e) this.channelToTrackMap[n] = e, Lp(this.channelToTrackMap[n]), this.sendAddTrackEvent(this.channelToTrackMap[n], this.mediaSink);
                    else {
                        const s = this.createHTMLTextTrackGuts("captions", t, i, r);
                        s && Pp(n) && (s[n] = !0, this.channelToTrackMap[n] = s)
                    }
                }
                return this.channelToTrackMap[n]
            }
            createHTMLCaptionsTrack(e) {
                return this.createHTMLCaptionsTrackGuts(e, this.config[1 === e ? "captionsTextTrack1Label" : "captionsTextTrack2Label"], this.config.captionsTextTrack1LanguageCode, !1)
            }
            getExistingHTMLTextTrack(e) {
                return this.config.condenseSubtitleTrack ? this.htmlTextTrackMap.get(e.persistentID) : this.htmlTextTrackMap.get(e.id)
            }
            getExistingHTMLTextTrackWithSubtitleTrackId(t) {
                var e = this._availableMediaOptions.find(e => e.id === t);
                return e ? this.getExistingHTMLTextTrack(e) : void 0
            }
            getExistingHTMLTextTrackIndex(e) {
                var t = this.getExistingHTMLTextTrack(e),
                    i = this.mediaSink.textTracks;
                let r = -1;
                for (let e = 0; e < i.length; ++e)
                    if (i[e] === t) {
                        r = e;
                        break
                    } return r
            }
            setExistingHTMLTextTrack(e, t) {
                return t.persistentId = e.persistentID, this.config.condenseSubtitleTrack ? this.htmlTextTrackMap.set(e.persistentID, t) : this.htmlTextTrackMap.set(e.id, t)
            }
            createHTMLTextTrack(t) {
                let i = this.getExistingHTMLTextTrack(t);
                if (i) this.tracksReused += 1;
                else {
                    if ("sbtl" === t.mediaType) this.subtitleTracksCreated += 1, i = this.createHTMLTextTrackGuts("subtitles", t.name, t.lang, t.forced);
                    else {
                        let e = 1;
                        t.inStreamID && (e = Number(t.inStreamID.substring(2))), this.captionTracksCreated += 1, i = this.createHTMLCaptionsTrackGuts(e, t.name, t.lang, !1)
                    }
                    i ? this.setExistingHTMLTextTrack(t, i) : (this.logger.error(`failed to create HTML text track for track ${t.id}: persistent id ${t.persistentID} name ${t.name} lang ${t.lang} inStreamID ${t.inStreamID}`), this.tracksFailed += 1)
                }
                return i
            }
            createHTMLTextTrackGuts(t, i, r, e) {
                const n = this.mediaSink;
                if (n) {
                    let e = !1;
                    "metadata" !== t && this.config.customTextTrackCueRenderer && (e = !0, t = "metadata");
                    const s = n.addTextTrack(t, i, r);
                    return e && (s.customTextTrackCueRenderer = !0), s
                }
            }
            resetLoadSource() {
                this.resetTracks()
            }
            resetTracks() {
                this._cleanTracks(), this.cueRanges = []
            }
            _cleanTracks() {
                var e = this.mediaSink;
                if (e) {
                    var t = e.textTracks;
                    if (t)
                        for (let e = 0; e < t.length; e++) Lp(t[e])
                }
            }
            getCuesOfEnabledTrack(e, t = !1) {
                let i = [];
                if (t) {
                    const t = this._getCuesOfEnabledTrack(e);
                    for (let e = 0; e < t.length; e++) {
                        var r = t[e];
                        Boolean(r.webVTTCue) && i.push(r)
                    }
                } else i = this._getCuesOfEnabledTrack(e);
                return i
            }
            _getCuesOfEnabledTrack(e) {
                e = this.getTrack(e), e = this.config.condenseSubtitleTrack ? null == e ? void 0 : e.persistentID : null == e ? void 0 : e.id, e = this.htmlTextTrackMap.get(e);
                return e && e.cues ? Array.from(e.cues) : []
            }
            attachSubtitleTracks() {
                this.gotTracks && (this.subtitleTracksCreated = 0, this.captionTracksCreated = 0, this.tracksReused = 0, this.tracksFailed = 0, this.tracks.forEach(e => {
                    this.createHTMLTextTrack(e)
                }))
            }
            setTracks(e, t, i) {
                this._cleanTracks(), this.htmlTextTrackMap = new Map, this.cueRanges = [], this.config.enableWebVTT && (this.tracks = e || []), this.gotTracks = !0, this._availableMediaOptions = e, this._disabledMediaOption = i, this.attachSubtitleTracks(), this.selectedTrack = t, this.nativeSubtitleTrackChange$ = new Xt, this.mediaSink.textTracksCreated = !0
            }
            onInlineStylesParsed(e) {}
            processSubtitleFrag(e, t, i, r) {
                var n = new Uint8Array(r),
                    e = this.getExistingHTMLTextTrackIndex(e);
                if (t && r.byteLength) {
                    const s = this._parseVTTs(e, t, i, n);
                    return s && ne(s.startTime) && (this.lastCueEndTime = Math.max(this.lastCueEndTime, s.endTime)), s
                }
            }
            _parseVTTs(r, n, e, t) {
                let s;
                return Mp(t, e, n.start, n.discoSeqNum, e => {
                    const t = this.mediaSink.textTracks[r],
                        i = {
                            count: 0,
                            startTime: Number.POSITIVE_INFINITY,
                            endTime: 0
                        };
                    e.map(e => {
                        !t || t.cues && t.cues.getCueById(e.id) || (e.fragSN = n.mediaSeqNum, e.webVTTCue = !0, t.addCue(e), i.count++), i.startTime = Math.min(e.startTime, i.startTime), i.endTime = Math.max(e.endTime, i.endTime)
                    }), s = i, this.mediaSink.archiveParsedSubtitleFragmentRecord(this.selectedTrack.persistentID, n.mediaSeqNum, i)
                }, e => {}, e => {
                    this.hls.trigger(x.INLINE_STYLES_PARSED, {
                        styles: e
                    })
                }, this.logger), s
            }
            _ensureParser() {
                var e, t;
                this.cea608Parser || (e = new Xh(this, 1), t = new Xh(this, 2), this.cea608Parser = new zh(0, e, t))
            }
            setupForFrag(e) {
                e && e.mediaOptionType === gu.Variant && !e.iframe && ((e = e.mediaSeqNum) !== this.lastVariantSeqNum + 1 && this.resetClosedCaptionParser(), this.lastVariantSeqNum = e)
            }
            resetClosedCaptionParser() {
                var e;
                null === (e = this.cea608Parser) || void 0 === e || e.reset()
            }
            addLegibleSamples(e, t, i, r) {
                t && this.addClosedCaptionSamples(e, t), i && 0 < i.length && this.addId3Samples(e, i, S(r))
            }
            addClosedCaptionSamples(e, t) {
                t.mp4 ? this.addMP4CaptionSamples(e, t.mp4) : t.ts && this.addTSCaptionSamples(e, t.ts)
            }
            addMP4CaptionSamples(e, i) {
                if (this.enableCaption && this.config.enableCEA708Captions) {
                    var r = S(e);
                    this._ensureParser();
                    for (let e = 0; e < i.length; e++) {
                        let t = i[e].pts - r;
                        var n = i[e].bytes;
                        for (let e = 0; e < n.length; e += 2) {
                            const i = [];
                            i.push(n[e]), e + 1 < n.length ? i.push(n[e + 1]) : i.push(80), this.cea608Parser.addData(t, i), t += .03336666666666667
                        }
                    }
                }
            }
            addTSCaptionSamples(e, t) {
                if (this.enableCaption && this.config.enableCEA708Captions) {
                    var i = S(e);
                    this._ensureParser();
                    for (let e = 0; e < t.length; e++) {
                        var r = t[e].pts - i,
                            n = _p.extractCea608Data(t[e].bytes);
                        this.cea608Parser.addData(r, n)
                    }
                }
            }
            addId3Samples(e, t, r) {
                if (this.config.enableID3Cues) {
                    const n = window.WebKitDataCue || window.VTTCue || window.TextTrackCue,
                        s = S(e);
                    for (let e = 0; e < t.length; e++) {
                        const a = t[e].pts - s;
                        let i = (e < t.length - 1 ? t[e + 1].pts : r) - s;
                        a === i && (i += 1e-4), t[e].frames && t[e].frames.forEach(e => {
                            if (e && !this.id3shouldIgnore(e)) {
                                const t = new n(a, i, "");
                                t.value = e, this.id3Track.addCue(t)
                            }
                        })
                    }
                }
            }
            id3shouldIgnore(e) {
                return "PRIV" === e.key && ("com.apple.streaming.transportStreamTimestamp" === e.info || "com.apple.streaming.audioDescription" === e.info)
            }
            static extractCea608Data(t) {
                var i = 31 & t[0];
                let r, n, s, a = 2;
                const o = [];
                for (let e = 0; e < i; e++) r = t[a++], n = 127 & t[a++], s = 127 & t[a++], 0 == n && 0 == s || 0 != (4 & r) && 0 == (3 & r) && (o.push(n), o.push(s));
                return o
            }
        }
        const Np = {
            name: "plist"
        };
        class Fp {
            constructor(e, t, i, r) {
                this.config = e, this.xhrLoader = t, this.customUrlLoader = i, this.sessionDataCheckForCompleteness = e => {
                    const t = this.config["sessionDataAutoLoad"],
                        i = Object.assign({}, e);
                    return e.complete || (e.itemList ? i.complete = e.itemList.every(e => t[e["DATA-ID"]] && !e.VALUE && !e._STATUS && e.URI ? (this.logger.warn(`Incomplete because ${e["DATA-ID"]} was autoloaded but no response yet`), !1) : (t[e["DATA-ID"]] && !e.URI && this.logger.warn(`id=${e["DATA-ID"]} missing uri`), !0)) : this.logger.warn("Uninitialized SessionData")), i
                }, this.logger = r.child({
                    name: "SessionDataLoader"
                })
            }
            loadSessionData(r) {
                const n = this.config["sessionDataAutoLoad"],
                    t = r.itemList || [];
                let s = $i(r);
                return t.forEach(e => {
                    const i = e["DATA-ID"],
                        t = e.URI;
                    if (t && n[i]) {
                        const n = bu.buildAbsoluteURL(r.baseUrl, t, {
                                alwaysNormalize: !0
                            }),
                            e = "";
                        s = s.pipe(La(t => this.loadSessionDataItemWithUrl(n, i, "", this.config, t, this.xhrLoader, this.customUrlLoader).pipe(Vn(e => (this.logger.error(`Error loading SessionData > url=${n}, id=${i}, err=${e}`), $i(t))))))
                    }
                }), s.pipe(hr(e => {
                    if (t.length < 1) return e;
                    e = this.sessionDataCheckForCompleteness(e);
                    if (e.complete) return e;
                    throw new V(!1, "Session data not complete after loading all items", $.IncompleteSessionData)
                }), Vs(() => {}))
            }
            loadSessionDataItemWithUrl(e, t, i, r, n, s, a) {
                const o = Qe(),
                    l = {
                        url: e,
                        method: "GET",
                        responseType: i,
                        xhrSetup: r.xhrSetup,
                        mimeType: "application/xml"
                    },
                    d = Lc({
                        url: e
                    }, r.fragLoadPolicy);
                let u;
                return u = Tu(e) ? a(l, d).pipe(hr(e => this.onLoadSuccess(n, t, e.data.response.data.toString(), e.data.response.data))) : s(l, d).pipe(hr(([e]) => this.onLoadSuccess(n, t, e.response, e.responseXML))), u.pipe(Vn(e => (e instanceof dr ? e = new cc(!1, e.message, 0, $.SessionDataLoadTimeout) : e instanceof oc && (e = new cc(!1, e.message, e.code, {
                    code: e.code,
                    text: "Failed to load SessionData"
                })), o.error(`Unable to load SessionData > err=${e}`), $i(this.onLoadError(n, t, e)))))
            }
            onLoadSuccess(e, t, i, r) {
                let n = null,
                    s = e;
                if (function(e) {
                        const t = /[\s]*<\?xml/i;
                        t.lastIndex = 0;
                        var i = t.exec(e);
                        return i || /[\s]*<plist/i.exec(e)
                    }(i) && (n = r)) {
                    const i = function n(e) {
                        if (!e) return null;
                        const t = Qe();
                        let s = null;
                        var a = e.childNodes;
                        if (a)
                            if (e.tagName) {
                                var i = null === (i = e.tagName) || void 0 === i ? void 0 : i.toLowerCase();
                                if ("plist" === i) {
                                    s = [];
                                    for (let e = 0; e < a.length; ++e) {
                                        const r = a[e];
                                        r.tagName && s.push(n(r))
                                    }
                                    1 === s.length && (s = s[0])
                                }
                                if ("array" === i) {
                                    s = [];
                                    for (let e = 0; e < a.length; ++e) {
                                        const r = a[e];
                                        r.tagName && s.push(n(r))
                                    }
                                }
                                if ("dict" === i) {
                                    let t, i, r = 0;
                                    s = {};
                                    for (let e = 0; e < a.length; e++) {
                                        var o = a[e],
                                            l = null === (l = o.tagName) || void 0 === l ? void 0 : l.toLowerCase();
                                        l && (r % 2 == 0 ? "key" === l && (t = n(o), r++) : (i = n(o), s[t] = i, t = null, i = null, r++))
                                    }
                                    t && (s[t] = i, t = null, i = null)
                                } else if ("key" === i) {
                                    const e = a[0];
                                    s = e ? e.nodeValue : (t.warn(Np, "Invalid dict key: Key is null, probably like this: <key/>"), null)
                                } else if ("string" === i) {
                                    const e = a[0];
                                    s = e ? e.nodeValue : null
                                } else if ("integer" === i) {
                                    const e = a[0];
                                    s = e ? parseInt(e.nodeValue) : 0
                                } else if ("float" === i) {
                                    const e = a[0];
                                    s = e ? parseFloat(e.nodeValue) : 0
                                } else if ("date" === i) {
                                    const e = a[0];
                                    s = e ? new Date(e.nodeValue) : null
                                } else if ("data" === i) {
                                    const e = a[0];
                                    s = e ? atob(e.nodeValue) : null
                                } else "true" === i ? s = !0 : "false" === i && (s = !1)
                            } else if (a.length < 1) t.warn(Np, `unknown node with unknown value > nodeType=${e.nodeType} tagName=${e.tagName} nodeName=${e.nodeName} value=${e.nodeValue}`);
                        else {
                            s = [];
                            for (let e = 0; e < a.length; ++e) {
                                const r = a[e];
                                r.tagName && s.push(n(r))
                            }
                            1 === s.length && (s = s[0])
                        }
                        return s
                    }(n);
                    s = this.setSessionData(e, t, "VALUE", i)
                } else if (function(e) {
                        const t = /[\s]*[\{\[]/;
                        return t.lastIndex = 0, t.exec(e)
                    }(i)) try {
                    const r = JSON.parse(i);
                    s = this.setSessionData(e, t, "VALUE", r)
                } catch (r) {
                    this.logger.error(`JSON parser error: ${r}`), s = this.setSessionData(e, t, "VALUE", i), s = this.setSessionData(s, t, "_STATUS", -1)
                } else s = this.setSessionData(e, t, "VALUE", i);
                return s
            }
            setSessionData(t, i, r, n) {
                let s = t;
                if (t.itemList) {
                    let e;
                    const a = [...t.itemList];
                    for (e = 0; e < t.itemList.length; ++e) {
                        const t = Object.assign({}, a[e]);
                        if (t["DATA-ID"] === i) {
                            t[r] = n, a[e] = t;
                            break
                        }
                    }
                    e === t.itemList.length && this.logger.error(`Can't set ${r} of session data ${i}`), s = Object.assign(Object.assign({}, t), {
                        itemList: a
                    })
                } else this.logger.error(`Can't set ${r} on uninitialized session data`);
                return s
            }
            onLoadError(e, t, i) {
                return this.setSessionData(e, t, "_STATUS", null === (i = i.response) || void 0 === i ? void 0 : i.code)
            }
        }

        function Bp(e, t) {
            let i, r = 0;
            for (const a of e)
                if (a.start <= t.endPTS && a.end > t.startPTS) {
                    const e = (n = t, s = a, Math.min(n.endPTS, s.end) - Math.max(n.startPTS, s.start));
                    e > r && (i = a, r = e)
                } else if (0 < r) break;
            var n, s;
            return i
        }

        function Up(e) {
            return null != e && "iframeMediaDuration" in e && "iframeMediaStart" in e
        }

        function $p(e, t) {
            return e === t || e && t && e.itemId === t.itemId && e.mediaOptionId === t.mediaOptionId && e.mediaSeqNum === t.mediaSeqNum && e.discoSeqNum === t.discoSeqNum
        }

        function Vp(e) {
            return JSON.stringify(e, ["mediaOptionId", "mediaSeqNum", "discoSeqNum", "start", "duration"])
        }

        function Kp() {
            return e => e.pipe(ln(e => null != e), hr(e => e))
        }

        function qp(e) {
            return be.isDolby(e) ? hu.DOVI : be.isHEVC(e) ? hu.HEVC : be.isVP09(e) ? hu.VP09 : be.isAVC(e) ? hu.AVC : hu.UNKNOWN
        }

        function Hp(e) {
            return null == e ? void 0 : e.split(".")[0]
        }

        function jp(e) {
            return be.isALAC(e) ? fu.ALAC : be.isFLAC(e) ? fu.FLAC : be.isEC3(e) ? fu.EC3 : be.isAC3(e) ? fu.AC3 : be.isXHEAAC(e) ? fu.XHEAAC : be.isAAC(e) ? fu.AAC : be.isMP3(e) ? fu.MP3 : fu.UNKNOWN
        }
        class Qp {
            constructor(...e) {
                this.identifier = e
            }
            ensureSameIdentifierLength(e) {
                if (this.identifier.length !== e.identifier.length) throw new Error(`Identifiers have non-matching lengths! (${this.identifier.length} vs ${e.identifier.length})`)
            }
            isGreaterThan(t) {
                this.ensureSameIdentifierLength(t);
                for (let e = 0; e < this.identifier.length; ++e) {
                    if (this.identifier[e] < t.identifier[e]) return !1;
                    if (this.identifier[e] > t.identifier[e]) return !0
                }
                return !1
            }
            isEqualTo(i) {
                return this.ensureSameIdentifierLength(i), this.identifier.every((e, t) => e === i.identifier[t])
            }
        }

        function Wp(e) {
            return ne(e) && 0 !== e && 1 !== e
        }
        class Gp extends Error {}
        class zp {
            constructor(e) {
                this.value = e, this.waiters = [], this.wcounter = 0, this.rcounter = 0
            }
            lock(e, t = !1) {
                return this._lock(!0, e, t)
            }
            unlock() {
                this._unlock(!0)
            }
            readLock(e, t = !1) {
                return this._lock(!1, e, t)
            }
            readUnlock() {
                this._unlock(!1)
            }
            _schedule() {
                const t = [];
                this.waiters = this.waiters.filter(e => !this._canLock(e.rw) || (e.rw ? ++this.wcounter : ++this.rcounter, t.push(e), !1));
                for (const e of t) e.observer.next(this.value), e.observer.complete()
            }
            _canLock(e) {
                return e && 0 === this.wcounter && 0 === this.rcounter || !e && 0 === this.wcounter
            }
            _lock(i, e, r = !1) {
                "boolean" == typeof e && ([r, e] = [e, void 0]);
                const t = new $t(e => {
                    var t = this._canLock(i);
                    if (r && !t) throw new Gp;
                    t ? (i ? ++this.wcounter : ++this.rcounter, e.next(), e.complete()) : this.waiters.push({
                        rw: i,
                        observer: e
                    })
                });
                return e ? t.pipe(jr(() => ((e, t, i, r) => {
                    if (!r) return $i(e);
                    let n, s;
                    try {
                        n = r(e, t)
                    } catch (e) {
                        s = Vi(() => e)
                    }
                    return s = s || (void 0 === n ? $i(e) : Fr(n)), s.pipe(Vs(i))
                })(this.value, e => {
                    this.value = e
                }, () => this._unlock(i), e))) : t
            }
            _unlock(e) {
                e ? this.wcounter = Math.max(this.wcounter - 1, 0) : this.rcounter = Math.max(this.rcounter - 1, 0), this._schedule()
            }
        }
        class Xp extends $t {
            constructor() {
                super(e => this._count$.pipe(ln(e => 0 === e), Ds(1), Zs(void 0)).subscribe(e)), this._count$ = new yi(0)
            }
            wrap(e) {
                return Zr(() => (this.add(), Fr(e))).pipe(Za({
                    error: e => this._count$.error(e)
                }), Vs(() => this.done()))
            }
            add(e = 1) {
                this._count$.next(this._count$.value + e)
            }
            done(e = 1) {
                this._count$.next(this._count$.value - e)
            }
        }
        const Yp = {
            isBuffered(t, i) {
                for (let e = 0; t && e < t.length; e++)
                    if (i >= t.start(e) && i <= t.end(e)) return !0;
                return !1
            },
            timeRangesToBufferedRange(t) {
                const i = [];
                for (let e = 0; t && e < t.length; e++) i.push({
                    start: t.start(e),
                    end: t.end(e)
                });
                return i
            },
            subtitleBufferInfo(e, t, i) {
                if (e) {
                    e = this.bufferedCues(e);
                    return this.getBufferedInfo(e, t, i)
                }
                return {
                    len: 0,
                    start: t,
                    end: t,
                    nextStart: void 0
                }
            },
            fragmentsBufferedInfo(e, t, i) {
                const r = [];
                for (const t of e) r.push({
                    start: t.start,
                    end: t.start + t.duration
                });
                return this.getBufferedInfo(r, t, i)
            },
            bufferedCues(t) {
                const i = [];
                if (t)
                    for (let e = 0; e < t.length; e++) i.push({
                        start: t[e].startTime,
                        end: t[e].endTime
                    });
                return i
            },
            bufferedInfoFromMedia: (e, t, i) => Yp.getBufferedInfo(Yp.timeRangesToBufferedRange(e.buffered), t, i),
            getBufferedInfo(e, t, i) {
                const r = [];
                let n, s, a, o, l;
                const d = e.map(({
                    start: e,
                    end: t
                }) => ({
                    start: e,
                    end: t
                }));
                for (d.sort((e, t) => {
                        return e.start - t.start || t.end - e.end
                    }), l = 0; l < d.length; l++) {
                    const e = r.length;
                    if (e) {
                        const t = r[e - 1].end;
                        d[l].start - t < i ? d[l].end > t && (r[e - 1].end = d[l].end) : r.push(d[l])
                    } else r.push(d[l])
                }
                for (l = 0, n = 0, s = a = t; l < r.length; l++) {
                    const e = r[l]["start"],
                        d = r[l]["end"];
                    if (t + i >= e && t < d) s = e, a = d, n = a - t;
                    else if (t + i < e) {
                        o = e;
                        break
                    }
                }
                return {
                    len: n,
                    start: s,
                    end: a,
                    nextStart: o
                }
            },
            toRangeString: e => `[${e.start.toFixed(3)},${e.end.toFixed(3)}]`
        };
        (w = Cp = Cp || {}).Seek = "Seek", w.HighBuffer = "HighBuffer", w.LowBuffer = "LowBuffer", (w = Dp = Dp || {}).AlmostDry = "AlmostDry", w.LowWater = "LowWater", w.HighWater = "HighWater", w.AboveHighWater = "AboveHighWater";
        const Jp = {
            [Dp.AlmostDry]: 0,
            [Dp.LowWater]: 1,
            [Dp.HighWater]: 2,
            [Dp.AboveHighWater]: 3
        };

        function Zp(t, e) {
            return [{
                threshold: e.highWaterLevelSeconds,
                level: Dp.HighWater
            }, {
                threshold: e.lowWaterLevelSeconds,
                level: Dp.LowWater
            }, {
                threshold: e.almostDryWaterLevelSeconds,
                level: Dp.AlmostDry
            }].find(({
                threshold: e
            }) => e < t)
        }

        function ef(t, e) {
            return [{
                threshold: e.almostDryWaterLevelSeconds,
                level: Dp.AlmostDry
            }, {
                threshold: e.lowWaterLevelSeconds,
                level: Dp.LowWater
            }, {
                threshold: e.highWaterLevelSeconds,
                level: Dp.HighWater
            }, {
                threshold: 1 / 0,
                level: Dp.AboveHighWater
            }].find(({
                threshold: e
            }) => t <= e)
        }

        function tf(t, i) {
            const e = ef(t.getCurrentWaterLevel(i), t.bufferMonitorInfo).level,
                r = [null, null];
            return [yu.Variant, yu.AltAudio].forEach(e => {
                null != t.sourceBufferEntityByType(e) && (r[e] = ef(t.getCurrentWaterLevelByType(e, i), t.bufferMonitorInfo).level)
            }), {
                combined: e,
                sbTuple: r
            }
        }

        function rf(s, a) {
            return ed([s.combinedBuffer$, s.gotPlaying$, s.seeking$, s.waterLevelChangedForType$(null), s.stallInfo$]).pipe(La(([e, t, i, r, n]) => 0 === e.length || !t || i || null == r || null != n ? Ii : function t(i, r, e) {
                const n = i.getCurrentWaterLevel(r),
                    s = Zp(n, i.bufferMonitorInfo);
                if (s) {
                    const e = s["threshold"];
                    return bn(Math.ceil(1e3 * (n - e))).pipe(La(() => {
                        const e = Zp(i.getCurrentWaterLevel(r), i.bufferMonitorInfo);
                        return (null == e ? void 0 : e.level) === s.level ? t(i, r) : Wu
                    }), hr(() => tf(i, r)))
                }
                return Ii
            }(s, a)))
        }
        class nf extends kl {
            constructor(e, t) {
                super(t), this.mediaElement = e
            }
            get mediaElementDuration$() {
                return this.selectActive(({
                    mediaElementDuration: e
                }) => e)
            }
            get mediaElementDuration() {
                var e;
                return null !== (e = null === (e = this.getActive()) || void 0 === e ? void 0 : e.mediaElementDuration) && void 0 !== e ? e : 1 / 0
            }
            get msDuration() {
                var e;
                return null !== (e = null === (e = this.mediaSourceEntity) || void 0 === e ? void 0 : e.duration) && void 0 !== e ? e : 1 / 0
            }
            get minSBDuration() {
                var e;
                let i = Number.POSITIVE_INFINITY;
                return null === (e = null === (e = this.mediaSourceEntity) || void 0 === e ? void 0 : e.sourceBufferEntities) || void 0 === e || e.forEach((e, t) => {
                    e && (i = ne(e.totalDuration) ? Math.min(i, e.totalDuration) : Number.NEGATIVE_INFINITY)
                }), ne(i) ? i : 1 / 0
            }
            get currentTime() {
                return this.mediaElement.currentTime
            }
            get clientWidth() {
                return this.mediaElement.clientWidth
            }
            get clientHeight() {
                return this.mediaElement.clientHeight
            }
            getBufferedDuration(e = .5) {
                var t = Yp.timeRangesToBufferedRange(this.mediaElement.buffered),
                    e = Yp.getBufferedInfo(t, this.currentTime, e);
                return e.end - e.start
            }
            get mediaSourceEntity() {
                var e;
                return null === (e = this.getActive()) || void 0 === e ? void 0 : e.mediaSourceEntity
            }
            get msReadyState() {
                var e;
                return null === (e = this.mediaSourceEntity) || void 0 === e ? void 0 : e.readyState
            }
            get sourceBufferEntities() {
                var e;
                return null === (e = this.mediaSourceEntity) || void 0 === e ? void 0 : e.sourceBufferEntities
            }
            sourceBufferEntityByType(e) {
                var t;
                return null === (t = this.sourceBufferEntities) || void 0 === t ? void 0 : t[e]
            }
            initSegmentEntityByType(e) {
                return null === (e = this.sourceBufferEntityByType(e)) || void 0 === e ? void 0 : e.initSegmentInfo
            }
            get maxBufferSize() {
                var e = null === (e = this.sourceBufferEntities) || void 0 === e ? void 0 : e[yu.Variant];
                let t = 1 / 0;
                return null != e && e.gotQuotaExceeded && (t = null !== (e = e.maxTotalBytes) && void 0 !== e ? e : 1 / 0), t
            }
            get postFlushSeek() {
                var e;
                return null === (e = this.getActive()) || void 0 === e ? void 0 : e.postFlushSeek
            }
            get seekable() {
                return this.mediaElement.seekable
            }
            get desiredRate() {
                var e;
                return (null === (e = this.getActive()) || void 0 === e ? void 0 : e.desiredRate) || 0
            }
            get desiredRate$() {
                return this.selectActive(({
                    desiredRate: e
                }) => null != e ? e : 0)
            }
            get effectiveRate() {
                return this.isIframeRate ? this.desiredRate : this.paused ? 0 : 1
            }
            get playbackRate() {
                return this.mediaElement.playbackRate
            }
            get isIframeRate() {
                return Wp(this.desiredRate)
            }
            get isIframeRate$() {
                return this.desiredRate$.pipe(hr(Wp))
            }
            get msObjectUrl$() {
                return this.selectActive(({
                    mediaSourceEntity: e
                }) => null == e ? void 0 : e.objectUrl).pipe(Is())
            }
            get msReadyState$() {
                return this.selectActive(({
                    mediaSourceEntity: e
                }) => {
                    return null !== (e = null == e ? void 0 : e.readyState) && void 0 !== e ? e : null
                })
            }
            get readyState() {
                var e;
                return null !== (e = null === (e = this.getActive()) || void 0 === e ? void 0 : e.readyState) && void 0 !== e ? e : 0
            }
            get readyState$() {
                return this.selectActive(({
                    readyState: e
                }) => null != e ? e : 0)
            }
            get mediaSourceEntity$() {
                return this.selectActive(({
                    mediaSourceEntity: e
                }) => e)
            }
            get expectedSbCount$() {
                return this.selectActive(({
                    expectedSbCount: e
                }) => e)
            }
            get expectedSbCount() {
                var e;
                return null === (e = this.getActive()) || void 0 === e ? void 0 : e.expectedSbCount
            }
            get paused$() {
                return this.selectActive(({
                    paused: e
                }) => e)
            }
            get paused() {
                var e;
                return null === (e = null === (e = this.getActive()) || void 0 === e ? void 0 : e.paused) || void 0 === e || e
            }
            get playbackStarted() {
                var e;
                return ne(null === (e = this.getActive()) || void 0 === e ? void 0 : e.firstPlayTime)
            }
            get flushing$() {
                return this.selectActive(({
                    flushing: e
                }) => e)
            }
            get flushing() {
                var e;
                return null !== (e = null === (e = this.getActive()) || void 0 === e ? void 0 : e.flushing) && void 0 !== e && e
            }
            get waitingForDisco$() {
                return this.selectActive(({
                    waitingForDisco: e
                }) => e)
            }
            get waitingForDisco() {
                var e;
                return null !== (e = null === (e = this.getActive()) || void 0 === e ? void 0 : e.waitingForDisco) && void 0 !== e && e
            }
            get gotPlaying() {
                var e;
                return null !== (e = null === (e = this.getActive()) || void 0 === e ? void 0 : e.gotPlaying) && void 0 !== e && e
            }
            get gotPlaying$() {
                return this.selectActive(({
                    gotPlaying: e
                }) => e)
            }
            get gotLoadStart$() {
                return this.selectActive(({
                    gotLoadStart: e
                }) => e)
            }
            get seekTo() {
                var e;
                return null === (e = this.getActive()) || void 0 === e ? void 0 : e.seekTo
            }
            get seekTo$() {
                return this.selectActive(({
                    seekTo: e
                }) => e)
            }
            get seeking() {
                var e;
                return null !== (e = null === (e = this.getActive()) || void 0 === e ? void 0 : e.seeking) && void 0 !== e && e
            }
            get seeking$() {
                return this.selectActive(({
                    seeking: e
                }) => e)
            }
            get nudgeTarget$() {
                return this.selectActive(({
                    nudgeInfo: e
                }) => null == e ? void 0 : e.nudgeTarget)
            }
            get nudgeCount() {
                var e;
                return null !== (e = null === (e = null === (e = this.getActive()) || void 0 === e ? void 0 : e.nudgeInfo) || void 0 === e ? void 0 : e.nudgeCount) && void 0 !== e ? e : 0
            }
            get sourceBufferEntities$() {
                return this.selectActive(({
                    mediaSourceEntity: e
                }) => null == e ? void 0 : e.sourceBufferEntities)
            }
            sourceBufferEntityByType$(t) {
                return this.selectActive(({
                    mediaSourceEntity: e
                }) => {
                    return null === (e = null == e ? void 0 : e.sourceBufferEntities) || void 0 === e ? void 0 : e[t]
                })
            }
            bufferedSegmentsByType$(t) {
                return this.selectActive(({
                    mediaSourceEntity: e
                }) => {
                    return null !== (e = null === (e = null === (e = null == e ? void 0 : e.sourceBufferEntities) || void 0 === e ? void 0 : e[t]) || void 0 === e ? void 0 : e.bufferedSegments) && void 0 !== e ? e : []
                })
            }
            getBufferedSegmentsByType(e) {
                return null !== (e = null === (e = this.sourceBufferEntityByType(e)) || void 0 === e ? void 0 : e.bufferedSegments) && void 0 !== e ? e : []
            }
            get bufferedSegmentsTuple$() {
                return ed([this.bufferedSegmentsByType$(yu.Variant), this.bufferedSegmentsByType$(yu.AltAudio)]).pipe(Gn(10))
            }
            get timeupdate$() {
                return Oc(this.mediaElement).event("timeupdate").pipe(ji(tr), Aa(), ao(125, void 0, {
                    leading: !0,
                    trailing: !0
                }), hr(e => this.currentTime), ln(e => ne(e)))
            }
            get playingEvent$() {
                return Oc(this.mediaElement).event("playing").pipe(hr(() => {}))
            }
            get mediaElementEntity$() {
                return this.selectActive(e => Boolean(e))
            }
            get ended$() {
                return this.selectActive(e => {
                    return null !== (e = null == e ? void 0 : e.ended) && void 0 !== e && e
                })
            }
            sbUpdating$(t) {
                return this.selectActive(e => {
                    return null !== (e = null === (e = null === (e = null === (e = null == e ? void 0 : e.mediaSourceEntity) || void 0 === e ? void 0 : e.sourceBufferEntities) || void 0 === e ? void 0 : e[t]) || void 0 === e ? void 0 : e.updating) && void 0 !== e && e
                })
            }
            sbUpdating(e) {
                var t;
                return null !== (e = null === (e = null === (t = null === (t = null === (t = this.getActive()) || void 0 === t ? void 0 : t.mediaSourceEntity) || void 0 === t ? void 0 : t.sourceBufferEntities) || void 0 === t ? void 0 : t[e]) || void 0 === e ? void 0 : e.updating) && void 0 !== e && e
            }
            sbError$(t) {
                return this.selectActive(e => {
                    return null === (e = null === (e = null === (e = null == e ? void 0 : e.mediaSourceEntity) || void 0 === e ? void 0 : e.sourceBufferEntities) || void 0 === e ? void 0 : e[t]) || void 0 === e ? void 0 : e.error
                })
            }
            get updating$() {
                return ed([this.sbUpdating$(yu.Variant), this.sbUpdating$(yu.AltAudio)]).pipe(hr(e => e.some(e => e)))
            }
            get bufferedRangeTuple$() {
                return ed([this.selectActive(e => {
                    return null !== (e = null === (e = null === (e = null === (e = null == e ? void 0 : e.mediaSourceEntity) || void 0 === e ? void 0 : e.sourceBufferEntities) || void 0 === e ? void 0 : e[gu.Variant]) || void 0 === e ? void 0 : e.bufferedRanges) && void 0 !== e ? e : null
                }), this.selectActive(e => {
                    return null !== (e = null === (e = null === (e = null === (e = null == e ? void 0 : e.mediaSourceEntity) || void 0 === e ? void 0 : e.sourceBufferEntities) || void 0 === e ? void 0 : e[gu.AltAudio]) || void 0 === e ? void 0 : e.bufferedRanges) && void 0 !== e ? e : null
                })])
            }
            getBufferedRangeByType(e) {
                return null !== (e = null === (e = this.sourceBufferEntities[e]) || void 0 === e ? void 0 : e.bufferedRanges) && void 0 !== e ? e : []
            }
            get combinedBuffer$() {
                return this.selectActive(e => {
                    return null !== (e = null == e ? void 0 : e.bufferedRanges) && void 0 !== e ? e : []
                })
            }
            getBufferInfo(n, s) {
                var e;
                const t = null === (e = this.sourceBufferEntities) || void 0 === e ? void 0 : e.map(e => null == e ? void 0 : e.bufferedRanges),
                    i = {
                        buffered: {
                            start: n,
                            end: n,
                            len: 0
                        },
                        bufferedSegments: []
                    },
                    a = [i, i];
                return t && t.forEach((e, t) => {
                    if (e) {
                        const i = Yp.getBufferedInfo(e, n, s),
                            r = (null !== (e = this.sourceBufferEntities[t].bufferedSegments) && void 0 !== e ? e : []).filter(e => !(e.endPTS < i.start || e.startPTS > i.end));
                        a[t] = {
                            buffered: i,
                            bufferedSegments: r
                        }
                    }
                }), a
            }
            getCombinedBufferInfo(e, t) {
                var i = this.getActive();
                return i ? Yp.getBufferedInfo(i.bufferedRanges, e, t) : null
            }
            get bufferMonitorInfo() {
                var e;
                return null !== (e = null === (e = this.getActive()) || void 0 === e ? void 0 : e.bufferMonitorInfo) && void 0 !== e ? e : null
            }
            get bufferMonitorThresholds$() {
                return this.selectActive(e => {
                    var t = null == e ? void 0 : e.bufferMonitorInfo;
                    if (!t) return null;
                    var {
                        almostDryWaterLevelSeconds: i,
                        lowWaterLevelSeconds: r,
                        highWaterLevelSeconds: e,
                        maxBufferSeconds: t
                    } = t;
                    return {
                        almostDryWaterLevelSeconds: i,
                        lowWaterLevelSeconds: r,
                        highWaterLevelSeconds: e,
                        maxBufferSeconds: t
                    }
                }).pipe(Is((e, t) => (null == e ? void 0 : e.lowWaterLevelSeconds) === (null == t ? void 0 : t.lowWaterLevelSeconds)))
            }
            get waterLevelType$() {
                return this.selectActive(e => {
                    return null !== (e = null == e ? void 0 : e.bufferMonitorInfo.waterLevelType) && void 0 !== e ? e : null
                })
            }
            waterLevelForType(e) {
                var t;
                return null !== (e = null === (t = null === (t = this.getActive()) || void 0 === t ? void 0 : t.bufferMonitorInfo.waterLevelType) || void 0 === t ? void 0 : t.sbTuple[e]) && void 0 !== e ? e : null
            }
            waterLevelChangedForType$(t) {
                return this.waterLevelType$.pipe(hr(e => null == e ? null : null == t ? e.combined : e.sbTuple[t]))
            }
            get fellBelowLowWater$() {
                return this.waterLevelChangedForType$(yu.Variant).pipe(ha(), hr(([e, t]) => function(e, t) {
                    return Jp[e] > Jp[t]
                }(e, t) && (t === Dp.LowWater || t === Dp.AlmostDry)), bo(this.seekTo$, this.waitingForDisco$), hr(([e, t, i]) => e && !ne(null == t ? void 0 : t.pos) && !i), Ra(!1))
            }
            isBufferedToEnd$(s, a = !0) {
                return ed([this.combinedBuffer$, this.selectActive(e => e.bufferMonitorInfo).pipe(Kp(), hr(e => a ? e.almostDryWaterLevelSeconds : Math.max(e.almostDryWaterLevelSeconds, e.lowWaterLevelSeconds / 2))), this.seeking$]).pipe(hr(([e, t]) => {
                    var i = this.minSBDuration;
                    if (!e || !ne(i) && a) return !1;
                    e = Yp.getBufferedInfo(e, this.currentTime, s).end;
                    let r, n;
                    return n = a ? (r = i, Math.abs(r - e) <= t) : (r = this.mediaElementDuration, r - e <= t), n
                }), Is())
            }
            needData$(e, n = !1) {
                var t = !n;
                return ed([this.msReadyState$, this.waterLevelChangedForType$(null), this.isBufferedToEnd$(e, t), this.bufferedRangeTuple$, this.seekTo$, this.mediaElementDuration$]).pipe(Gn(10), hr(([e, t, i, , r]) => {
                    if ("closed" === e) return !1;
                    if (n) return !0;
                    i = null == t || !i && t !== Dp.AboveHighWater, r = this.isIframeRate || !!r;
                    return i || t !== Dp.AboveHighWater && r
                }), tc("needData"))
            }
            getSourceBufferInfoAction(e, t, i, r) {
                var {
                    currentTime: n,
                    sourceBufferEntities: s,
                    msReadyState: a
                } = this;
                let o = [null, null];
                return !e && i.every(e => !(null != e && e.userInitiated)) ? null : "open" === a && s && null != s[0] ? (o = this.getBufferInfo(n, r), {
                    position: n,
                    discoSeqNum: null == t ? void 0 : t.discoSeqNum,
                    bufferInfoTuple: o,
                    switchContexts: i
                }) : {
                    position: null == t ? void 0 : t.pos,
                    discoSeqNum: null == t ? void 0 : t.discoSeqNum,
                    bufferInfoTuple: o,
                    switchContexts: i
                }
            }
            get haveEnough() {
                var e;
                return null !== (e = null === (e = this.getActive()) || void 0 === e ? void 0 : e.haveEnough) && void 0 !== e && e
            }
            get haveEnough$() {
                return this.selectActive(({
                    haveEnough: e
                }) => e)
            }
            static likelyToKeepUp(e, t, i) {
                return t && i >= e.HAVE_FUTURE_DATA
            }
            get playbackLikelyToKeepUp() {
                return nf.likelyToKeepUp(this.mediaElement, this.haveEnough, this.readyState)
            }
            get playbackLikelyToKeepUp$() {
                return ed([this.haveEnough$, this.readyState$]).pipe(hr(([e, t]) => nf.likelyToKeepUp(this.mediaElement, e, t)))
            }
            getCurrentWaterLevel(e) {
                var t = this.currentTime,
                    i = null !== (i = null === (i = this.getActive()) || void 0 === i ? void 0 : i.bufferedRanges) && void 0 !== i ? i : [];
                return Yp.getBufferedInfo(i, t, e).len
            }
            getCombinedMediaSourceBufferInfo(e) {
                var t = this.currentTime,
                    [i, r] = null === (r = null === (i = this.getActive()) || void 0 === i ? void 0 : i.mediaSourceEntity) || void 0 === r ? void 0 : r.sourceBufferEntities;
                return [Yp.getBufferedInfo(null !== (i = null == i ? void 0 : i.bufferedRanges) && void 0 !== i ? i : [], t, e), Yp.getBufferedInfo(null !== (r = null == r ? void 0 : r.bufferedRanges) && void 0 !== r ? r : [], t, e)]
            }
            getCurrentWaterLevelByType(e, t) {
                var i = this.currentTime,
                    e = this.sourceBufferEntityByType(e),
                    e = null !== (e = null == e ? void 0 : e.bufferedRanges) && void 0 !== e ? e : [];
                return Yp.getBufferedInfo(e, i, t).len
            }
            canContinuePlaybackWithoutGap(e, t, i, r) {
                if ("LIVE" !== e.type) return !0;
                if (!e.ptsKnown) return !1;
                var n = this.currentTime,
                    i = performance.now() + i.avgPlaylistLoadTimeMs + 1e3 * e.targetduration,
                    t = e.fragments[0].start + (i - t) / 1e3;
                let s = this.getCombinedBufferInfo(n, r).end;
                return s >= e.fragments[0].start - r && s <= e.fragments[0].start + e.totalduration && (s = e.fragments[0].start + e.totalduration), t <= s
            }
            get stallInfo$() {
                return this.selectActive(e => {
                    return null !== (e = null == e ? void 0 : e.stallInfo) && void 0 !== e ? e : null
                })
            }
            get textTracks() {
                return this.mediaElement.textTracks
            }
            get textTracksCreated$() {
                return this.selectActive(e => null == e ? void 0 : e.textTracksCreated)
            }
            get mediaOptionParsedSubtitleRecord() {
                var e;
                return null === (e = this.getActive()) || void 0 === e ? void 0 : e.mediaOptionParsedSubtitleRecord
            }
            getParsedSubtitleRecordsForMediaOption(e) {
                return this.mediaOptionParsedSubtitleRecord ? this.mediaOptionParsedSubtitleRecord[e] || {} : null
            }
        }
        class sf {
            constructor(e, t, i, r) {
                this.mediaSink = e, this.media = t, this.logger = r, this.useCustomMediaFunctions = i.useCustomMediaFunctions, this.overridePlaybackRate = i.overridePlaybackRate
            }
            install() {
                const e = this.media;
                e && (this.useCustomMediaFunctions && e && e.play && e.pause && (e.originalPlay || (e.originalPlay = e.play.bind(e)), e.originalPause || (e.originalPause = e.pause.bind(e)), e.play = () => (this.mediaSink.checkForReplay(), this.mediaSink.desiredRate = 1, 0 < e.currentTime && !e.paused && !e.ended && 2 < e.readyState ? Promise.resolve() : new Promise((e, t) => {
                    this.pendingPlayPromises || (this.pendingPlayPromises = []), this.pendingPlayPromises.push({
                        resolve: e,
                        reject: t
                    })
                })), e.pause = () => {
                    this.mediaSink.desiredRate = 0
                }), "function" == typeof HTMLMediaElement && this.overridePlaybackRate && Object.defineProperty(e, "playbackRate", {
                    enumerable: !0,
                    configurable: !0,
                    get: function() {
                        return 1
                    },
                    set: function(e) {
                        Object.getOwnPropertyDescriptor(HTMLMediaElement.prototype, "playbackRate").set.call(this, e)
                    }
                }), this.playPromise = null, this.expectPauseEvent = this.expectPlayEvent = !1)
            }
            uninstall() {
                const e = this.media;
                e && (e.originalPlay && (e.play = e.originalPlay, delete e.originalPlay), e.originalPause && (e.pause = e.originalPause, delete e.originalPause), this.overridePlaybackRate && (e.playbackRate = 1, delete e.playbackRate)), this.playPromise = null, this.expectPauseEvent = this.expectPlayEvent = !1
            }
            play() {
                var e;
                this.media && (e = this.mediaSink.flushing, this.playPromise || e ? this.logger.warn(`Ignoring play command playPromise/flushing ${Boolean(this.playPromise)}/${e}`) : (this.expectPlayEvent = this.expectPlayEvent || this.media.paused, this.playPromise = this._mediaPlayInternal(), this.playPromise && this.playPromise.then(function() {
                    this.playPromise = null, this._handlePendingPlayPromises(null)
                }.bind(this)).catch(function(e) {
                    this.playPromise = null, this.expectPlayEvent = !1, this._handlePendingPlayPromises(e || new Error("Play rejected for unknown reason")), "NotAllowedError" === (null == e ? void 0 : e.name) ? (this.logger.warn("play() not allowed, going back to rate 0"), this.mediaSink.desiredRate = 0) : this.logger.error(`play() error: ${null==e?void 0:e.message}`)
                }.bind(this))))
            }
            pause() {
                this.media && (this.playPromise ? this.playPromise.then(() => {
                    var e = this.mediaSink.mediaQuery;
                    (0 === this.mediaSink.desiredRate || e.seeking && !e.playbackLikelyToKeepUp) && this._mediaPauseInternal()
                }).catch(e => {
                    this.logger.error(`Promise error in pause(): ${e.message}`)
                }) : this._mediaPauseInternal())
            }
            _handlePendingPlayPromises(t) {
                var e, i = null === (e = this.pendingPlayPromises) || void 0 === e ? void 0 : e.length;
                if (t)
                    for (let e = 0; e < i; e++) this.pendingPlayPromises[e].reject(t);
                else
                    for (let e = 0; e < i; e++) this.pendingPlayPromises[e].resolve();
                this.pendingPlayPromises = []
            }
            _mediaPlayInternal() {
                return (this.media.originalPlay || this.media.play.bind(this.media))()
            }
            _mediaPauseInternal() {
                return this.expectPauseEvent = this.expectPauseEvent || !this.media.paused, (this.media.originalPause || this.media.pause.bind(this.media))()
            }
        }
        class af extends Error {}
        class of extends p {
            constructor(e, t, i, r, n) {
                super(L, e, t, i, r), this.sbType = n, this.response = r
            }
        }
        class lf extends of {
            constructor(e, t, i, r) {
                super("bufferAddCodecError", !1, e, t, i), this.mediaOptionId = r, this.mediaOptionType = Vu(this.sbType)
            }
        }
        class df extends of {
            constructor(e, t, i, r, n, s) {
                super(e, t, i, r, n), this.isTimeout = s, this.mediaOptionType = Vu(this.sbType)
            }
        }
        class uf extends df {
            constructor(e, t, i, r) {
                super("bufferFullError", !1, e, t, i, !1), this.maxTotalBytes = r
            }
        }
        class cf extends df {
            constructor(e, t, i) {
                super(n, !1, e, t, i, !0)
            }
        }
        class hf extends df {
            constructor(e, t, i, r) {
                super(n, !1, e, t, i, !1), this.mediaOptionId = r, this.mediaOptionType = Vu(this.sbType)
            }
        }
        class pf extends p {
            constructor(e, t, i, r, n, s, a = NaN) {
                super(L, e, t, i, r), this.stallType = n, this.bufferLen = s, this.nudgePosition = a, this.response = r
            }
        }
        class ff extends $t {
            constructor(n, e, s, a, o, l, d, u, c) {
                super(e => {
                    const t = Oc(l),
                        i = u.child({
                            sb: o
                        });
                    n.setSourceBufferEntity(o, d), d.mimeType.includes("audio/mpeg") && (this.updateMp3Timestamps = !0);
                    const r = an(t.event("updatestart").pipe(Za(() => {
                        n.setSourceBufferUpdating(o)
                    })), t.event("updateend").pipe(ji(tr), Za(() => {
                        var e = Yp.timeRangesToBufferedRange(l.buffered),
                            t = Yp.timeRangesToBufferedRange(s.buffered);
                        n.setBufferedRangesUpdated(o, e, t, !1, c)
                    })), t.event("error").pipe(Za(() => {
                        n.setSourceBufferError(o, "Got source buffer error")
                    }))).pipe(La(() => Ii)).subscribe(e);
                    return () => {
                        r.unsubscribe();
                        try {
                            "open" === a.readyState && l.abort(), a.removeSourceBuffer(l)
                        } catch (e) {
                            i.error(`Error aborting SourceBuffer on unsubscribe: ${e.message}`)
                        }
                    }
                }), this.mediaElementStore = n, this.mediaElementQuery = e, this.mediaElement = s, this.type = o, this.sourceBuffer = l, this.config = c, this.updateMp3Timestamps = !1
            }
            get buffered() {
                return this.sourceBuffer.buffered
            }
            appendBuffer(e, t) {
                return Zr(() => this.sourceBuffer.updating ? this._waitForUpdateEndOrError().pipe(La(() => this.appendBuffer(e, t))) : this._appendBufferAsync(e, t))
            }
            _appendBufferAsync(e, t) {
                let i = NaN,
                    r = null;
                const n = ("startPTS" in t ? t.frag : t).mediaOptionId;
                try {
                    "startPTS" in t && (r = {
                        startPTS: t.startPTS,
                        endPTS: t.endPTS,
                        bytes: t.bytes,
                        frag: Object.assign({}, t.frag)
                    }), this.mediaElementStore.setInflightSegment(this.type, r), i = performance.now(), this.sourceBuffer.appendBuffer(e)
                } catch (e) {
                    return 22 !== e.code ? (this.mediaElementStore.setInflightSegment(this.type, null), this.mediaElement.error ? Vi(new hf(e.message, $.VideoDecoderBadDataErr, this.type, n)) : Vi(e)) : (this.mediaElementStore.setBufferedRangesUpdated(this.type, Yp.timeRangesToBufferedRange(this.sourceBuffer.buffered), Yp.timeRangesToBufferedRange(this.mediaElement.buffered), !0, this.config), Vi(new uf(e.message, $.AllocationFailed, this.type, this.maxTotalBytes)))
                }
                return this._waitForUpdateEndOrError().pipe(hr(() => ({
                    startAppend: i,
                    endAppend: performance.now(),
                    bytesAppend: e.byteLength
                })), So(1e4), Vn(e => {
                    throw e instanceof dr ? (this.sourceBuffer.abort(), e = new cf("Append took longer than 10000ms", $.InternalError, this.type)) : e instanceof of && (e = new hf("Decode error", $.VideoDecoderBadDataErr, this.type, n)), e
                }))
            }
            remove(e, t) {
                return this._waitForUpdateEndOrError().pipe(La(this._removeAsync.bind(this, e, t)))
            }
            _removeAsync(e, t) {
                try {
                    this.sourceBuffer.remove(e, t)
                } catch (e) {
                    return Vi(new of (r, !1, e.message, $.InternalError, this.type))
                }
                return this._waitForUpdateEndOrError()
            }
            abort() {
                try {
                    this.sourceBuffer.abort()
                } catch (e) {
                    return Vi(new of (r, !1, e.message, $.InternalError, this.type))
                }
                return this._waitForUpdateEndOrError()
            }
            get updating() {
                return this.sourceBuffer.updating
            }
            get timestampOffset() {
                return this.sourceBuffer.timestampOffset
            }
            set timestampOffset(e) {
                this.sourceBuffer.timestampOffset = e
            }
            get gotQuotaExceeded() {
                var e;
                return null !== (e = null === (e = this.mediaElementQuery.sourceBufferEntityByType(this.type)) || void 0 === e ? void 0 : e.gotQuotaExceeded) && void 0 !== e && e
            }
            get bufferedSegments() {
                var e;
                return null !== (e = null === (e = this.mediaElementQuery.sourceBufferEntityByType(this.type)) || void 0 === e ? void 0 : e.bufferedSegments) && void 0 !== e ? e : []
            }
            get totalBytes() {
                var e;
                return null !== (e = null === (e = this.mediaElementQuery.sourceBufferEntityByType(this.type)) || void 0 === e ? void 0 : e.totalBytes) && void 0 !== e ? e : 0
            }
            get maxTotalBytes() {
                var e = null !== (e = null === (e = this.mediaElementQuery.sourceBufferEntityByType(this.type)) || void 0 === e ? void 0 : e.maxTotalBytes) && void 0 !== e ? e : 1 / 0;
                return this.gotQuotaExceeded ? e : 1 / 0
            }
            _waitForUpdateEndOrError() {
                return this.sourceBuffer.updating && this.mediaElementStore.setSourceBufferUpdating(this.type), this.mediaElementQuery.sbUpdating$(this.type).pipe(ln(e => !1 === e), bo(this.mediaElementQuery.sbError$(this.type)), hr(([, e]) => {
                    if (e) throw new of (r, !1, "Got error during sourceBuffer operation", $.InternalError, this.type)
                }), Ds(1))
            }
        }
        class mf extends $t {
            constructor(a, o, e, l, t) {
                super(e => {
                    const t = Oc(l),
                        i = an(t.event("sourceopen"), t.event("sourceclose"), t.event("sourceended")).pipe(Za(e => {
                            e = (null !== (e = null == e ? void 0 : e.target) && void 0 !== e ? e : l).readyState;
                            o.msReadyState = e
                        })),
                        r = this.sourceBuffers$.pipe(La(e => e ? an(...e.filter(e => null != e)) : Ii)),
                        n = an(i, r).pipe(La(() => Ii)).subscribe(e),
                        s = URL.createObjectURL(l);
                    return a.src = s, o.setMediaSourceEntity(s, l.readyState), () => {
                        n.unsubscribe(), URL.revokeObjectURL(s), a.src === s && (a.removeAttribute("src"), a.load(), o.setMediaSourceEntity(null)), this.sourceBuffers$.next(null)
                    }
                }), this.mediaElement = a, this.mediaElementStore = o, this.mediaElementQuery = e, this.mediaSource = l, this.logger = t, this.sourceBuffers$ = new yi(null)
            }
            get readyState() {
                return this.mediaSource.readyState
            }
            set duration(e) {
                this.mediaSource.duration = e
            }
            get duration() {
                return this.mediaSource.duration
            }
            endOfStream(e) {
                this.mediaSource.endOfStream(e)
            }
            createSourceBuffers(e, a) {
                const o = this.mediaSource;
                al(() => {
                    try {
                        const s = [null, null];
                        e.forEach((t, i) => {
                            if (t) {
                                var {
                                    mimeType: r,
                                    mediaOptionId: n
                                } = t;
                                let e;
                                try {
                                    e = o.addSourceBuffer(r)
                                } catch (t) {
                                    throw new lf(t.message, $.IncompatibleAsset, i, n)
                                }
                                s[i] = new ff(this.mediaElementStore, this.mediaElementQuery, this.mediaElement, this.mediaSource, i, e, t, this.logger, a)
                            }
                        }), this.sourceBuffers$.next(s)
                    } catch (e) {
                        if (!(e instanceof p)) throw new af(`error initializing sourcebuffers ${e.message} readyState=${o.readyState}`);
                        throw e
                    }
                })
            }
            get needSourceBuffers() {
                return null == this.sourceBuffers$.value || null == this.sourceBuffers$.value[0]
            }
            get sourceBuffers() {
                return this.sourceBuffers$.value
            }
            getSourceBufferByType(e) {
                var t = this.sourceBuffers$.value;
                return t ? t[e] : null
            }
            updateLiveSeekableRange(e, t) {
                const i = this.mediaSource;
                null != i && i.setLiveSeekableRange && "open" === (null == i ? void 0 : i.readyState) && i.setLiveSeekableRange(e, t)
            }
            clearLiveSeekableRange() {
                const e = this.mediaSource;
                null != e && e.clearLiveSeekableRange && "open" === (null == e ? void 0 : e.readyState) && e.clearLiveSeekableRange()
            }
        }

        function gf(e, c, t) {
            const {
                lowBufferThreshold: h,
                lowBufferWatchdogPeriod: p,
                highBufferWatchdogPeriod: f,
                seekWatchdogPeriod: m
            } = t, i = ed([c.desiredRate$, c.ended$, c.combinedBuffer$, c.seekTo$]).pipe(hr(e => {
                var t, [i, r, n, s] = e;
                return t = c.currentTime, e = i, i = r, r = n, n = isFinite(null == s ? void 0 : s.pos), s = r.some(e => e.start <= t && e.end > t), !(1 !== e || i || 0 === r.length || n && !s)
            }), Is()), r = c.combinedBuffer$.pipe(hr(() => c.getCurrentWaterLevel(0) <= t.lowBufferThreshold || !c.haveEnough ? Cp.LowBuffer : Cp.HighBuffer), Is()), n = ed([i, c.seekTo$, c.gotPlaying$, r]).pipe(La(e => {
                var [t, i, r] = e;
                if (!t) return $i(null);
                var n, s, a, o, l, d, u, e = c.nudgeCount,
                    t = m + +e;
                return isFinite(null == i ? void 0 : i.pos) || !r ? (n = c, s = performance.now(), t = t, a = h, bn(1e3 * t).pipe(hr(() => {
                    var e = n.currentTime,
                        t = n.getCombinedBufferInfo(e, 0);
                    return yf(Cp.Seek, e, s, t, a, n.haveEnough)
                }))) : (o = c, l = p, d = f + +e, u = h, an($i(o.currentTime), o.timeupdate$).pipe(La(e => {
                    const t = performance.now(),
                        i = o.getCombinedBufferInfo(e, 0);
                    let r, n;
                    return r = i.len <= u || !o.haveEnough ? (n = l, Cp.LowBuffer) : (n = d, Cp.HighBuffer), bn(Math.max(100, 1e3 * n)).pipe(hr(() => e < o.currentTime ? null : yf(r, e, t, i, u, o.haveEnough)))
                })))
            })), s = n.pipe(Kp(), bo(c.combinedBuffer$), La(([]) => ed([c.seeking$, c.paused$])), La(([e, t]) => e || t ? Ii : c.timeupdate$.pipe(ha(), ln(([e, t]) => ne(e) && ne(t) && e < t), Ds(1))), hr(() => null));
            return an(n, s)
        }

        function yf(e, t, i, r, n, s) {
            var a = performance.now() - i;
            return {
                type: e,
                isLowBufferStall: r.len <= n || !s,
                tstalled: i,
                stallDurationMs: a,
                currentTime: t
            }
        }
        class vf extends $t {
            constructor(w, A, e, t, i, r, n) {
                super(e => {
                    const t = this.config,
                        i = A.startMediaSession(w, t.maxBufferLength, t.almostDryBufferSec, t.defaultTargetDuration),
                        r = Sf(w, A, this._mediaQuery, this, this.hlsGapless, t, this.logger, this.rtcService),
                        n = this.mediaSource$.pipe(La(e => e || Ii)),
                        s = this._mediaQuery.seekTo$.pipe((u = w, c = this._mediaQuery, p = (h = this).config, f = (f = this.logger).child({
                            name: "seek"
                        }), e => e.pipe(Za(e => {}), ln(e => e && ne(e.pos)), La(e => c.readyState$.pipe(ln(e => e >= u.HAVE_METADATA), Ds(1), Zs(e), La(({
                            pos: e,
                            fromEvent: t
                        }) => (h.checkForInconsistentStoreBufferRangesAndUpdate(), u.paused || h.pause(), t || (u.currentTime = e), Gu(c.haveEnough$, e => e).pipe(Zs({
                            pos: e,
                            fromEvent: t
                        })))), La(({
                            pos: e,
                            fromEvent: t
                        }) => {
                            var i = c.getCombinedBufferInfo(e, 0),
                                r = i.nextStart;
                            return (!t || p.nudgeFromEventSeek) && 0 === i.len && ne(r) && e < r && r - e <= p.maxSeekHole ? (h.seekTo = r, Ii) : $i(e)
                        }), bo(c.desiredRate$), hr(([, e]) => {
                            u.paused && 0 !== e && h.play()
                        }), $a(Ii), Vn(e => (f.error(`error during seek ${e.message}`), Ii))))))),
                        a = this._mediaQuery.desiredRate$.pipe((o = w, l = this._mediaQuery, d = this, e => e.pipe(bo(l.seekTo$), La(([e, t]) => ne(null == t ? void 0 : t.pos) ? Ii : 0 === e ? (o.paused || d.pause(), Ii) : Gu(l.haveEnough$, e => e).pipe(Za(() => {
                            o.paused && d.play()
                        }))), $a(Ii))));
                    var o, l, d, u, c, h, p, f;
                    this.liveSeekableWindow = {
                        start: NaN,
                        end: NaN
                    }, this.mediaFunctions = this.mediaFunctions || new sf(this, w, t, this.logger), this.mediaFunctions.install();
                    var m, g, y, v, S, b, T, E, I = an(gf(this.logger, this._mediaQuery, this.config).pipe(Za(e => {
                        A.setStallInfo(e)
                    })), this.mediaQuery.stallInfo$.pipe((g = A, y = (m = this).config, v = this.logger, e => e.pipe(_s(e => e ? function(i, e, r, n) {
                        const s = i.mediaQuery;
                        return an(ed([s.seekTo$, s.nudgeTarget$]).pipe(ln(([e, t]) => e && ne(e.pos) && ne(t) && (e.pos < t || e.pos - t > r.maxSeekHole)), Zs(null)), s.stallInfo$).pipe(bo(s.desiredRate$), ji(tr), hr(([c, e], t) => {
                            if (!c) return NaN;
                            var h = s.getCombinedBufferInfo(c.currentTime, 0),
                                e = Wp(e);
                            return function(e, t, i, r, n) {
                                var {
                                    type: s,
                                    isLowBufferStall: a,
                                    currentTime: o
                                } = c, l = h.len, d = t.maxSeekHole;
                                let u = NaN;
                                if (a) {
                                    const t = h.nextStart - o <= d ? h.nextStart : 1 / 0;
                                    ne(t) ? u = t : e.mediaQuery.msDuration - o < .1 && (u = o + .1)
                                } else if (n < t.nudgeMaxRetry) u = o + t.nudgeOffset;
                                else {
                                    if (!r) throw i.error(`still stuck in high buffer @${o} after ${t.nudgeMaxRetry}, raise fatal error`), new pf("bufferStalledError", !0, "got fatal buffer error", $.VideoDecoderBadDataErr, s, l);
                                    i.error(`still stuck in high buffer @${o} after ${t.nudgeMaxRetry}, non fatal in iframeMode`)
                                }
                                return ne(u) && e.nudgeSeek(u, n + 1), u
                            }(i, r, n, e, t)
                        }), Wa(e => ne(e)), Vs(() => {
                            e.setNudgeInfo(null)
                        }))
                    }(m, g, y, v) : $i(NaN))))));
                    an(r, n, s, a, I, (S = this.mediaQuery, b = A, I = t.maxBufferHole, an((E = I, ed([(T = S).bufferMonitorThresholds$, T.combinedBuffer$, T.seeking$]).pipe(hr(([e]) => null == e ? null : tf(T, E)))), rf(S, I)).pipe(ji(tr), Za(({
                        combined: e,
                        sbTuple: t
                    }) => {
                        b.updateWaterLevels(e, t)
                    })))).pipe($a(Ii), Vs(() => {
                        A.remove(i), this.mediaFunctions.uninstall(), this.mediaFunctions = void 0
                    })).subscribe(e)
                }), this.mediaElement = w, this.mediaElementStore = A, this.config = e, this.hlsGapless = t, this.logger = i, this.teardownWG$ = r, this.rtcService = n, this.mediaSource$ = new yi(null), this.mediaKeysMutex = new zp, this._mediaQuery = new nf(w, A), this.logger = i.child({
                    name: "mse"
                }), this.createId3Track(w), this.mediaFunctions = new sf(this, w, e, this.logger)
            }
            get mediaSourceAdapter() {
                return this.mediaSource$.value
            }
            get sourceBuffers() {
                var e;
                return null !== (e = null === (e = this.mediaSourceAdapter) || void 0 === e ? void 0 : e.sourceBuffers) && void 0 !== e ? e : []
            }
            get needSourceBuffers() {
                return !this.sourceBuffers[0]
            }
            get mediaQuery() {
                return this._mediaQuery
            }
            sourceBuffersBufferedRangeByType(e) {
                var t, e = null === (t = null === (t = this.mediaSourceAdapter) || void 0 === t ? void 0 : t.sourceBuffers) || void 0 === t ? void 0 : t[e];
                return e ? Yp.timeRangesToBufferedRange(e.sourceBuffer.buffered) : null
            }
            createId3Track(e) {
                this.id3Track = e.addTextTrack("metadata", "id3"), this.id3Track.mode = "hidden"
            }
            checkForInconsistentStoreBufferRangesAndUpdate() {
                var e = Yp.timeRangesToBufferedRange(this.mediaElement.buffered),
                    t = this.sourceBuffersBufferedRangeByType(yu.Variant),
                    i = this.sourceBuffersBufferedRangeByType(yu.AltAudio),
                    r = null !== (n = null === (r = this.mediaQuery.sourceBufferEntityByType(yu.Variant)) || void 0 === r ? void 0 : r.bufferedRanges) && void 0 !== n ? n : null,
                    n = null !== (n = null === (n = this.mediaQuery.sourceBufferEntityByType(yu.AltAudio)) || void 0 === n ? void 0 : n.bufferedRanges) && void 0 !== n ? n : null;
                this.shouldUpdateStoreValues(t, r) && (this.logger.warn(`[${Uu[yu.Variant]}] SourceBuffer's loaded bufferedRanges ${JSON.stringify(t)} & mediaElementStore's bufferedRanges ${JSON.stringify(r)} are out of sync!`), this.updateMediaElementStoreBufferedRanges(e, yu.Variant)), this.shouldUpdateStoreValues(i, n) && (this.logger.warn(`[${Uu[yu.AltAudio]}] SourceBuffer's loaded bufferedRanges ${JSON.stringify(i)} & mediaElementStore's bufferedRanges ${JSON.stringify(n)} are out of sync!`), this.updateMediaElementStoreBufferedRanges(e, yu.AltAudio))
            }
            shouldUpdateStoreValues(e, i) {
                return !(null == e && null == i || (null == e ? void 0 : e.length) == (null == i ? void 0 : i.length) && !e.find(t => {
                    var e = Ku.search(i, e => t.start >= e.start && t.end <= e.end ? 0 : t.end < e.start ? -1 : 1);
                    return null == e || e.start != t.start || e.end != t.end || void 0
                }))
            }
            updateMediaElementStoreBufferedRanges(e, t) {
                var i = this.sourceBuffersBufferedRangeByType(t);
                i && !this.mediaQuery.sbUpdating(t) && this.mediaElementStore.setBufferedRangesUpdated(t, i, e, !1, this.config)
            }
            destroyMediaSource() {
                this.mediaSource$.next(null)
            }
            makeMediaSource() {
                return new MediaSource
            }
            openMediaSource(t) {
                al(() => {
                    var e;
                    t ? (e = new mf(this.mediaElement, this.mediaElementStore, this.mediaQuery, t, this.logger), this.mediaSource$.next(e)) : this.mediaSource$.next(null)
                })
            }
            createSourceBuffers(e) {
                const t = this.mediaSource$.value;
                if (!t) throw new Error("createSourceBuffers empty mediaSource");
                t.createSourceBuffers(e, this.config)
            }
            _waitForMediaSourceOpen(i) {
                const r = this.mediaQuery.mediaSourceEntity.objectUrl;
                return ed([this.mediaQuery.msReadyState$, this.mediaQuery.msObjectUrl$]).pipe(La(([e, t]) => t !== r ? $i(null) : "open" === e || "ended" === e ? $i(i) : Ii))
            }
            get appendOrder() {
                return this.mediaQuery.isIframeRate ? [yu.Variant, yu.AltAudio] : [yu.AltAudio, yu.Variant]
            }
            clearFlush(e) {
                e.forEach(e => {
                    e && (e.dataSeg.flushBeforeAppend = {
                        start: 0,
                        end: 0
                    })
                })
            }
            getSwitchPosition(e) {
                return e.reduce((e, t) => {
                    t = t ? t.dataSeg.switchPosition : void 0;
                    return ne(t) ? ne(e) ? Math.min(e, t) : t : e
                }, void 0)
            }
            checkForReplay() {
                var e = this.mediaElement;
                e.paused && !e.seeking && e.duration && e.currentTime && e.currentTime >= e.duration - this.config.maxTotalDurationTolerance && (this.seekTo = 0)
            }
            resetMediaSourceIfNeeded(r) {
                const n = this["mediaQuery"],
                    e = n["sourceBufferEntities"],
                    t = n.getActive()["expectedSbCount"];
                if (!e || this.needSourceBuffers) return this._waitForMediaSourceOpen(r);
                const s = function(e, s, t, i) {
                    const r = s.filter(e => Boolean(e)).length,
                        n = e.filter(e => Boolean(e)).length,
                        l = [null, null];
                    e.forEach((e, t) => {
                        var i, r, n, s, a, o;
                        e && (s = e["offsetTimestamp"], a = S(s), i = e.initSeg.mimeType, {
                            audioCodec: r,
                            videoCodec: n
                        } = e.initSeg.initParsedData, o = e["dataSeg"], s = S(o.startPts) - a, a = S(o.endPts) - a, o = o.discoSeqNum, l[t] = {
                            audioCodec: r,
                            videoCodec: n,
                            mimeType: i,
                            startPTSSec: s,
                            endPTSSec: a,
                            discoSeqNum: o,
                            mediaOptionId: e.initSeg.mediaOptionId
                        })
                    });
                    let a = r === t,
                        o = n === t;
                    if (1 === n && n < t && 0 !== r) {
                        const t = e[gu.Variant] ? gu.Variant : gu.AltAudio,
                            h = 1 - t,
                            r = l[t],
                            n = l[h] = function(e, i, r, n, t, s) {
                                const a = null == e ? void 0 : e.bufferedSegments;
                                if (!a) return s.warn("getMatchingInfo trying to query null sbEntity"), null;
                                s = a.find(e => {
                                    var t = e.frag.discoSeqNum === n,
                                        e = Math.max(i, e.startPTS) < Math.min(r, e.endPTS);
                                    return t && e
                                });
                                if (null == s) return null; {
                                    const {
                                        audioCodec: i,
                                        videoCodec: r,
                                        mimeType: o
                                    } = e;
                                    return {
                                        mimeType: o,
                                        audioCodec: i,
                                        videoCodec: r,
                                        startPTSSec: s.startPTS,
                                        endPTSSec: s.endPTS,
                                        discoSeqNum: n,
                                        mediaOptionId: t
                                    }
                                }
                            }(s[h], r.startPTSSec, r.endPTSSec, r.discoSeqNum, r.mediaOptionId, i);
                        if (!n)
                            if (null !== (e = null === (e = e[gu.Variant]) || void 0 === e ? void 0 : e.dataSeg) && void 0 !== e && e.iframe && t === gu.Variant && l[t]) {
                                const p = s[t].videoCodec,
                                    h = l[t].videoCodec;
                                if (a = a && (p === h || be.isCompatibleVideoCodec(p, h)), a) return {
                                    compatible: a,
                                    boundary: NaN,
                                    allowance: NaN,
                                    discoSeqNum: l[t].discoSeqNum
                                }
                            } else i.warn(`${Nu[t]} No matching frag found ${ae(r)} buffered=${ae(s[h].bufferedSegments.map(e=>{var{mediaSeqNum:t,discoSeqNum:i}=e.frag;return{mediaSeqNum:t,discoSeqNum:i,startPTS:e.startPTS,endPTS:e.endPTS}}))}`);
                        o = null != n
                    }
                    let d = NaN,
                        u = NaN,
                        c = NaN;
                    return o && l.forEach((e, t) => {
                        if (!e) return null;
                        ne(c) ? c !== e.discoSeqNum && (c = NaN) : c = e.discoSeqNum;
                        t = s[t];
                        if (t) {
                            const s = t.audioCodec,
                                i = t.videoCodec,
                                {
                                    audioCodec: r,
                                    videoCodec: n
                                } = e;
                            a = a && (i === n || be.isCompatibleVideoCodec(i, n)), a = a && (s === r || be.isCompatibleAudioCodec(s, r))
                        } else a = !1;
                        d = ne(d) ? (u = Math.abs(e.startPTSSec - d), Math.max(e.startPTSSec, d)) : (u = 0, e.startPTSSec)
                    }), {
                        compatible: a && o,
                        boundary: d,
                        allowance: u,
                        discoSeqNum: c
                    }
                }(r, e, t, (this.config.maxBufferHole, this.logger));
                if (s.compatible) return this._waitForMediaSourceOpen(r);
                let i = s.boundary;
                const a = s.allowance,
                    o = this.getSwitchPosition(r);
                if (ne(o) && (i = o), !ne(i)) return this.logger.warn("not enough info #disco"), $i(null);
                const l = fn(Gu(an($i(n.currentTime), n.timeupdate$), e => e >= i), Gu(n.stallInfo$.pipe(hr(e => {
                    return null !== (e = null == e ? void 0 : e.currentTime) && void 0 !== e ? e : NaN
                })), e => e >= i - a - this.config.discontinuitySeekTolerance));
                return this.mediaElementStore.waitingForDisco = !0, l.pipe(Zs(i), La(e => {
                    performance.now();
                    const t = n.currentTime,
                        i = this.msDuration;
                    return this.resetMediaSource(Math.max(t, e), s.discoSeqNum), this._waitForMediaSourceOpen(r).pipe(Za(() => {
                        performance.now(), this.msDuration = i
                    }))
                }), Vs(() => {
                    this.mediaElementStore.waitingForDisco = !1
                }))
            }
            resetMediaSource(e = NaN, t) {
                var i;
                ne(e) || (e = null !== (i = null === (i = this.mediaQuery.seekTo) || void 0 === i ? void 0 : i.pos) && void 0 !== i ? i : this.mediaQuery.currentTime), ne(t) || (t = null === (i = this.mediaQuery.seekTo) || void 0 === i ? void 0 : i.discoSeqNum), 0 < this.sourceBuffers.length && (this.openMediaSource(this.makeMediaSource()), this.setSeekToWithDiscontinuity(e, t))
            }
            setExpectedSbCount(e) {
                this.mediaElementStore.expectedSbCount = e
            }
            appendInitSegments(l, d) {
                const {
                    mediaQuery: e,
                    mediaElementStore: u,
                    sourceBuffers: c
                } = this, h = e["sourceBufferEntities"];
                if (!c) throw new Error("appendInitSegments: null sourceBuffers");
                if (!h) throw new Error("appendInitSegments: null sourceBufferEntities");
                var t = this.appendOrder.map(t => {
                    if (l[t]) {
                        const i = c[t],
                            r = l[t],
                            n = h[t],
                            s = r["initSeg"];
                        if (!n) throw new Error(`appendInitSegments: sb[${Uu[t]}] null currentSbEntity`);
                        if (!i) throw new Error(`appendInitSegments: sb[${Uu[t]}] null source buffer`);
                        const a = n.initSegmentInfo,
                            o = function() {
                                var {
                                    itemId: e,
                                    mediaOptionId: t,
                                    discoSeqNum: i,
                                    keyTagInfo: r
                                } = s;
                                return {
                                    itemId: e,
                                    mediaOptionId: t,
                                    discoSeqNum: i,
                                    keyId: je(null == r ? void 0 : r.keyId)
                                }
                            }();
                        if ((e = o) && a && e.itemId === a.itemId && e.mediaOptionId === a.mediaOptionId && e.discoSeqNum === a.discoSeqNum && e.keyId === a.keyId) return $i(null);
                        var e = Vu(t);
                        return i.appendBuffer(s.data, s).pipe(Za(e => {
                            u.setInitSegmentEntity(t, o)
                        }), d(i, e, s.mediaOptionId, this.config, this.mediaQuery))
                    }
                }).filter(e => Boolean(e));
                return 0 === t.length ? $i(null) : en(t)
            }
            appendDataSegments(m, g) {
                var e = this.appendOrder.map(e => {
                    const t = m[e],
                        {
                            mediaQuery: i,
                            sourceBuffers: r
                        } = this,
                        n = i["sourceBufferEntities"];
                    if (!r) throw new Error("appendDataSegments: null sourceBuffers");
                    if (!n) throw new Error("appendDataSegments: null sourceBufferEntities");
                    if (!t) return null;
                    const s = r[e],
                        a = m[e],
                        o = n[e];
                    if (!o) throw new Error("appendDataSegments: null currentSbEntity");
                    const l = o.initSegmentInfo,
                        d = a["dataSeg"];
                    if (!l) throw new Error(`appendDataSegments: sb[${Uu[e]}] null currentInitSegmentInfo`);
                    if (!o) throw new Error(`appendDataSegments: sb[${Uu[e]}] null currentSbEntity`);
                    if (!s) throw new Error(`appendDataSegments: sb[${Uu[e]}] null source buffer`);
                    const u = s.timestampOffset,
                        c = {
                            startPTS: S(d.startPts) + u,
                            endPTS: S(d.endPts) + u,
                            firstKeyframePts: d.firstKeyframePts ? S(d.firstKeyframePts) + u : void 0,
                            bytes: d.data2 ? d.data1.byteLength + d.data2.byteLength : d.data1.byteLength,
                            frag: {
                                itemId: d.itemId,
                                mediaOptionId: d.mediaOptionId,
                                mediaSeqNum: d.mediaSeqNum,
                                discoSeqNum: d.discoSeqNum,
                                keyTagInfo: d.keyTagInfo,
                                isLastFragment: d.isLastFragment,
                                iframe: d.iframe,
                                framesWithoutIDR: d.framesWithoutIDR,
                                dropped: d.dropped
                            }
                        },
                        h = Vu(e);
                    let p = Wu;
                    var f = t.dataSeg.flushBeforeAppend;
                    return f && f.start !== f.end && (p = this.flushData(e, f.start, f.end)), p.pipe(La(() => $i(d.data1, d.data2).pipe(Kp()).pipe(Wn(e => s.appendBuffer(e, c).pipe(g(s, h, d.mediaOptionId, this.config, this.mediaQuery))))), Za(() => {
                        i.getBufferedRangeByType(e)
                    }))
                }).filter(e => Boolean(e));
                return 0 === e.length ? $i(null) : en(e)
            }
            setStoreSbTimeoffsets(s) {
                const {
                    mediaElementStore: a,
                    sourceBuffers: e
                } = this;
                e.forEach((t, i) => {
                    if (t && s[i]) {
                        var {
                            offsetTimestamp: r,
                            dataSeg: n
                        } = s[i], n = S(n.startPts);
                        let e = -1 * S(r);
                        t.updateMp3Timestamps && .1 < Math.abs(t.timestampOffset - n) && (e = n + e), t.timestampOffset !== e && (t.timestampOffset = e, a.setTimestampOffset(i, t.timestampOffset))
                    }
                })
            }
            adjustJaggedStart(e) {
                const {
                    mediaQuery: t,
                    logger: n
                } = this, {
                    sourceBufferEntities: i,
                    currentTime: r,
                    seekTo: s
                } = t, a = e.reduce((e, t) => null != t && t.dataSeg.endPts ? Math.min(b(t.dataSeg.endPts, t.offsetTimestamp), e) : e, Number.POSITIVE_INFINITY);
                if (!i) throw new Error("appendSourceBufferData null currentSbEntity");
                const o = (null == s ? void 0 : s.pos) || r;
                let l = NaN;
                i.forEach((e, t) => {
                    if (e) {
                        e = Yp.getBufferedInfo(e.bufferedRanges, o, 0);
                        if (0 === e.len) {
                            const i = e["nextStart"],
                                r = ne(this.config.jaggedSeekTolerance) ? this.config.jaggedSeekTolerance : 0;
                            n.warn(`sb[${Uu[t]}] jagged start: ${i} appendEndTime=${a} current=${l} tolerance=${r}`), ne(i) && (!ne(l) || i - l > r) && (l = i)
                        }
                    }
                }), ne(l) && a > l && (n.warn(`[seek] jagged start, adjusting currentTime:${r.toFixed(3)} seekTo=${null===(e=null==s?void 0:s.pos)||void 0===e?void 0:e.toFixed(3)}->${l} appendEndTime=${a}`), this.seekTo = l)
            }
            addCues(e, t) {
                const i = this.mediaElement.textTracks[e];
                i && t.forEach(e => {
                    i.addCue(e)
                })
            }
            _flushInternal(e, t, i) {
                return Zr(() => e.remove(t, i)).pipe(Za(() => {}))
            }
            flushAll(i, r, n = !1) {
                return 0 === this.sourceBuffers.length ? Wu : en(this.sourceBuffers.map((e, t) => e ? this.flushData(t, i, r, n) : Wu)).pipe(Zs(void 0))
            }
            flushData(o, l, d, u = !1) {
                const {
                    mediaQuery: t,
                    logger: c
                } = this;
                return Gu(t.updating$, e => !1 === e).pipe(La(() => {
                    var e = t["sourceBufferEntities"],
                        e = e[o];
                    null != e && e.updating && this.logger.warn(`trying to flush while updating ${o}`);
                    const r = this.sourceBuffers[o];
                    if (!r) return Wu;
                    let n, s, a = Wu;
                    e = -1 === navigator.userAgent.toLowerCase().indexOf("firefox");
                    if (this.flushing = !0, e) return this._flushInternal(r, l, d);
                    for (let i = 0; i < r.buffered.length; i++) {
                        let e, t;
                        n = r.buffered.start(i), s = r.buffered.end(i), t = d === 1 / 0 ? (e = l, d) : (e = Math.max(n, l), Math.min(s, d)), Math.min(t, s) > e && (u || .5 < Math.min(t, s) - e) ? a = a.pipe($a(this._flushInternal(r, e, t))) : c.warn(`ignoring sb[${Uu[o]}] flush ${e},${t}`)
                    }
                    return a
                }), Vs(() => {
                    this.flushing = !1
                }))
            }
            static convertInitSegToCompatInfo(e) {
                return {
                    mimeType: e.mimeType,
                    audioCodec: e.initParsedData.audioCodec,
                    videoCodec: e.initParsedData.videoCodec,
                    startPTSSec: void 0,
                    endPTSSec: void 0,
                    discoSeqNum: e.discoSeqNum,
                    mediaOptionId: e.mediaOptionId
                }
            }
            static combineAppendDataInfoWithCompatInfo(e, t, i, r = 0) {
                const n = [...t];
                e.forEach((e, t) => null != e && e.initSeg ? n[t] = vf.convertInitSegToCompatInfo(e.initSeg) : null);
                t = n[yu.Variant].videoCodec, e = Hp(t);
                if (i && i.has(e)) {
                    const s = i.get(e);
                    n[yu.Variant].mimeType = n[yu.Variant].mimeType.replace(t, s), n[yu.Variant].videoCodec = s
                }
                return n
            }
            convertSourceBufferEntitiesToCompatInfo(e) {
                const t = e.sourceBufferEntities,
                    i = [null, null];
                return t.forEach((e, t) => {
                    e && (i[t] = {
                        mimeType: e.mimeType,
                        audioCodec: e.audioCodec,
                        videoCodec: e.videoCodec,
                        startPTSSec: void 0,
                        endPTSSec: void 0,
                        discoSeqNum: void 0,
                        mediaOptionId: null === (e = e.initSegmentInfo) || void 0 === e ? void 0 : e.mediaOptionId
                    })
                }), i
            }
            appendData(e, i, r) {
                const {
                    mediaQuery: t,
                    logger: n
                } = this, o = this.convertSourceBufferEntitiesToCompatInfo(t);
                return e.every(e => null == e) ? $i([]) : this.resetMediaSourceIfNeeded(e).pipe(La(e => e ? t.updating$.pipe(ln(e => !1 === e), Ds(1), Zs(e)) : $i(null)), La(t => {
                    if (!t) return $i([]);
                    let s = NaN,
                        a = NaN;
                    if (this.needSourceBuffers) {
                        s = performance.now();
                        const i = vf.combineAppendDataInfoWithCompatInfo(t, o, r, n);
                        this.createSourceBuffers(i), a = performance.now(), this.clearFlush(t)
                    }
                    return t.forEach(e => {
                        e = null == e ? void 0 : e.dataSeg;
                        null != e && e.cues && ne(null == e ? void 0 : e.texttrackIdx) && this.addCues(e.texttrackIdx, e.cues)
                    }), this.setStoreSbTimeoffsets(t), Jr(Zr(() => this.appendInitSegments(t, i)), Zr(() => this.appendDataSegments(t, i))).pipe(function(r, i) {
                        return 2 <= arguments.length ? function(e) {
                            return Bt(sa(r, i), Ws(1), (void 0 === (t = i) && (t = null), function(e) {
                                return e.lift(new is(t))
                            }))(e);
                            var t
                        } : function(e) {
                            return Bt(sa(function(e, t, i) {
                                return r(e, t)
                            }), Ws(1))(e)
                        }
                    }((e, t) => (e.push(t), e), new Array), hr(([i, r]) => {
                        const n = [null, null];
                        return [yu.Variant, yu.AltAudio].forEach(e => {
                            var t;
                            null != (null == i ? void 0 : i[e]) && (t = {
                                fragmentType: Vu(e),
                                bufferCreationStart: s,
                                bufferCreationEnd: a,
                                startInitAppend: i[e].startAppend,
                                endInitAppend: i[e].endAppend,
                                initBytesAppend: i[e].bytesAppend,
                                startDataAppend: r[e].startAppend,
                                endDataAppend: r[e].endAppend,
                                dataBytesAppend: r[e].bytesAppend
                            }, n[e] = t)
                        }), n
                    }), Za(e => {
                        this.adjustJaggedStart(t)
                    }))
                }), Ds(1))
            }
            endStream() {
                try {
                    this.mediaSourceAdapter.endOfStream()
                } catch (e) {
                    this.logger.warn(`endOfStream failed: ${e.message}`)
                }
            }
            setMediaKeys(e) {
                return this.teardownWG$.wrap(this.mediaKeysMutex.lock(() => Fr(this.mediaElement.setMediaKeys(e))).pipe(Za(() => {}), va(e => e.pipe(jr((e, t) => {
                    if (t < 3) return bn(100 * t);
                    throw e
                })))))
            }
            clearMediaKeys() {
                return Zr(() => {
                    if (!this.mediaElement) return Wu;
                    const e = -1 < navigator.userAgent.toLowerCase().indexOf("chrome"),
                        t = this.mediaElement.src;
                    return e && (this.mediaElement.src = ""), this.setMediaKeys(null).pipe(Za(() => this.mediaElement.src = t))
                })
            }
            set postFlushSeek(e) {
                this.mediaElementStore.postFlushSeek = e
            }
            schedulePostFlushSeek(e) {
                al(() => {
                    this.mediaQuery.seekTo && (this.seekTo = null), this.postFlushSeek = e
                })
            }
            set seekTo(e) {
                this.mediaElementStore.setSeekToPos(e, !1)
            }
            setSeekToWithDiscontinuity(e, t) {
                this.mediaElementStore.setSeekToPos(e, !1, t)
            }
            nudgeSeek(e, t) {
                al(() => {
                    this.mediaElementStore.setSeekToPos(e, !1), this.mediaElementStore.setNudgeInfo({
                        nudgeTarget: e,
                        nudgeCount: t
                    })
                })
            }
            set desiredRate(e) {
                this.mediaElementStore.desiredRate = e
            }
            toggleTrickPlaybackMode(e) {
                if (this.config.overridePlaybackRate) {
                    const t = e ? 2 : 1;
                    try {
                        this.mediaElement.playbackRate = t
                    } catch (e) {
                        this.logger.error({
                            name: "iframes"
                        }, `Exception when setting playbackRate=${t}: ${e.message}`)
                    }
                }
                const t = this.muteValueOnTrickPlaybackToggle;
                e && void 0 === t ? (this.muteValueOnTrickPlaybackToggle = this.mediaElement.muted, this.mediaElement.muted = e) : e || void 0 === t || (this.mediaElement.muted = t, this.muteValueOnTrickPlaybackToggle = void 0)
            }
            play() {
                this.mediaFunctions.play()
            }
            pause() {
                this.mediaFunctions.pause()
            }
            get expectPlayEvent() {
                return this.mediaFunctions.expectPlayEvent
            }
            set expectPlayEvent(e) {
                this.mediaFunctions.expectPlayEvent = e
            }
            get expectPauseEvent() {
                return this.mediaFunctions.expectPauseEvent
            }
            set expectPauseEvent(e) {
                this.mediaFunctions.expectPauseEvent = e
            }
            set textTracksCreated(e) {
                const t = this["mediaElementStore"];
                t.textTracksCreated = e
            }
            get msDuration() {
                return this._mediaQuery.msDuration
            }
            set msDuration(e) {
                try {
                    const t = this["mediaElementStore"],
                        i = this.mediaSource$.value;
                    i.duration !== e && (i.duration = e, t.msDuration = e)
                } catch (e) {
                    this.logger.warn(`Error setting duration ${e.message}`)
                }
            }
            set haveEnough(e) {
                this.mediaElementStore.haveEnough = e
            }
            set flushing(e) {
                this.mediaElementStore.flushing = e
            }
            set bufferMonitorTargetDuration(e) {
                this.mediaElementStore.bufferMonitorTargetDuration = e
            }
            get textTracks() {
                return this.mediaElement.textTracks
            }
            get id3TextTrack() {
                return this.id3Track
            }
            addTextTrack(e, t, i) {
                return this.mediaElement.addTextTrack(e, t, i)
            }
            dispatchEvent(e) {
                return this.mediaElement.dispatchEvent(e)
            }
            get offsetWidth() {
                return this.mediaElement.offsetWidth
            }
            get offsetHeight() {
                return this.mediaElement.offsetHeight
            }
            getliveSeekableWindow() {
                return this.liveSeekableWindow
            }
            archiveParsedSubtitleFragmentRecord(e, t, i) {
                return this.mediaElementStore.archiveParsedSubtitleFragmentRecord(e, t, i)
            }
            updateLiveSeekableRange(e) {
                var t = e.fragments,
                    e = t.length;
                if (1 < e) {
                    const i = Math.max(t[0].start, 0),
                        r = t[e - 1].start + t[e - 1].duration;
                    this.mediaSource$.value.updateLiveSeekableRange(i, r), this.liveSeekableWindow.start = i, this.liveSeekableWindow.end = r
                }
            }
            clearLiveSeekableRange() {
                this.mediaSource$.value.clearLiveSeekableRange(), this.liveSeekableWindow.start = NaN, this.liveSeekableWindow.end = NaN
            }
        }
        const Sf = (t, r, n, s, a, o, l, i) => {
                if (!t) return Ii;
                const e = Oc(t);
                return an(e.event("durationchange").pipe(hr(e => kc(t, "durationchange", e)), Za(e => {
                    e = e.currentTarget;
                    r.mediaElementDuration = e.duration
                })), e.event("seeking").pipe(ao(o.seekEventThrottleMs), hr(e => kc(t, "seeking", e)), Za(e => {
                    var t = e.currentTarget,
                        e = t.currentTime;
                    if (t.readyState >= t.HAVE_METADATA) {
                        const i = n.seekTo;
                        !i || !i.fromEvent && 1e-5 < Math.abs(i.pos - e) ? a.inGaplessMode ? function(e, t, i, r, n) {
                            let s = !1;
                            e < t.playingItem.itemStartOffset && (n.warn(`[Gapless] Seeking past track boundary oldSeek=${e}, adjustedSeek=${t.playingItem.itemStartOffset}`), e = t.playingItem.itemStartOffset, s = !0), t.isPreloading && (e > t.loadingItem.itemStartOffset && (n.warn(`[Gapless] Seeking past track boundary oldSeek=${e}, adjustedSeek=${t.loadingItem.itemStartOffset}`), e = t.loadingItem.itemStartOffset, s = !0), t.dequeueSource("SeekToUnbufferedTimeRanges")), s ? i.resetMediaSource(e) : r.setSeekToPos(e, !0)
                        }(e, a, s, r, l) : s && s.hasOwnProperty("liveSeekableWindow") && ne(s.getliveSeekableWindow().start) && ne(s.getliveSeekableWindow().end) && (e < s.getliveSeekableWindow().start || e > s.getliveSeekableWindow().end) ? function(e, t, i, r, n, s) {
                            let a = e;
                            if (e < t) a = t;
                            else if (i < e) {
                                let e = r.defaultTargetDuration;
                                ne(r.liveSyncDuration) ? e = r.liveSyncDuration : ne(r.liveSyncDurationCount) && (e = r.liveSyncDurationCount * r.defaultTargetDuration), a = Math.max(0, i - e)
                            }
                            s.warn(`[live] liveAdjustedSeek seekTo:${se(e,3)}, adjustedSeek:${se(a,3)}, liveWindowStart:${se(t,3)}, liveWindowEnd:${se(i,3)}`), n.setSeekToPos(a, !0)
                        }(e, s.getliveSeekableWindow().start, s.getliveSeekableWindow().end, o, r, l) : r.setSeekToPos(e, !0) : r.seeking = !0
                    }
                })), e.event("seeked").pipe(hr(e => kc(t, "seeked", e)), Za(() => {
                    r.setSeekToPos(null, !0)
                })), e.event("play").pipe(hr(e => kc(t, "play", e)), bo(n.desiredRate$), hr(([e]) => {
                    var t = e.currentTarget;
                    r.paused = t.paused;
                    var i = s.expectPlayEvent,
                        t = t.controls || o.nativeControlsEnabled;
                    return !i && t && (s.checkForReplay(), r.desiredRate = 1), s.expectPlayEvent = !1, e
                })), e.event("playing").pipe(hr(e => kc(t, "playing", e)), Za(e => {
                    e = e.currentTarget;
                    r.paused = e.paused, r.gotPlayingEvent()
                })), e.event("loadstart").pipe(hr(e => kc(t, "loadstart", e)), Za(() => {
                    r.gotLoadStartEvent()
                })), e.event("pause").pipe(hr(e => kc(t, "pause", e)), Za(e => {
                    var t = e.currentTarget;
                    r.paused = t.paused;
                    e = s.expectPauseEvent, t = t.controls || o.nativeControlsEnabled;
                    !e && t && (r.desiredRate = 0), s.expectPauseEvent = !1
                })), e.event("loadedmetadata").pipe(hr(e => kc(t, "loadedmetadata", e))), e.event("loadeddata").pipe(hr(e => kc(t, "loadeddata", e))), e.event("canplay").pipe(hr(e => kc(t, "canplay", e))), e.event("canplaythrough").pipe(hr(e => kc(t, "canplaythrough", e))), e.event("waiting").pipe(hr(e => kc(t, "waiting", e))), e.event("emptied").pipe(hr(e => kc(t, "emptied", e))), e.event("error").pipe(hr(e => kc(t, "error", e)), Wn(e => Vi(t.error))), e.event("ended").pipe(hr(e => kc(t, "ended", e)))).pipe(bo(n.bufferedRangeTuple$), ll(([e]) => {
                    var t = e.currentTarget,
                        e = t.readyState;
                    r.readyState = e, r.ended = t.ended
                }), Vn(e => (e instanceof MediaError ? (l.warn(`mediaElementError, code: ${e.code}, message: ${e.message}`), null == i || i.handleMediaElementError(e)) : l.error(`media event error: ${e.message}`), Ii)), $a(on), Vn(e => e instanceof MediaError ? (l.warn(`mediaElementError, code: ${e.code}, message: ${e.message}`), Vi(e)) : (l.error(`media event error: ${e.message}`), Ii)))
            },
            bf = new class extends fl {
                constructor() {
                    super({}, {
                        name: "media-element-store",
                        producerFn: su
                    }), this._activeId = ""
                }
                get activeId() {
                    return this._activeId
                }
                startMediaSession(i, r, n, s) {
                    return Do("playback.session.start"), this._activeId = `media session: ${(new Date).toISOString()}`, al(() => {
                        var e = s,
                            t = Math.max(e, r - e),
                            t = {
                                id: this.activeId,
                                desiredRate: !i.autoplay && i.paused ? 0 : 1,
                                paused: i.paused,
                                gotPlaying: !1,
                                gotLoadStart: !1,
                                firstPlayTime: void 0,
                                seeking: i.seeking,
                                flushing: !1,
                                readyState: i.readyState,
                                ended: i.ended,
                                bufferedRanges: [],
                                haveEnough: !1,
                                mediaSourceEntity: null,
                                expectedSbCount: NaN,
                                bufferMonitorInfo: {
                                    waterLevelType: null,
                                    almostDryWaterLevelSeconds: n,
                                    lowWaterLevelSeconds: e,
                                    highWaterLevelSeconds: t,
                                    maxBufferSeconds: r
                                },
                                mediaOptionParsedSubtitleRecord: [],
                                textTracksCreated: !1,
                                waitingForDisco: !1
                            };
                        this.add(t), this.setActive(this.activeId)
                    }), this.logger = Qe().child({
                        name: "UpdateBufferedSegments"
                    }), this.activeId
                }
                setMediaSourceEntity(t, i) {
                    Do("playback.set.msObjectUrl"), this.updateActive(e => {
                        e.mediaSourceEntity = null != t && null != i ? {
                            objectUrl: t,
                            readyState: i,
                            duration: NaN,
                            sourceBufferEntities: [null, null]
                        } : null, e.bufferedRanges = [], e.haveEnough = !1, e.readyState = 0, e.bufferMonitorInfo.waterLevelType = null
                    })
                }
                set mediaElementDuration(t) {
                    Do("playback.set.mediaElementDuration"), this.updateActive(e => {
                        e && (e.mediaElementDuration = t)
                    })
                }
                set msReadyState(t) {
                    Do("playback.set.msReadyState"), this.updateActive(({
                        mediaSourceEntity: e
                    }) => {
                        e && (e.readyState = t)
                    })
                }
                set readyState(t) {
                    Do(`playback.set.readyState ${t}`), this.updateActive(e => {
                        e.readyState = t
                    })
                }
                set ended(t) {
                    Do(`playback.set.ended ${t}`), this.updateActive(e => {
                        e.ended = t
                    })
                }
                set msDuration(t) {
                    Do("playback.set.msDuration"), this.updateActive(e => {
                        e.mediaSourceEntity.duration = t
                    })
                }
                set textTracksCreated(t) {
                    Do("playback.set.textTracksCreated ${created}"), this.updateActive(e => {
                        e.textTracksCreated = t
                    })
                }
                set expectedSbCount(t) {
                    Do("playback.set.expectedSbCount"), this.updateActive(e => {
                        e.expectedSbCount = t
                    })
                }
                set postFlushSeek(e) {
                    this.updateActive({
                        postFlushSeek: e
                    })
                }
                setSeekToPos(t, i, r) {
                    Do(`playback.set.seekToPos: ${null==t?void 0:t.toFixed(3)} cc: ${r}`), this.updateActive(e => {
                        ne(t) ? (e.seekTo = {
                            pos: t,
                            fromEvent: i,
                            discoSeqNum: r
                        }, e.gotPlaying = !1, e.haveEnough = !1) : (e.seekTo = null, e.postFlushSeek = void 0), i && (e.seeking = ne(t))
                    })
                }
                set seeking(t) {
                    Do(`playback.set.seeking: ${t}`), this.updateActive(e => {
                        e.seeking = t
                    })
                }
                set paused(t) {
                    Do(`playback.set.paused: ${t}`), this.updateActive(e => {
                        (e.paused = t) && (e.gotPlaying = !1)
                    })
                }
                gotPlayingEvent() {
                    Do("playback.set.playing"), this.updateActive(e => {
                        e.paused || (e.gotPlaying = !0, e.firstPlayTime = e.firstPlayTime || performance.now())
                    })
                }
                gotLoadStartEvent() {
                    Do("playback.set.loadstart"), this.updateActive(e => {
                        e.gotLoadStart = !0
                    })
                }
                set desiredRate(t) {
                    Do(`playback.set.desiredRate: ${t}`), this.updateActive(e => {
                        e.desiredRate = t
                    })
                }
                set haveEnough(t) {
                    Do(`playback.set.haveEnough: ${t}`), this.updateActive(e => {
                        e.haveEnough = t
                    })
                }
                set flushing(e) {
                    Do(`playback.set.flushing: ${e}`), this.updateActive({
                        flushing: e
                    })
                }
                set waitingForDisco(t) {
                    Do(`playback.set.waitingForDisco: ${t}`), this.updateActive(e => {
                        e && (e.waitingForDisco = t)
                    })
                }
                setSourceBufferUpdating(i) {
                    Do(`playback.set.sourcebuffers[${Uu[i]}].updating`), this.updateActive(({
                        mediaSourceEntity: e
                    }) => {
                        const t = null === (e = null == e ? void 0 : e.sourceBufferEntities) || void 0 === e ? void 0 : e[i];
                        t && (t.updating = !0, t.error = void 0)
                    })
                }
                setTimestampOffset(i, r) {
                    Do(`playback.set.sourcebuffers[${Uu[i]}].timestampOffset`), this.updateActive(({
                        mediaSourceEntity: e
                    }) => {
                        const t = null === (e = null == e ? void 0 : e.sourceBufferEntities) || void 0 === e ? void 0 : e[i];
                        t && (t.timestampOffset = r)
                    })
                }
                setBufferedRangesUpdated(a, o, l, d, u) {
                    Do(`playback.set.sourcebuffers[${Uu[a]}].bufferupdated`), this.updateActive(e => {
                        var t, i, r;
                        const n = null == e ? void 0 : e.mediaSourceEntity,
                            s = null === (r = null == n ? void 0 : n.sourceBufferEntities) || void 0 === r ? void 0 : r[a];
                        if (s) {
                            const a = null == n ? void 0 : n.duration;
                            s.updating = !1, s.bufferedRanges = [...o], t = s, i = t.inFlight, r = t.bufferedSegments, i && ne(i.startPTS) && ne(i.endPTS) && function(t, i) {
                                    let r = !1;
                                    for (let e = t.length - 1; - 1 < e; e--) {
                                        const s = t[e],
                                            a = Math.max(i.startPTS, s.startPTS),
                                            o = Math.min(i.endPTS, s.endPTS);
                                        var n;
                                        o <= a || ((n = (1 - (o - a) / (s.endPTS - s.startPTS)) * s.bytes) <= 0 ? t.splice(e, 1) : (s.bytes = n, s.startPTS < i.startPTS ? s.endPTS = a : (s.startPTS = o, r || (t.splice(e, 0, i), r = !0))))
                                    }
                                    r || t.push(i)
                                }(r, i), t.inFlight = null,
                                function(e, t, i, r, n) {
                                    const {
                                        maxBufferHole: s,
                                        bufferedSegmentEjectionToleranceMs: a
                                    } = r, o = e.bufferedSegments, l = e.bufferedRanges;
                                    let d, u = 0,
                                        c = !1;
                                    if (l.length)
                                        for (let e = o.length - 1; - 1 < e; e--) {
                                            const t = o[e],
                                                r = !t.frag.iframe;
                                            r && t.frag.isLastFragment && (d = t.frag);
                                            var h = t.endPTS - t.startPTS;
                                            if (h <= 0) o.splice(e, 1), null == n || n.warn(`Ejecting segment from bufferedSegments due to segmentDuration <= 0 > segment=${ae(t)}`), c = t.frag === d;
                                            else {
                                                var p = Bp(l, t);
                                                if (p) {
                                                    var f = Math.max(p.start, t.startPTS),
                                                        p = Math.min(p.end, t.endPTS),
                                                        f = p - f;
                                                    if (u += t.bytes * f / h, r)
                                                        if (f < Math.min(h, s)) o.splice(e, 1), null == n || n.warn(`Ejecting segment from bufferedSegments due to tiny overlaps > segment=${ae(t)}, bufferedRanges=${ae(l)}`), c = t.frag === d;
                                                        else {
                                                            const r = t.appendedDuration,
                                                                u = (r || 0) - f,
                                                                m = Math.min(.001 * a, h);
                                                            r ? !(u > m && f != h) || t.frag.isLastFragment && p === i || (o.splice(e, 1), null == n || n.warn(`Ejecting segment from bufferedSegments due to change in current overlap > segment=${ae(t)}, delta=${u}, bufferedRanges=${ae(l)}`), c = t.frag === d) : t.appendedDuration = f
                                                        }
                                                } else null == n || n.warn(`Ejecting segment from bufferedSegments due to no overlap > segment=${ae(t)}, bufferedRanges=${ae(l)}`), o.splice(e, 1), c = t.frag === d
                                            }
                                        } else o.length && o.splice(0, o.length);
                                    e.totalDuration = d && !c && 0 < l.length ? l[l.length - 1].end : 1 / 0, e.gotQuotaExceeded = e.gotQuotaExceeded || t, e.totalBytes = u, e.maxTotalBytes = Math.max(e.totalBytes, e.maxTotalBytes)
                                }(s, d, a, u, this.logger)
                        }
                        e.bufferedRanges = [...l]
                    })
                }
                setSourceBufferEntity(n, s) {
                    Do(`playback.set.sourcebuffers[${Uu[n]}].setSourceBufferEntity`), this.updateActive(({
                        mediaSourceEntity: e
                    }) => {
                        var t, i, r;
                        e && ({
                            mimeType: t,
                            audioCodec: i,
                            videoCodec: r
                        } = s, e.sourceBufferEntities[n] = {
                            mimeType: t,
                            audioCodec: i,
                            videoCodec: r,
                            updating: !1,
                            bufferedRanges: [],
                            timestampOffset: 0,
                            inFlight: null,
                            bufferedSegments: [],
                            totalBytes: 0,
                            maxTotalBytes: 0,
                            gotQuotaExceeded: !1,
                            totalDuration: 1 / 0
                        })
                    })
                }
                setInflightSegment(i, r) {
                    Do(`playback.set.sourcebuffers[${Uu[i]}].setInflightSegment`), this.updateActive(({
                        mediaSourceEntity: e
                    }) => {
                        const t = null === (e = null == e ? void 0 : e.sourceBufferEntities) || void 0 === e ? void 0 : e[i];
                        t && (t.inFlight = r)
                    })
                }
                setInitSegmentEntity(i, r) {
                    Do(`playback.set.sourcebuffers[${Uu[i]}].setInitSegmentEntity`), this.updateActive(({
                        mediaSourceEntity: e
                    }) => {
                        const t = null === (e = null == e ? void 0 : e.sourceBufferEntities) || void 0 === e ? void 0 : e[i];
                        t && (t.initSegmentInfo = r)
                    })
                }
                setSourceBufferError(i, r) {
                    Do(`playback.set.sourcebuffers[${i}].error: ${r}`), this.updateActive(({
                        mediaSourceEntity: e
                    }) => {
                        const t = null === (e = null == e ? void 0 : e.sourceBufferEntities) || void 0 === e ? void 0 : e[i];
                        t && (t.inFlight = null, t.updating = !1, t.error = r)
                    })
                }
                setStallInfo(t) {
                    Do(`playback.set.stallInfo stalled=${null!=t}`), this.updateActive(e => {
                        e.stallInfo = t
                    })
                }
                setNudgeInfo(t) {
                    Do(`playback.set.nudgeInfo ${ae(t)}`), this.updateActive(e => {
                        e.nudgeInfo = t
                    })
                }
                updateWaterLevels(t, i) {
                    Do("playback.set.updateWaterLevels"), this.updateActive(e => {
                        e.bufferMonitorInfo.waterLevelType = {
                            combined: t,
                            sbTuple: [...i]
                        }
                    })
                }
                set bufferMonitorTargetDuration(i) {
                    Do(`playback.set.targetDuration: ${i}`), this.updateActive(e => {
                        if (ne(i) && 0 < i) {
                            const t = e.bufferMonitorInfo;
                            t.lowWaterLevelSeconds = Math.min(i, t.maxBufferSeconds), t.highWaterLevelSeconds = Math.max(t.lowWaterLevelSeconds, t.maxBufferSeconds - i)
                        }
                    })
                }
                archiveParsedSubtitleFragmentRecord(i, r, n) {
                    Do(`playback.cues.set persistentId ${i} mediaSeqNum ${r}: parsed ${n.count} time-range ${n.startTime}:${n.endTime}`), this.updateActive(e => {
                        let t = e.mediaOptionParsedSubtitleRecord[i];
                        t || (t = {}, e.mediaOptionParsedSubtitleRecord[i] = t), t[r] = n
                    })
                }
            };
        class Tf extends bi {
            constructor(e) {
                super(e), this.store = e, this.displaySupportsHdr$ = this.select("supportsHdr"), this.platformInfo$ = this.select("platformInfo"), this.viewportInfo$ = this.select("viewportInfo")
            }
            get platformInfo() {
                return this.getValue().platformInfo
            }
            get displaySupportsHdr() {
                return this.getValue().supportsHdr
            }
            get viewportInfo() {
                return this.getValue().viewportInfo
            }
        }
        class Ef {
            constructor(e) {
                this.store = e
            }
            getQuery() {
                return new Tf(this.store)
            }
            updateSupportsHdr(t) {
                this.store.update(e => {
                    e.supportsHdr = t
                })
            }
            updatePlatformInfo(e) {
                this.store.update({
                    platformInfo: e
                })
            }
            updateViewportInfo(t) {
                this.store.update(e => {
                    e.viewportInfo = t
                })
            }
        }
        const If = new class extends dl {
            constructor() {
                super({
                    supportsHdr: !0
                }, {
                    name: "platform",
                    producerFn: su
                })
            }
        };
        let wf = null;

        function Af() {
            return wf = wf || new Ef(If), wf
        }
        class Of extends $t {
            constructor(e, t) {
                super(e => {
                    null == t || t.add(), e.add(this._handler$.pipe(jr(([e, t, i]) => e(...t).pipe(Za({
                        next(e) {
                            i(e, null)
                        },
                        error(e) {
                            i(null, e)
                        }
                    })))).subscribe())
                }), this._vanillaRPC = e, this.teardownWG$ = t, this._handler$ = new Xt
            }
            register(e, i) {
                return this._vanillaRPC.register(e, (...t) => e => {
                    this._handler$.next([i, t, e])
                })
            }
            invoke(e, t, r) {
                return new $t(i => {
                    this._vanillaRPC.invoke(e, t, r)((e, t) => {
                        null != t ? i.error(t) : (i.next(e), i.complete())
                    })
                })
            }
        }
        class kf extends Of {
            constructor(e) {
                super(e)
            }
            decrypt(e, t, i, r, n) {
                return this.invoke("decrypt", [e, t, i, r, n], [e, t, r])
            }
        }
        class Cf extends Of {
            constructor(e) {
                super(e), this.rpcService = e, this.sessions = {}, this._onEvent = (e, t, i) => () => {
                    null != this.sessions[e] && this.sessions[e].observer.trigger(t, i)
                }, this.rpcService.register("demuxer.event", this._onEvent)
            }
            init(e, t, i) {
                return [{
                    maxSeekHole: r,
                    maxBufferHole: n,
                    audioPrimingDelay: s,
                    stretchShortVideoTrack: a,
                    forceKeyFrameOnDiscontinuity: o
                }] = [t], this.invoke("demuxer.init", [e, t = {
                    maxSeekHole: r,
                    maxBufferHole: n,
                    audioPrimingDelay: s,
                    stretchShortVideoTrack: a,
                    forceKeyFrameOnDiscontinuity: o
                }, i], []).pipe(hr(e => {
                    var t = new Df(this, e);
                    return this.sessions[e] = t
                }));
                var r, n, s, a, o
            }
        }
        class Df {
            constructor(e, t) {
                this.rpc = e, this.demuxSessionID = t, this.observer = new a
            }
            push(e, t, i, r, n, s, a, o, l, d, u, c, h) {
                return this.rpc.invoke("demuxer.push", [this.demuxSessionID, e, t, i, r, n, s, a, o, l, d, u, c], null != h ? h : [e])
            }
            pushWithoutTransfer(e, t, i, r, n, s, a, o, l, d, u, c) {
                return this.push(e, t, i, r, n, s, a, o, l, d, u, c, [])
            }
            destroy() {
                this.observer.removeAllListeners(), this.rpc.invoke("demuxer.destroy", [this.demuxSessionID], []).subscribe()
            }
        }
        class Mf {
            constructor() {
                this.handlers = {}
            }
            register(e, t) {
                if (null != this.handlers[e]) return !1;
                this.handlers[e] = t
            }
            unregister(e) {
                if (null != this.handlers[e]) return !1;
                delete this.handlers[e]
            }
            invoke(e, i) {
                return (t = Mf._fallbackCallback) => {
                    try {
                        if (null == this.handlers[e]) throw new Error(`command ${e} not found`);
                        this.handlers[e](...i)(t)
                    } catch (e) {
                        t(void 0, e)
                    }
                }
            }
            teardown(e) {
                this.handlers = null, e()
            }
        }
        Mf._fallbackCallback = (e, t) => {
            if (null != t) throw t
        };
        const xf = e => {
            e = e.child({
                name: "InlineRPCService"
            });
            var t = new Mf;
            return new i(t, e), new ot(t, e), t
        };
        let Pf;
        const Rf = e => {
                try {
                    if (null == Pf) {
                        const e = new Blob(["var exports = {};var module = { exports: exports };function define(f){f()};define.amd = true;(" + Xy.toString() + ")(true);"], {
                                type: "text/javascript"
                            }),
                            r = URL.createObjectURL(e);
                        Pf = new Worker(r)
                    }
                    var t = new lt(Pf);
                    return i = t, n = e.child({
                        name: "WorkerRPCService"
                    }), i.register("logger.log", (e, i, ...r) => t => {
                        try {
                            for (const i of e) n = n.child(i);
                            "function" == typeof n[i] && n[i](...r), t()
                        } catch (e) {
                            t(void 0, e)
                        }
                    }), t
                } catch (e) {
                    throw new Error("Failed to create WebWorker")
                }
                var i, n
            },
            Lf = (...r) => i => {
                for (let t = 0; t < r.length; t++) {
                    const e = r[t];
                    try {
                        return e(i)
                    } catch (e) {
                        if (t === r.length - 1) throw e;
                        i.warn(e)
                    }
                }
            },
            _f = e => Lf(Rf, xf)(e);
        class Nf {}
        Nf.PlayEnded = 6101, Nf.Periodic = 6110, Nf.PlayStalled = 6103, Nf.KeySessionComplete = 6104, Nf.PlayLikelyToKeepUp = 6105, Nf.PlayRateChanged = 6106, Nf.PlayError = 6107, Nf.MediaEngineStalled = 6108, Nf.SwitchComplete = 6109, Nf.VariantEnded = 6111, Nf.NwError = 6202;
        const Ff = {
            avc1: 1,
            avc3: 1,
            hvc1: {
                SDR: 2,
                HLG: 10,
                PQ: 11
            },
            hev1: {
                SDR: 2,
                HLG: 10,
                PQ: 11
            },
            vp09: {
                SDR: 3,
                HLG: 14,
                PQ: 13
            },
            dvh1: {
                PQ: 12
            }
        };
        class Bf {
            constructor(e, t) {
                this.query = e, this.logger = t
            }
            setReportingAgent(e) {
                this.reportingAgent = e
            }
            sendPlayEnded(e) {
                var t = Nf.PlayEnded;
                this.fillAndFire(t, this.query.playEnded(e))
            }
            sendPlayStalled(e) {
                var t = Nf.PlayStalled;
                this.fillAndFire(t, this.query.playStalled(e))
            }
            sendMediaEngineStalled(e) {
                var t = Nf.MediaEngineStalled;
                this.fillAndFire(t, this.query.mediaEngineStalled(e))
            }
            sendKeySessionComplete(e) {
                var t = Nf.KeySessionComplete;
                this.fillAndFire(t, this.query.keySessionComplete(e))
            }
            sendPlayLikelyToKeepUp(e) {
                var t = Nf.PlayLikelyToKeepUp;
                this.fillAndFire(t, this.query.playLikelyToKeepUp(e))
            }
            sendPlayRateChange(e) {
                var t = Nf.PlayRateChanged;
                this.fillAndFire(t, this.query.playRateChanged(e))
            }
            sendSwitchComplete(e) {
                var t = Nf.SwitchComplete;
                this.fillAndFire(t, this.query.switchComplete(e))
            }
            sendVariantEnded(e) {
                var t = Nf.VariantEnded;
                this.fillAndFire(t, this.query.variantEnded(e))
            }
            sendPlayError(e) {
                var t = Nf.PlayError;
                this.fillAndFire(t, this.query.playError(e))
            }
            sendNwError(e) {
                var t = Nf.NwError;
                this.fillAndFire(t, this.query.nwError(e))
            }
            sendPeriodic(e) {
                var t = Nf.Periodic;
                this.fillAndFire(t, this.query.periodic(e))
            }
            fillAndFire(e, t) {
                if (e !== Nf.Periodic || t.PlayTimeWC || t.ADT) {
                    var r = e === Nf.PlayEnded || e === Nf.Periodic ? 1 : 0;
                    if (this.reportingAgent) {
                        let i = {};
                        Object.entries(t).forEach(([e, t]) => {
                            "object" == typeof(t = ne(t) ? Number(Number(t).toFixed(2)) : t) ? "ServerInfo" === e && Object.entries(t).forEach(([e, t]) => {
                                i[e] = t
                            }): i[e] = t
                        }), i = JSON.parse(JSON.stringify(i));
                        try {
                            this.reportingAgent.issueReportingEvent(e, i, r)
                        } catch (e) {}
                    }
                }
            }
        }
        class Uf extends kl {
            constructor(e, t) {
                super(e), this.logger = t
            }
            get activeEntity() {
                return this.getActive()
            }
            entity(e) {
                return this.getEntity(e)
            }
            playEnded(e) {
                return null === (e = this.getEntity(e)) || void 0 === e ? void 0 : e.playEndedRecord
            }
            periodic(e) {
                return null === (e = this.getEntity(e)) || void 0 === e ? void 0 : e.periodicRecord
            }
            playStalled(e) {
                return null === (e = this.getEntity(e)) || void 0 === e ? void 0 : e.playStalledRecord
            }
            mediaEngineStalled(e) {
                return null === (e = this.getEntity(e)) || void 0 === e ? void 0 : e.mediaEngineStalledRecord
            }
            keySessionComplete(e) {
                return null === (e = this.getEntity(e)) || void 0 === e ? void 0 : e.keySessionCompleteRecord
            }
            playLikelyToKeepUp(e) {
                return null === (e = this.getEntity(e)) || void 0 === e ? void 0 : e.playLikelyToKeepUpRecord
            }
            playRateChanged(e) {
                return null === (e = this.getEntity(e)) || void 0 === e ? void 0 : e.playRateChangedRecord
            }
            switchComplete(e) {
                return null === (e = this.getEntity(e)) || void 0 === e ? void 0 : e.switchCompleteRecord
            }
            variantEnded(e) {
                return null === (e = this.getEntity(e)) || void 0 === e ? void 0 : e.variantEndedRecord
            }
            playError(e) {
                return null === (e = this.getEntity(e)) || void 0 === e ? void 0 : e.playErrorRecord
            }
            nwError(e) {
                return null === (e = this.getEntity(e)) || void 0 === e ? void 0 : e.nwErrorRecord
            }
        }
        class $f extends fl {
            constructor(e) {
                super({}, {
                    name: "rtc-store",
                    idKey: "itemId",
                    producerFn: su,
                    resettable: !0
                }), this.logger = e
            }
            createEntity(e) {
                e = {
                    itemId: e,
                    sessionControlRecord: {
                        state: "RTC_STATE_INIT",
                        rate: 0,
                        oldRate: 0,
                        eventStartTime: Date.now(),
                        sessionStartTime: Date.now(),
                        lastLikelyToKeepUpTime: Date.now(),
                        lastPeriodicTime: Date.now(),
                        playLikelyToKeepUpEventCounter: 1,
                        periodicEventCounter: 1,
                        activeKeySessions: {},
                        intervalVariantList: {},
                        sessionVariantList: {}
                    },
                    playEndedRecord: {},
                    periodicRecord: {},
                    playStalledRecord: {},
                    keySessionCompleteRecord: {},
                    playLikelyToKeepUpRecord: {},
                    playRateChangedRecord: {},
                    playErrorRecord: {},
                    mediaEngineStalledRecord: {},
                    switchCompleteRecord: {},
                    variantEndedRecord: {},
                    nwErrorRecord: {}
                };
                this.add(e)
            }
            updateEnded(e) {
                this._prepareEventPlayEnded(e)
            }
            updatePeriodic(e, t) {
                this._prepareEventPeriodic(e, {
                    isFinal: t
                })
            }
            updateBufferStalled(e, t) {
                this.update(e, ({
                    sessionControlRecord: e,
                    variantEndedRecord: t,
                    periodicRecord: i,
                    playEndedRecord: r
                }) => {
                    e.rate = 0, t.StallCount = (t.StallCount || 0) + 1, i.StallCount = (i.StallCount || 0) + 1, r.StallCount = (r.StallCount || 0) + 1
                }), this._prepareEventPlayStalled(e, t)
            }
            updateSegmentKeyLoaded(e, r) {
                this.update(e, ({
                    sessionControlRecord: e
                }) => {
                    const t = {},
                        i = r.timestamp;
                    t.keyFormat = "identity", t.keyDeliveryTime = r.adt, t.currentMediaTime = r.currentTime, "RTC_STATE_INIT" === e.state && (t.keyInitTime = i - e.sessionStartTime), e.activeKeySessions[r.keyuri] = t
                }), this._prepareEventKeySessionComplete(e, r)
            }
            updateLicenseResponseProcessed(e, i) {
                this.update(e, ({
                    sessionControlRecord: e
                }) => {
                    const t = e.activeKeySessions[i.keyuri];
                    t.licenseResponseProcessTime = i.timestamp - t.licenseResponseSubmitTime, e.lastKeyDeliveryTime = t.keyDeliveryTime = i.timestamp - t.licenseChallengeStartTime, t.currentMediaTime = i.currentTime, e.finishedKeyUri = i.keyuri
                }), this._prepareEventKeySessionComplete(e, i)
            }
            updateLicenseChallengeError(e, i) {
                this.update(e, ({
                    sessionControlRecord: e
                }) => {
                    const t = e.activeKeySessions[i.keyuri];
                    e.lastKeyErrorType = t.keyErrorType = "licenseChallengeError", e.finishedKeyUri = i.keyuri
                }), this._prepareEventKeySessionComplete(e, i)
            }
            updateLicenseResponseError(e, i) {
                this.update(e, ({
                    sessionControlRecord: e
                }) => {
                    const t = e.activeKeySessions[i.keyuri];
                    e.lastKeyErrorType = t.keyErrorType = "licenseResponseError", e.finishedKeyUri = i.keyuri
                }), this._prepareEventKeySessionComplete(e, i)
            }
            updateKeyAborted(e, t) {
                this.update(e, ({
                    sessionControlRecord: e
                }) => {
                    e.activeKeySessions[t.keyuri].keyErrorType = "keyAborted", e.finishedKeyUri = t.keyuri
                }), this._prepareEventKeySessionComplete(e, t)
            }
            updateCanPlay(e, t) {
                this.update(e, ({}) => {}), this._prepareEventPlayLikelyToKeepUp(e, t)
            }
            updateRateChanged(e, t) {
                this.update(e, ({
                    sessionControlRecord: e
                }) => {
                    e.rate = 100 * t.rate, 0 < t.rate && 0 === e.oldRate && (e.playInfo || (e.playInfo = []), e.playInfo.push({
                        latency: t.latency
                    }), e.curLevelUrl || (e.curLevelUrl = t.url))
                }), this._prepareEventPlayRateChanged(e, t)
            }
            updateMediaError(e, r) {
                this.update(e, ({
                    sessionControlRecord: e,
                    periodicRecord: t,
                    playEndedRecord: i
                }) => {
                    t.PlayerErrCount = (t.PlayerErrCount || 0) + 1, i.PlayerErrCount = (i.PlayerErrCount || 0) + 1, r.fatal && (e.rate = 0, t.FatalPlayerErrCount = (t.FatalPlayerErrCount || 0) + 1, i.FatalPlayerErrCount = (i.FatalPlayerErrCount || 0) + 1, i.ErrCode = r.details, i.ErrReason = r.code, i.ErrIsFatal = !0, i.ErrDomain = "mediaError")
                }), r.fatal ? this._prepareEventPlayError(e, r) : this.update(e, ({
                    sessionControlRecord: e
                }) => {
                    var t = r.details + "/" + r.code;
                    e.nonFatalPlayErrList[t] = (e.nonFatalPlayErrList[t] || 0) + 1
                })
            }
            updateMediaElementError(e, t) {
                let i;
                try {
                    i = JSON.parse(t.message)
                } catch (e) {
                    this.logger.warn(`message is not JSON, ignoring; ${t.message}`)
                }
                var r = i ? parseInt(i.ErrReason) : null,
                    n = i ? parseInt(i.ErrDetail) : null;
                this._prepareEventPlayError(e, {
                    domain: "mediaElementError",
                    mediaElemCode: t.code,
                    mediaElemReason: r,
                    mediaElemDetail: n,
                    code: null,
                    details: null,
                    fatal: null
                })
            }
            updateMediaEngineStalled(e, t) {
                this.update(e, ({
                    sessionControlRecord: e,
                    variantEndedRecord: t,
                    periodicRecord: i,
                    playEndedRecord: r
                }) => {
                    e.rate = 0, t.MediaEngineStallCount = (t.MediaEngineStallCount || 0) + 1, i.MediaEngineStallCount = (i.MediaEngineStallCount || 0) + 1, r.MediaEngineStallCount = (r.MediaEngineStallCount || 0) + 1
                }), this._prepareEventMediaEngineStalled(e, t)
            }
            updateLevelSwitched(e, d) {
                this.update(e, ({
                    sessionControlRecord: e,
                    switchCompleteRecord: t,
                    periodicRecord: i,
                    playEndedRecord: r
                }) => {
                    i.SwCnt = (i.SwCnt || 0) + 1, r.SwCnt = (r.SwCnt || 0) + 1;
                    var n = Date.now(),
                        s = e.curLevelUrl,
                        a = d.url,
                        i = this._getVariantInfo(s, e),
                        r = this._getVariantInfo(a, e);
                    let o, l = !1;
                    s && (o = r.bandwidth < i.bandwidth ? "Down" : "Up", l = r.iframes), t.BadSw = this._isBadSw(o, e.lastSwitchDir || o, l, e.lastLevelIsIframe || l, n, e.lastSwitchTime || n, d.isSeeking), e.lastSwitchDir = o, e.lastSwitchTime = n, e.lastLevelIsIframe = l, e.curLevelUrl = a, e.variantStartTimeMedia = d.currentTime
                }), this._prepareEventSwitchComplete(e, d)
            }
            updateLevelLoadError(e, o) {
                this.update(e, ({
                    sessionControlRecord: e,
                    switchCompleteRecord: t,
                    periodicRecord: i,
                    playEndedRecord: r
                }) => {
                    var n = Date.now();
                    let s, a = !1;
                    if (e.curLevelUrl) {
                        const t = this._getVariantInfo(e.curLevelUrl, e),
                            i = this._getVariantInfo(o.url, e);
                        s = i.bandwidth < t.bandwidth ? "Down" : "Up", a = i.iframes
                    }
                    i.SwCnt = (i.SwCnt || 0) + 1, r.SwCnt = (r.SwCnt || 0) + 1, t.BadSw = this._isBadSw(s, e.lastSwitchDir || s, a, e.lastLevelIsIframe || a, n, e.lastSwitchTime || n, o.isSeeking), t.SwFail = !0
                }), this._prepareEventSwitchComplete(e, o)
            }
            updateVariantEnd(e, t) {
                this._prepareEventVariantEnded(e, t)
            }
            updateNwError(e, r) {
                this.update(e, ({
                    sessionControlRecord: e,
                    periodicRecord: t,
                    playEndedRecord: i
                }) => {
                    t.NwErrCount = (t.NwErrCount || 0) + 1, i.NwErrCount = (i.NwErrCount || 0) + 1, r.fatal && (e.rate = 0, t.FatalNwErrCount = (t.FatalNwErrCount || 0) + 1, i.FatalNwErrCount = (i.FatalNwErrCount || 0) + 1, i.ErrCode = r.details, i.ErrReason = r.code, i.ErrIsFatal = !0, i.ErrDomain = "networkError")
                }), r.fatal ? this._prepareEventNwError(e, r) : this.update(e, ({
                    sessionControlRecord: e
                }) => {
                    var t = r.details + "/" + r.code;
                    e.nonFatalNwErrList[t] = (e.nonFatalNwErrList[t] || 0) + 1
                })
            }
            finalize(e, t) {
                switch (t) {
                    case Nf.PlayEnded:
                        this.update(e, ({
                            sessionControlRecord: e
                        }) => {
                            e.state = "RTC_STATE_STOP", e.oldRate = 0
                        }), this.update(e, e => {
                            e.playEndedRecord = {}
                        });
                        break;
                    case Nf.Periodic:
                        this.update(e, ({
                            sessionControlRecord: t
                        }) => {
                            t.lastPeriodicTime = Date.now(), t.periodicEventCounter += 1, Object.keys(t.intervalVariantList).forEach(e => {
                                t.intervalVariantList[e].playTime = 0
                            })
                        }), this.update(e, e => {
                            e.periodicRecord = {}
                        });
                        break;
                    case Nf.PlayStalled:
                        this.update(e, ({
                            sessionControlRecord: e
                        }) => {
                            e.state = "RTC_STATE_STALL", e.oldRate = 0
                        }), this.update(e, e => {
                            e.playStalledRecord = {}
                        });
                        break;
                    case Nf.KeySessionComplete:
                        this.update(e, ({
                            sessionControlRecord: e
                        }) => {
                            delete e.activeKeySessions[e.finishedKeyUri]
                        }), this.update(e, e => {
                            e.keySessionCompleteRecord = {}
                        });
                        break;
                    case Nf.PlayLikelyToKeepUp:
                        this.update(e, ({
                            sessionControlRecord: e
                        }) => {
                            "RTC_STATE_PLAY" !== e.state && (e.state = "RTC_STATE_CANPLAY", e.lastLikelyToKeepUpTime = Date.now(), e.playLikelyToKeepUpEventCounter += 1)
                        }), this.update(e, e => {
                            e.playLikelyToKeepUpRecord = {}
                        });
                        break;
                    case Nf.PlayRateChanged:
                        this.update(e, ({
                            sessionControlRecord: e,
                            playEndedRecord: t,
                            playStalledRecord: i,
                            mediaEngineStalledRecord: r,
                            playErrorRecord: n,
                            nwErrorRecord: s
                        }) => {
                            0 !== e.rate ? (e.state = "RTC_STATE_PLAY", delete t.LastStall, delete t.LastMediaEngineStall, delete t.LastPause, delete n.LastPause, delete s.LastPause) : (e.state = "RTC_STATE_PAUSE", delete i.LastResume, delete r.LastResume, delete n.LastResume, delete s.LastResume), e.oldRate = e.rate
                        }), this.update(e, e => {
                            e.playRateChangedRecord = {}
                        });
                        break;
                    case Nf.PlayError:
                        this.update(e, ({
                            sessionControlRecord: e
                        }) => {
                            e.state = "RTC_STATE_PLAYERROR"
                        }), this.update(e, e => {
                            e.playErrorRecord = {}
                        });
                        break;
                    case Nf.MediaEngineStalled:
                        this.update(e, ({
                            sessionControlRecord: e
                        }) => {
                            e.state = "RTC_STATE_MEDIAENGINESTALL", e.oldRate = 0
                        }), this.update(e, e => {
                            e.mediaEngineStalledRecord = {}
                        });
                        break;
                    case Nf.SwitchComplete:
                        this.update(e, e => {
                            e.switchCompleteRecord = {}, e.sessionControlRecord.prevLevelUrl = e.sessionControlRecord.curLevelUrl
                        });
                        break;
                    case Nf.VariantEnded:
                        this.update(e, ({
                            sessionControlRecord: e
                        }) => {
                            e.decodedFramesForVariant = 0, e.decodedFramesForVariantSampleCount = 0
                        }), this.update(e, e => {
                            e.variantEndedRecord = {}
                        });
                        break;
                    case Nf.NwError:
                        this.update(e, ({
                            sessionControlRecord: e
                        }) => {
                            e.state = "RTC_STATE_NWERROR"
                        }), this.update(e, e => {
                            e.nwErrorRecord = {}
                        })
                }
                this.update(e, ({
                    sessionControlRecord: e
                }) => {
                    e.eventStartTime = Date.now()
                })
            }
            updatePlaybackInfo(e, s) {
                this.update(e, ({
                    sessionControlRecord: e,
                    periodicRecord: t,
                    playEndedRecord: i
                }) => {
                    s.droppedVideoFrames < e.droppedVideoFrames && (e.droppedVideoFrames = 0), s.decodedFrameCount < e.decodedFrameCount && (e.decodedFrameCount = 0);
                    var r = s.droppedVideoFrames - (e.droppedVideoFrames || 0),
                        n = s.decodedFrameCount - (e.decodedFrameCount || 0);
                    e.droppedVideoFrames = s.droppedVideoFrames, e.decodedFrameCount = s.decodedFrameCount, e.decodedFramesForVariant += n, e.decodedFramesForVariantSampleCount += 1, r && (3 <= r ? (t.GroupViFrDr = (t.GroupViFrDr || 0) + r, t.GroupViFrDrEvtCount = (t.GroupViFrDrEvtCount || 0) + 1, i.GroupViFrDr = (i.GroupViFrDr || 0) + r, i.GroupViFrDrEvtCount = (i.GroupViFrDrEvtCount || 0) + 1) : (t.SparseViFrDr = (t.SparseViFrDr || 0) + r, t.SparseViFrDrEvtCount = (t.SparseViFrDrEvtCount || 0) + 1, i.SparseViFrDr = (i.SparseViFrDr || 0) + r, i.SparseViFrDrEvtCount = (i.SparseViFrDrEvtCount || 0) + 1))
                })
            }
            updateBufferAppended(e, t) {
                this.update(e, ({
                    sessionControlRecord: e
                }) => {
                    e.bufferAppendInfo || (e.bufferAppendInfo = []), e.bufferAppendInfo.push(t)
                })
            }
            updateSeeked(e, t) {
                this.update(e, ({
                    sessionControlRecord: e
                }) => {
                    e.seekInfo || (e.seekInfo = []), e.seekInfo.push(t)
                })
            }
            updateManifestParsed(e, r) {
                this.update(e, ({
                    sessionControlRecord: e,
                    periodicRecord: t,
                    playEndedRecord: i
                }) => {
                    t.MasterPlaylistADT = (t.MasterPlaylistADT || 0) + r.adt, i.MasterPlaylistADT = (i.MasterPlaylistADT || 0) + r.adt;
                    t = this._computeVariantInfo(r.levels);
                    i.IsAudioOnly = r.isAudioOnly, i.IsGapless = r.isGapless, i.IsFirstItem = r.isFirstItem, i.ItemID = r.itemID, i.MaxVideoQltyIndex = t.maxVideoQltyIndex, i.MaxReWd = t.maxWidth, i.MaxReHt = t.maxHeight, e.manifestData = {
                        variantList: t.variantList,
                        varListString: t.varListString
                    }
                })
            }
            updateFragLoaded(e, r) {
                this.update(e, ({
                    sessionControlRecord: e,
                    periodicRecord: t,
                    playEndedRecord: i
                }) => {
                    if (t.MediaRequestsSent = (t.MediaRequestsSent || 0) + 1, i.MediaRequestsSent = (i.MediaRequestsSent || 0) + 1, r.cdnServer) {
                        const e = r.cdnServer.toLowerCase();
                        "aapl" !== e && "akam" !== e && "llnw" !== e || (i.LastMediaCDNServer = e)
                    }
                    r.serverInfo && (i.ServerInfo = r.serverInfo), e.segmentMimeTypes || (e.segmentMimeTypes = []), void 0 === e.segmentMimeTypes.find(e => e == r.contentType) && e.segmentMimeTypes.push(r.contentType), r.fragType === gu.Variant ? (e.variantVideoBytes = (e.variantVideoBytes || 0) + r.bytes, e.variantVideoDuration = (e.variantVideoDuration || 0) + r.duration, e.intervalVideoBytes = (e.intervalVideoBytes || 0) + r.bytes, e.intervalVideoDuration = (e.intervalVideoDuration || 0) + r.duration, e.sessionVideoBytes = (e.sessionVideoBytes || 0) + r.bytes, e.sessionVideoDuration = (e.sessionVideoDuration || 0) + r.duration, e.obrLast = 8 * r.bytes / (r.duration / 1e3), t.NetBytes = (t.NetBytes || 0) + r.bytes, t.ADT = (t.ADT || 0) + r.adt, t.SegmentProcessTime = (t.SegmentProcessTime || 0) + r.processTime, i.ADT = (i.ADT || 0) + r.adt, i.NetBytes = (i.NetBytes || 0) + r.bytes, i.SegmentProcessTime = (i.SegmentProcessTime || 0) + r.processTime) : r.fragType === gu.AltAudio && (e.variantAudioBytes = (e.variantAudioBytes || 0) + r.bytes, e.variantAudioDuration = (e.variantAudioDuration || 0) + r.duration, e.intervalAudioBytes = (e.intervalAudioBytes || 0) + r.bytes, e.intervalAudioDuration = (e.intervalAudioDuration || 0) + r.duration, e.sessionAudioBytes = (e.sessionAudioBytes || 0) + r.bytes, e.sessionAudioDuration = (e.sessionAudioDuration || 0) + r.duration)
                })
            }
            updateFragBuffered(e, i) {
                this.update(e, ({
                    periodicRecord: e,
                    playEndedRecord: t
                }) => {
                    i.fragType === gu.Variant && (e.SegmentParseTime = (e.SegmentParseTime || 0) + i.parseTime, t.SegmentParseTime = (t.SegmentParseTime || 0) + i.parseTime)
                })
            }
            updateLevelLoaded(e, n) {
                this.update(e, ({
                    sessionControlRecord: e,
                    playLikelyToKeepUpRecord: t,
                    periodicRecord: i,
                    playEndedRecord: r
                }) => {
                    t.PlaylistADT = (t.PlaylistADT || 0) + n.adt, i.PlaylistADT = (i.PlaylistADT || 0) + n.adt, r.PlaylistADT = (r.PlaylistADT || 0) + n.adt, i.MaxPlaylistDT = n.adt > i.MaxPlaylistDT ? n.adt : i.MaxPlaylistDT, r.MaxPlaylistDT = n.adt > r.MaxPlaylistDT ? n.adt : r.MaxPlaylistDT, r.PlayType = n.playType, this._setTargetDuration(n.url, n.targetduration, e), e.playlistMimeTypes || (e.playlistMimeTypes = []), void 0 === e.playlistMimeTypes.find(e => e == n.contentType) && e.playlistMimeTypes.push(n.contentType);
                    i = n.url, r = this._getVariantInfo(i, e);
                    e.intervalVariantList[i] || (e.intervalVariantList[i] = Object.assign({}, r)), e.sessionVariantList[i] || (e.sessionVariantList[i] = Object.assign({}, r))
                })
            }
            updateLevelsChanged(e, r) {
                this.update(e, ({
                    sessionControlRecord: t,
                    playEndedRecord: e
                }) => {
                    const i = this._computeVariantInfo(r.levels);
                    e.MaxVideoQltyIndex = i.maxVideoQltyIndex, e.MaxReWd = i.maxWidth, e.MaxReHt = i.maxHeight, t.manifestData = {
                        variantList: i.variantList,
                        varListString: i.varListString
                    }, Object.keys(i.variantList).forEach(e => {
                        t.intervalVariantList[e] && (t.intervalVariantList[e].brRnk = i.variantList[e].brRnk), t.sessionVariantList[e] && (t.sessionVariantList[e].brRnk = i.variantList[e].brRnk)
                    })
                })
            }
            updateLicenseChallengeRequested(e, r) {
                this.update(e, ({
                    sessionControlRecord: e
                }) => {
                    const t = {},
                        i = r.timestamp;
                    t.licenseChallengeStartTime = i, "RTC_STATE_INIT" === e.state && (t.keyInitTime = i - e.sessionStartTime), e.activeKeySessions[r.keyuri] = t
                })
            }
            updateLicenseChallengeReceived(e, i) {
                this.update(e, ({
                    sessionControlRecord: e
                }) => {
                    const t = e.activeKeySessions[i.keyuri];
                    t.licenseChallengeRequestTime = i.timestamp - t.licenseChallengeStartTime
                })
            }
            updateLicenseChallengeSubmitted(e, i) {
                this.update(e, ({
                    sessionControlRecord: e
                }) => {
                    const t = e.activeKeySessions[i.keyuri];
                    t.keyFormat = i.keyFormat, t.licenseChallengeSubmitTime = i.timestamp
                })
            }
            updateLicenseChallengeCreated(e, i) {
                this.update(e, ({
                    sessionControlRecord: e
                }) => {
                    const t = e.activeKeySessions[i.keyuri];
                    t.cdmVersion = i.cdmVersion, t.licenseChallengeCreationTime = i.timestamp - t.licenseChallengeSubmitTime
                })
            }
            updateLicenseResponseRequested(e, t) {
                this.update(e, ({
                    sessionControlRecord: e
                }) => {
                    e.activeKeySessions[t.keyuri].licenseResponseRequestTime = t.timestamp
                })
            }
            updateLicenseResponseReceived(e, i) {
                this.update(e, ({
                    sessionControlRecord: e
                }) => {
                    const t = e.activeKeySessions[i.keyuri];
                    t.licenseResponseReceiveTime = i.timestamp - t.licenseResponseRequestTime
                })
            }
            updateLicenseResponseSubmitted(e, t) {
                this.update(e, ({
                    sessionControlRecord: e
                }) => {
                    e.activeKeySessions[t.keyuri].licenseResponseSubmitTime = t.timestamp
                })
            }
            _prepareEventPlayEnded(e) {
                this.update(e, ({
                    sessionControlRecord: e,
                    playEndedRecord: t
                }) => {
                    t.AvgVideoBitrate = 8 * (e.sessionVideoBytes || 0) / (e.sessionVideoDuration || 1), t.AvgAudioBitrate = 8 * (e.sessionAudioBytes || 0) / (e.sessionAudioDuration || 1);
                    var i = 1e3 * Math.round((t.NetBytes || 0) / 1e3);
                    t.NetBytes = i;
                    var r = t.ADT || 1,
                        n = t.ADT + t.SegmentProcessTime || 1,
                        s = t.ADT + t.SegmentProcessTime + t.SegmentParseTime || 1;
                    t.TWOBR = 8 * i / (r / 1e3), t.PerceivedTWOBR = 8 * i / (n / 1e3), t.NetTWOBR = 8 * i / (s / 1e3);
                    var s = this._findTimeWeightedValues("RTC_STATE_PLAY" === e.state ? Date.now() - e.eventStartTime : 0, e.sessionVariantList, e.curLevelUrl);
                    t.PlayerTWIBR = s.twIBR, t.PlayerTWIABR = s.twIABR, t.TWBitRk = s.twBRnk;
                    s = this._getVariantInfo(e.curLevelUrl, e);
                    t.TargetDur = s.targetduration, t.ReWd = s.width, t.ReHt = s.height, t.VariantList = null === (s = e.manifestData) || void 0 === s ? void 0 : s.varListString;
                    let a = "";
                    e.playlistMimeTypes && (e.playlistMimeTypes.forEach(e => {
                        a += e + ","
                    }), a = a.slice(0, -1));
                    let o = "";
                    e.segmentMimeTypes && (e.segmentMimeTypes.forEach(e => {
                        o += e + ","
                    }), o = o.slice(0, -1)), t.PlaylistMimeType = a, t.SegmentMimeType = o, t.Rate = e.rate
                }), this._aggregateTimes(e)
            }
            _prepareEventPeriodic(e, o) {
                this.update(e, ({
                    sessionControlRecord: e,
                    periodicRecord: t,
                    playEndedRecord: i
                }) => {
                    t.EventCounter = e.periodicEventCounter, t.PInterval = Date.now() - e.lastPeriodicTime, t.AvgVideoBitrate = 8 * (e.intervalVideoBytes || 0) / (e.intervalVideoDuration || 1), t.AvgAudioBitrate = 8 * (e.intervalAudioBytes || 0) / (e.intervalAudioDuration || 1);
                    let r = t.NetBytes || 0;
                    o.isFinal && (t.NetBytes = r = 1e3 * Math.round(r / 1e3));
                    var n = t.ADT || 1,
                        s = t.ADT + t.SegmentProcessTime || 1,
                        a = t.ADT + t.SegmentProcessTime + t.SegmentParseTime || 1;
                    t.TWOBR = 8 * r / (n / 1e3), t.PerceivedTWOBR = 8 * r / (s / 1e3), t.NetTWOBR = 8 * r / (a / 1e3);
                    var a = this._findTimeWeightedValues("RTC_STATE_PLAY" === e.state ? Date.now() - e.eventStartTime : 0, e.intervalVariantList, e.curLevelUrl);
                    t.PlayerTWIBR = a.twIBR, t.PlayerTWIABR = a.twIABR, t.TWBitRk = a.twBRnk;
                    a = this._getVariantInfo(e.curLevelUrl, e);
                    t.TargetDur = a.targetduration, t.ReWd = a.width, t.ReHt = a.height, t.VariantList = null === (a = e.manifestData) || void 0 === a ? void 0 : a.varListString, t.Rate = e.rate;
                    e = this._computeMediaStats(e);
                    e && (t.MedianBufferAppendLatency = e.bufLatencyInfo.median, t.MaxBufferAppendLatency = e.bufLatencyInfo.max, t.MedianBufferAppendSize = e.bufSizeInfo.median, t.MaxBufferAppendSize = e.bufSizeInfo.max, t.MedianSeekLatency = e.seekLatencyInfo.median, t.MaxSeekLatency = e.seekLatencyInfo.max, t.MedianPlayLatency = e.playLatencyInfo.median, t.MaxPlayLatency = e.playLatencyInfo.max), this._copyCommonKeys(t, i)
                }), this._aggregateTimes(e)
            }
            _prepareEventPlayStalled(e, s) {
                this.update(e, ({
                    sessionControlRecord: e,
                    playStalledRecord: t,
                    playEndedRecord: i
                }) => {
                    var r = this._getVariantInfo(e.curLevelUrl, e),
                        n = Date.now();
                    t.MediaDur = s.mediaDur, t.BitRnk = r.brRnk, t.Codecs = r.codecs, t.LastLikelyToKeepUp = n - e.lastLikelyToKeepUpTime, t.LastSwitch = n - e.lastSwitchTime, t.StallDetectionTime = s.stallDurationMs, t.StallType = s.type, t.BufferLength = s.bufferLen, "networkError" === i.ErrDomain && (t.NwErrTime = i.NwErrTime, t.NwErrCode = i.ErrCode), t.LaSwDir = e.lastSwitchDir, t.TargetDur = r.targetduration, t.PlayerIABR = r.avgBandwidth, t.PlayerIBR = r.bandwidth, t.Rate = e.rate, t.OBRLast = e.obrLast, t.OBRMean = 8 * i.NetBytes / (i.ADT / 1e3), this._copyCommonKeys(t, i)
                }), this._aggregateTimes(e)
            }
            _prepareEventKeySessionComplete(e, r) {
                this.update(e, ({
                    sessionControlRecord: e,
                    keySessionCompleteRecord: t,
                    playEndedRecord: i
                }) => {
                    e = e.activeKeySessions[r.keyuri];
                    e ? (t.KeyFormat = e.keyFormat, t.CDMVersion = e.cdmVersion, t.LicenseChallengeRequestTime = e.licenseChallengeRequestTime, t.LicenseChallengeCreationTime = e.licenseChallengeCreationTime, t.LicenseResponseReceiveTime = e.licenseResponseReceiveTime, t.LicenseResponseProcessTime = e.licenseResponseProcessTime, t.KeyDeliveryTime = e.keyDeliveryTime, t.CurrentMediaTime = 1e3 * e.currentMediaTime, t.KeyInitTime = e.keyInitTime, t.KeyErrorType = e.keyErrorType, this._copyCommonKeys(t, i)) : this.logger.warn(`_prepareEventKeySessionComplete no keySessionInfo for ${le(r.keyuri)}`)
                }), this._aggregateTimes(e)
            }
            _prepareEventPlayLikelyToKeepUp(e, n) {
                this.update(e, ({
                    sessionControlRecord: e,
                    playLikelyToKeepUpRecord: t,
                    playEndedRecord: i
                }) => {
                    var r = this._getVariantInfo(e.curLevelUrl, e);
                    t.EventCounter = e.playLikelyToKeepUpEventCounter, t.PlayerIABR = r.avgBandwidth, t.PlayerIBR = r.bandwidth, t.MediaDur = n.mediaDur, t.BitRnk = r.brRnk, t.Codecs = r.codecs, t.TargetDur = r.targetduration, this._copyCommonKeys(t, i)
                }), this._aggregateTimes(e)
            }
            _prepareEventPlayRateChanged(e, n) {
                this.update(e, ({
                    sessionControlRecord: e,
                    playRateChangedRecord: t,
                    playEndedRecord: i
                }) => {
                    var r = this._getVariantInfo(e.curLevelUrl, e);
                    t.Rate = e.rate, t.StNPT = n.currentTime, t.PlayerIABR = r.avgBandwidth, t.PlayerIBR = r.bandwidth, t.BitRnk = r.brRnk, t.MediaDur = n.mediaDur, t.Codecs = r.codecs, this._copyCommonKeys(t, i)
                }), this._aggregateTimes(e)
            }
            _prepareEventPlayError(e, s) {
                this.update(e, ({
                    sessionControlRecord: e,
                    playErrorRecord: t,
                    playEndedRecord: i
                }) => {
                    var r = this._getVariantInfo(e.curLevelUrl, e),
                        n = Date.now();
                    "mediaElementError" == s.domain ? (t.ErrDomain = t.ErrCode = "mediaElementError", t.ErrIsFatal = !0, t.ErrCodeMediaElement = s.mediaElemCode, t.ErrReason = s.mediaElemReason, t.ErrDetail = s.mediaElemDetail) : (t.ErrCode = s.details, t.ErrReason = s.code, t.ErrIsFatal = s.fatal, t.ErrDomain = "mediaError"), t.PlayerErrCount = s.count || 1, t.BitRnk = r.brRnk, t.MediaDur = s.mediaDur, t.PlayTime = i.PlayTime, t.PlayTimeWC = i.PlayTimeWC, t.PlayerIABR = r.avgBandwidth, t.PlayerIBR = r.bandwidth, t.LastLikelyToKeepUp = n - e.lastLikelyToKeepUpTime, t.LastSwitch = n - e.lastSwitchTime, t.VideoQltyIndex = r.qltyIndex, t.Rate = e.rate, t.KeyErrorType = e.lastKeyErrorType, t.KeyDeliveryTime = e.lastKeyDeliveryTime, this._copyCommonKeys(t, i)
                }), this._aggregateTimes(e)
            }
            _prepareEventMediaEngineStalled(e, s) {
                this.update(e, ({
                    sessionControlRecord: e,
                    mediaEngineStalledRecord: t,
                    playEndedRecord: i
                }) => {
                    var r = Date.now(),
                        n = this._getVariantInfo(e.curLevelUrl, e);
                    t.MediaDur = s.mediaDur, t.BitRnk = n.brRnk, t.Codecs = n.codecs, t.LastLikelyToKeepUp = r - e.lastLikelyToKeepUpTime, t.LastSwitch = r - e.lastSwitchTime, t.StallDetectionTime = s.stallDurationMs, t.StallType = s.type, t.BufferLength = s.bufferLen, t.LaSwDir = e.lastSwitchDir, t.TargetDur = n.targetduration, t.PlayerIABR = n.avgBandwidth, t.PlayerIBR = n.bandwidth, t.Rate = e.rate, t.OBRLast = e.obrLast, t.OBRMean = 8 * i.NetBytes / (i.ADT / 1e3), this._copyCommonKeys(t, i)
                }), this._aggregateTimes(e)
            }
            _prepareEventSwitchComplete(e, s) {
                this.update(e, ({
                    sessionControlRecord: e,
                    switchCompleteRecord: t,
                    playEndedRecord: i
                }) => {
                    var r = this._getVariantInfo(e.prevLevelUrl, e),
                        n = this._getVariantInfo(e.curLevelUrl, e);
                    t.FrBitRnk = r.brRnk, t.ToBitRnk = n.brRnk, t.TimeToBitrate = Date.now() - e.sessionStartTime, t.MediaDur = s.mediaDur, t.Rate = e.rate, t.PlayerIBR = n.bandwidth, t.PlayerIABR = n.avgBandwidth, t.LastPlayerIBR = r.bandwidth, t.LastPlayerIABR = r.avgBandwidth, t.ReWd = n.width, t.ReHt = n.height, this._copyCommonKeys(t, i)
                }), this._aggregateTimes(e)
            }
            _prepareEventVariantEnded(e, n) {
                this.update(e, ({
                    sessionControlRecord: e,
                    variantEndedRecord: t,
                    playEndedRecord: i
                }) => {
                    var r = this._getVariantInfo(e.curLevelUrl, e);
                    t.Rate = e.rate, t.VarAvgBitrate = r.avgBandwidth, t.VarPeakBitrate = r.bandwidth, t.VarBitRk = r.brRnk, t.VarSTTime = e.variantStartTimeMedia, t.VarEndTime = 1e3 * n.currentTime, t.IFR = r.framerate, t.ODR = e.decodedFramesForVariant / e.decodedFramesForVariantSampleCount, t.ReWd = r.width, t.ReHt = r.height, t.Codecs = r.codecs, t.AvgVideoBitrate = 8 * (e.variantVideoBytes || 0) / (e.variantVideoDuration || 1), t.AvgAudioBitrate = 8 * (e.variantAudioBytes || 0) / (e.variantAudioDuration || 1), this._copyCommonKeys(t, i)
                }), this._aggregateTimes(e)
            }
            _prepareEventNwError(e, n) {
                this.update(e, ({
                    sessionControlRecord: e,
                    nwErrorRecord: t,
                    playEndedRecord: i
                }) => {
                    var r = this._getVariantInfo(e.curLevelUrl, e);
                    t.ErrCode = n.details, t.ErrReason = n.code, t.ErrIsFatal = n.fatal, t.NwErrCount = n.count || 1, t.ErrDomain = "networkError", t.PlayTime = i.PlayTime, t.PlayTimeWC = i.PlayTimeWC, t.BitRnk = r.brRnk, t.Rate = e.rate, t.KeyErrorType = e.lastKeyErrorType, t.KeyDeliveryTime = e.lastKeyDeliveryTime, this._copyCommonKeys(t, i)
                }), this._aggregateTimes(e)
            }
            _copyCommonKeys(e, t) {
                e.PlayType = t.PlayType, e.LastMediaCDNServer = t.LastMediaCDNServer, e.MaxVideoQltyIndex = t.MaxVideoQltyIndex, e.MaxReWd = t.MaxReWd, e.MaxReHt = t.MaxReHt, e.IsGapless = t.IsGapless, e.IsAudioOnly = t.IsAudioOnly, e.IsFirstItem = t.IsFirstItem, e.ItemID = t.ItemID, e.ServerInfo = t.ServerInfo
            }
            _computeVariantInfo(e) {
                const i = {};
                let r = 0,
                    n = 0,
                    s = 0,
                    a = 0;
                const o = this._getMaxNormalizedPeak(e);
                e.forEach(e => {
                    if (e.attrs) {
                        const r = this._getVideoFourCC(e.attrs.CODECS),
                            n = this._getVideoQualityIndex(r, e.attrs["VIDEO-RANGE"]) || 0,
                            s = {
                                codecs: e.attrs.CODECS,
                                width: e.width,
                                height: e.height,
                                bandwidth: e.attrs.BANDWIDTH,
                                avgBandwidth: e.attrs["AVERAGE-BANDWIDTH"],
                                framerate: e.attrs["FRAME-RATE"],
                                iframes: e.iframes,
                                brRnk: this._getBitrateRank(e.attrs.BANDWIDTH, r, o),
                                qltyIndex: n,
                                targetduration: 0,
                                playTime: 0
                            };
                        a = n > a ? n : a, i[e.url] = s
                    }
                    var t = e.width * e.height;
                    t > s && (s = t, r = e.width, n = e.height)
                });
                e = 0 < Object.keys(i).length ? Object.values(i).map(e => e.bandwidth + ":" + e.avgBandwidth).join(",") : void 0;
                return {
                    variantList: i,
                    varListString: e,
                    maxVideoQltyIndex: a,
                    maxWidth: r,
                    maxHeight: n
                }
            }
            _getMaxNormalizedPeak(e) {
                let n = 0;
                return e.forEach(e => {
                    e = e.attrs;
                    if (e) {
                        const t = e.BANDWIDTH || 0,
                            i = this._getNormalizedPeak(t, this._getVideoFourCC(e.CODECS)),
                            r = Math.max(t, i);
                        n = r > n ? r : n
                    }
                }), n
            }
            _getNormalizedPeak(e, t) {
                return "object" == typeof Ff[t] ? 1.5 * e : +e
            }
            _getVideoFourCC(e) {
                return e && e.split(",").map(e => e.split(".")[0].trim()).find(e => !!Ff[e])
            }
            _getVideoQualityIndex(e, t) {
                return "object" == typeof Ff[e] ? Ff[e][t] : Ff[e]
            }
            _getBitrateRank(e, t, i) {
                t = Math.max(1, this._getNormalizedPeak(e, t));
                return Math.ceil(100 * t / i)
            }
            _findTimeWeightedValues(o, l, d) {
                const e = {
                    twBRnk: 0,
                    twIBR: 0,
                    twIABR: 0
                };
                if (l) {
                    let i = 0,
                        r = 0,
                        n = 0,
                        s = 0,
                        a = 0;
                    Object.values(l).forEach(e => {
                        let t = e.playTime;
                        e === l[d] && (t += o || 0), t && (r += e.bandwidth * t, i += e.brRnk * t, n += t, e.avgBandwidth && (s += e.avgBandwidth * t, a += t))
                    }), n && (e.twBRnk = i / n, e.twIBR = r / n), s && a && (e.twIABR = s / a)
                }
                return e
            }
            _computeMediaStats(e) {
                const t = e.bufferAppendInfo;
                let i = [];
                const r = [];
                t && t.forEach && t.forEach(e => {
                    i.push(e.latency), r.push(e.size)
                });
                var n = this._computeStats(i),
                    s = this._computeStats(r),
                    a = e.seekInfo;
                i = [], a && a.forEach && e.seekInfo.forEach(e => i.push(e.latency));
                var o = this._computeStats(i),
                    a = e.playInfo;
                return i = [], a && a.forEach && e.playInfo.forEach(e => i.push(e.latency)), {
                    bufLatencyInfo: n,
                    bufSizeInfo: s,
                    seekLatencyInfo: o,
                    playLatencyInfo: this._computeStats(i)
                }
            }
            _computeStats(e) {
                let t, i;
                if (e) {
                    const r = e.filter(e => 0 < e);
                    if (0 < r.length) {
                        t = r.reduce((e, t) => Math.max(e, t));
                        const e = r.length,
                            n = r.sort((e, t) => e - t),
                            s = Math.ceil(e / 2);
                        i = e % 2 == 0 ? (n[s] + n[s - 1]) / 2 : n[s - 1]
                    }
                }
                return {
                    max: t,
                    median: i
                }
            }
            _getVariantInfo(e, t) {
                return e && t.manifestData && t.manifestData.variantList && t.manifestData.variantList[e] ? t.manifestData.variantList[e] : {}
            }
            _setTargetDuration(e, t, i) {
                e && i.manifestData && i.manifestData.variantList && i.manifestData.variantList[e] && (i.manifestData.variantList[e].targetduration = t)
            }
            _isBadSw(e, t, i, r, n, s, a) {
                let o = n - s < 1e4 && t !== e && r === i && !a ? !0 : !1;
                return o
            }
            _aggregateTimes(e) {
                this.update(e, ({
                    sessionControlRecord: t,
                    playLikelyToKeepUpRecord: i,
                    playStalledRecord: r,
                    mediaEngineStalledRecord: n,
                    switchCompleteRecord: s,
                    playRateChangedRecord: a,
                    variantEndedRecord: o,
                    playErrorRecord: l,
                    nwErrorRecord: d,
                    periodicRecord: u,
                    playEndedRecord: c
                }) => {
                    var h = Date.now() - t.eventStartTime;
                    switch (t.state) {
                        case "RTC_STATE_INIT":
                            i.StartupTime = (i.StartupTime || 0) + h, u.InitTime = (u.InitTime || 0) + h, c.InitTime = (c.InitTime || 0) + h;
                            break;
                        case "RTC_STATE_CANPLAY":
                            a.StartupTime = (a.StartupTime || 0) + h, u.InitTime = (u.InitTime || 0) + h, c.InitTime = (c.InitTime || 0) + h;
                            break;
                        case "RTC_STATE_PAUSE":
                            u.PauseTime = (u.PauseTime || 0) + h, c.PauseTime = (c.PauseTime || 0) + h, a.LastPause = (a.LastPause || 0) + h, c.LastPause = (c.LastPause || 0) + h, l.LastPause = (l.LastPause || 0) + h, d.LastPause = (d.LastPause || 0) + h;
                            break;
                        case "RTC_STATE_STALL":
                            o.StallTime = (o.StallTime || 0) + h, u.StallTime = (u.StallTime || 0) + h, c.StallTime = (c.StallTime || 0) + h, a.LastStall = (a.LastStall || 0) + h, l.LastStall = (l.LastStall || 0) + h, c.LastStall = (c.LastStall || 0) + h;
                            break;
                        case "RTC_STATE_MEDIAENGINESTALL":
                            o.MediaEngineStallTime = (o.MediaEngineStallTime || 0) + h, u.MediaEngineStallTime = (u.MediaEngineStallTime || 0) + h, c.MediaEngineStallTime = (c.MediaEngineStallTime || 0) + h, a.LastMediaEngineStall = (a.LastMediaEngineStall || 0) + h, l.LastMediaEngineStall = (l.LastMediaEngineStall || 0) + h, c.LastMediaEngineStall = (c.LastMediaEngineStall || 0) + h;
                            break;
                        case "RTC_STATE_NWERROR":
                            c.NwErrTime = (c.NwErrTime || 0) + h, u.NwErrTime = (u.NwErrTime || 0) + h;
                            break;
                        case "RTC_STATE_PLAYERROR":
                            u.PlayErrTime = (u.PlayErrTime || 0) + h, c.PlayErrTime = (c.PlayErrTime || 0) + h;
                            break;
                        case "RTC_STATE_PLAY": {
                            a.RateChangePlayTime = (a.RateChangePlayTime || 0) + h, s.PlayTime = (s.PlayTime || 0) + h, s.PlayTimeLastSW = (s.PlayTimeLastSW || 0) + h * (t.oldRate / 100), r.LastResume = (r.LastResume || 0) + h, n.LastResume = (n.LastResume || 0) + h, l.LastResume = (l.LastResume || 0) + h, d.LastResume = (d.LastResume || 0) + h, o.VarPlayTimeWC = (o.VarPlayTimeWC || 0) + h, o.VarPlayTime = (o.VarPlayTime || 0) + h * (t.oldRate / 100), u.PlayTimeWC = (u.PlayTimeWC || 0) + h, u.PlayTime = (u.PlayTime || 0) + h * (t.oldRate / 100), c.PlayTimeWC = (c.PlayTimeWC || 0) + h, c.PlayTime = (c.PlayTime || 0) + h * (t.oldRate / 100), n.PlayTime = c.PlayTime, r.PlayTime = c.PlayTime;
                            const i = t.curLevelUrl;
                            let e = t.intervalVariantList[i];
                            e.playTime = (e.playTime || 0) + h, e = t.sessionVariantList[i], e.playTime = (e.playTime || 0) + h;
                            break
                        }
                    }
                })
            }
        }
        const Vf = {
            name: "rtc-service"
        };
        class Kf {
            constructor(e, t, i, r) {
                this.hls = e, this.config = t, this.accessLog = i, this.logger = r, this.destroy$ = new Xt, this.isSeeking = !1, this.seekStart = null, this.periodicInterval = t.rtcIntervalTimeout || 3e5, this.intervalFunc = null, this.rtcStore = new $f(this.logger), this.rtcQuery = new Uf(this.rtcStore, this.logger), this.rtcComponent = new Bf(this.rtcQuery, this.logger), i.setRTCQuery(this.rtcQuery), this.subscribeAndUpdateStore(), this.registerForEvents()
            }
            destroy() {
                this.destroy$.next(), this.clearPeriodic(), this.rtcStore.reset()
            }
            detachMedia() {
                this.clearPeriodic();
                var e;
                try {
                    e = this.hls.realCurrentTime, this.rtcStore.updateVariantEnd(this.rtcEventItemId(!0), {
                        currentTime: e
                    }), this.sendAndFinalize(this.rtcEventItemId(!0), Nf.VariantEnded), this.rtcStore.updatePeriodic(this.rtcEventItemId(!0), !0), this.sendAndFinalize(this.rtcEventItemId(!0), Nf.Periodic), this.rtcStore.updateEnded(this.rtcEventItemId(!0)), this.sendAndFinalize(this.rtcEventItemId(!0), Nf.PlayEnded)
                } catch (e) {
                    this.logger.warn(Vf, e)
                }
            }
            handleError(e) {
                var t = e instanceof p ? e : new V(!0, e.message, $.InternalError);
                t instanceof uc && !t.fatal ? (this.rtcStore.updateLevelLoadError(this.rtcEventItemId(), {
                    url: t.url,
                    mediaDur: this.hls.bufferedDuration,
                    isSeeking: this.isSeeking
                }), this.sendAndFinalize(this.rtcEventItemId(), Nf.SwitchComplete)) : t.type === o ? (this.rtcStore.updateNwError(this.rtcEventItemId(), {
                    fatal: t.fatal,
                    details: t.details,
                    code: null === (e = t.response) || void 0 === e ? void 0 : e.code
                }), this.sendAndFinalize(this.rtcEventItemId(), Nf.NwError)) : (this.rtcStore.updateMediaError(this.rtcEventItemId(), {
                    fatal: t.fatal,
                    details: t.details,
                    code: null === (t = t.response) || void 0 === t ? void 0 : t.code
                }), this.sendAndFinalize(this.rtcEventItemId(), Nf.PlayError))
            }
            handleMediaElementError(e) {
                this.rtcStore.updateMediaElementError(this.rtcEventItemId(), e), this.sendAndFinalize(this.rtcEventItemId(), Nf.PlayError)
            }
            handleFragLoaded(e, t) {
                var i, r, n;
                this.checkMediaOptionType(e.mediaOptionType) && (e.itemId !== this.rtcEventItemId() && this.logger.warn(Vf, `Frag id does not match current item id. Frag Id=${e.itemId}, playing id=${this.rtcEventItemId(!0)}, loading id=${null===(n=this.hls.loadingItem)||void 0===n?void 0:n.itemId}`), i = t.tload - t.trequest, r = t.tload - t.tfirst, n = this.serverInfoInstance || {}, this.rtcStore.updateFragLoaded(e.itemId, {
                    fragType: e.mediaOptionType,
                    bytes: t.loaded,
                    duration: e.duration,
                    adt: i,
                    processTime: r,
                    contentType: t.contentType,
                    cdnServer: t.cdnServer,
                    serverInfo: n
                }), this.accessLog.updateFragLoaded(e.itemId, this.isSeeking, {
                    fragType: e.mediaOptionType,
                    bytes: t.loaded,
                    duration: e.duration,
                    adt: i,
                    processTime: r,
                    startPTS: e.start,
                    endPTS: e.start + e.duration
                }))
            }
            handleFragBuffered(e) {
                var t;
                this.checkMediaOptionType(e.fragmentType) && (t = e.endDataAppend - e.startDataAppend, this.rtcStore.updateFragBuffered(this.rtcEventItemId(), {
                    fragType: e.fragmentType,
                    bytes: e.dataBytesAppend,
                    parseTime: t
                }))
            }
            handleLevelLoaded(e, t) {
                var i;
                e ? (e.itemId !== this.rtcEventItemId() && this.logger.warn(Vf, `media option id does not match current item id. media Id=${e.itemId}, current id=${this.rtcEventItemId}`), e.mediaOptionType === gu.Variant && (i = t.tload - t.trequest, this.rtcStore.updateLevelLoaded(this.rtcEventItemId(), {
                    url: e.url,
                    targetduration: e.targetduration,
                    adt: i,
                    contentType: t.contentType,
                    playType: e.type
                }))) : this.logger.warn(`handleLevelLoaded called with mediaOptionDetails as ${e}`)
            }
            handleLevelSwitched(e) {
                var t = {
                    url: e.url,
                    isSeeking: this.isSeeking,
                    mediaDur: this.hls.bufferedDuration,
                    currentTime: this.hls.realCurrentTime
                };
                e.oldVariant && (this.rtcStore.updateVariantEnd(this.rtcEventItemId(), {
                    currentTime: this.hls.realCurrentTime
                }), this.sendAndFinalize(this.rtcEventItemId(), Nf.VariantEnded)), this.rtcStore.updateLevelSwitched(this.rtcEventItemId(), t), this.sendAndFinalize(this.rtcEventItemId(), Nf.SwitchComplete)
            }
            handleLevelSwitching(e) {
                this.levelSwitchingUrl = e
            }
            handleLevelsChanged(e) {
                this.rtcStore.updateLevelsChanged(this.rtcEventItemId(), {
                    levels: e
                })
            }
            handleManifestParsed(e) {
                var t = e.stats.tload - e.stats.trequest;
                this.rtcStore.updateManifestParsed(this.rtcEventItemId(), {
                    levels: e.levels,
                    adt: t,
                    contentType: e.stats.contentType,
                    isAudioOnly: this.hls.inGaplessMode,
                    isGapless: this.hls.inGaplessMode,
                    isFirstItem: this.hls.isFirstItem,
                    itemID: ((null === (e = this.hls.reportingAgent) || void 0 === e ? void 0 : e.SessionID) || Zl()) + "-" + this.rtcEventItemId()
                })
            }
            handleSeek(e) {
                if ("SEEKING" === e) this.isSeeking = !0, this.seekStart = Date.now();
                else if ("SEEKED" === e) {
                    this.isSeeking = !1;
                    let e = 0;
                    this.seekStart && (e = Date.now() - this.seekStart), this.seekStart = null, this.rtcStore.updateSeeked(this.rtcEventItemId(!0), {
                        latency: e
                    })
                }
            }
            handleDesiredRateChanged(e, t) {
                0 === t || 1 < Math.abs(e) && 1 < Math.abs(t) ? (this.rtcStore.updateRateChanged(this.rtcEventItemId(!0), {
                    rate: t,
                    latency: 0,
                    mediaDur: this.hls.bufferedDuration,
                    currentTime: this.hls.realCurrentTime,
                    url: this.levelSwitchingUrl
                }), this.sendAndFinalize(this.rtcEventItemId(!0), Nf.PlayRateChanged)) : 1 !== e && 1 === t && (this.playStart = Date.now()), this.oldRate = e, this.newRate = t
            }
            handleVariantBufferAppended(e, t) {
                let i = 0;
                e && (i = Date.now() - e), this.rtcStore.updateBufferAppended(this.rtcEventItemId(), {
                    latency: i,
                    size: t
                })
            }
            handleStalled(e, t) {
                var i = {
                        type: e.type,
                        stallDurationMs: e.stallDurationMs,
                        bufferLen: t,
                        mediaDur: this.hls.bufferedDuration
                    },
                    t = this.rtcQuery.getEntity(this.rtcEventItemId(!0)).sessionControlRecord.state;
                e.type === Cp.LowBuffer || e.type === Cp.Seek && e.isLowBufferStall ? "RTC_STATE_PLAY" === t && (this.rtcStore.updateBufferStalled(this.rtcEventItemId(!0), i), this.sendAndFinalize(this.rtcEventItemId(!0), Nf.PlayStalled)) : "RTC_STATE_PLAY" === t && (this.rtcStore.updateMediaEngineStalled(this.rtcEventItemId(!0), i), this.sendAndFinalize(this.rtcEventItemId(!0), Nf.MediaEngineStalled))
            }
            handlePlaybackInfo(e, t) {
                this.rtcStore.updatePlaybackInfo(this.rtcEventItemId(!0), {
                    droppedVideoFrames: e,
                    decodedFrameCount: t
                }), this.accessLog.updatePlaybackInfo(this.rtcEventItemId(!0), {
                    droppedVideoFrames: e,
                    decodedFrameCount: t
                })
            }
            checkMediaOptionType(e) {
                return e === gu.Variant || e === gu.AltAudio || (this.logger.error(Vf, 'Should not have media option type = "%s" in RTC', Nu[e]), !1)
            }
            rtcEventItemId(e = !1) {
                return (this.hls.isPreloading ? e ? this.hls.playingItem : this.hls.loadingItem : this.hls.currentItem).itemId
            }
            subscribeAndUpdateStore() {
                this.hls.publicQueries$.pipe(La(([, e]) => this.mediaElementQueryListener(e)), Va(this.destroy$)).subscribe(), this.hls.itemQueue.activeItemById$.pipe(Za(t => {
                    if (t) {
                        let e = !1;
                        if (this.hls.userInfo ? this.hls.userInfo.internalBuild ? e = !0 : this.hls.userInfo.diagnosticsAndUsage && (e = this.config.enableRtcReporting) : e = this.config.enableRtcReporting, e) {
                            const i = this.hls.reportingAgent;
                            i ? this.rtcComponent.setReportingAgent(i) : this.logger.warn(Vf, "[RTCA] - Reporting is enabled but reportingAgent is null")
                        } else this.rtcComponent.setReportingAgent(null);
                        this.serverInfoInstance = null;
                        t = t.itemId;
                        this.rtcStore.createEntity(t), !this.hls.isFirstItem && this.hls.inGaplessMode || this.setPeriodic(t)
                    }
                }), Va(this.destroy$)).subscribe()
            }
            itemTransitioned(e, t) {
                this.rtcStore.updateVariantEnd(e, {
                    currentTime: this.hls.realCurrentTime
                }), this.sendAndFinalize(e, Nf.VariantEnded), this.rtcStore.updatePeriodic(e, !0), this.sendAndFinalize(e, Nf.Periodic), this.rtcStore.updateEnded(e), this.sendAndFinalize(e, Nf.PlayEnded), this.setPeriodic(t)
            }
            mediaElementQueryListener(e) {
                return e.gotPlaying$.pipe(Za(e => {
                    if (e) {
                        const e = this.oldRate,
                            t = this.newRate || 1;
                        1 < Math.abs(e) && 1 < Math.abs(t) || (this.rtcStore.updateCanPlay(this.rtcEventItemId(!0), {
                            mediaDur: this.hls.bufferedDuration
                        }), this.sendAndFinalize(this.rtcEventItemId(!0), Nf.PlayLikelyToKeepUp), this.rtcStore.updateRateChanged(this.rtcEventItemId(!0), {
                            rate: t,
                            latency: ne(this.playStart) ? Date.now() - this.playStart : 0,
                            mediaDur: this.hls.bufferedDuration,
                            currentTime: this.hls.realCurrentTime,
                            url: this.levelSwitchingUrl
                        }), this.sendAndFinalize(this.rtcEventItemId(!0), Nf.PlayRateChanged))
                    }
                }))
            }
            registerForEvents() {
                const e = Oc(this.hls, this);
                an(e.event(P.KEY_REQUEST_STARTED, this.keyRequestStarted, this), e.event(P.KEY_LOADED, this.keyLoaded, this)).pipe(Va(this.destroy$)).subscribe()
            }
            keyRequestStarted(e) {
                e.timestamp = Date.now(), this.rtcStore.updateLicenseChallengeRequested(this.rtcEventItemId(), e)
            }
            keyLoaded(e) {
                e.timestamp = Date.now(), e.currentTime = this.hls.realCurrentTime, this.rtcStore.updateSegmentKeyLoaded(this.rtcEventItemId(), e)
            }
            licenseChallengeReceived(e) {
                this.rtcStore.updateLicenseChallengeReceived(this.rtcEventItemId(), {
                    timestamp: Date.now(),
                    keyuri: e.keyuri
                })
            }
            licenseChallengeSubmitted(e) {
                this.rtcStore.updateLicenseChallengeSubmitted(this.rtcEventItemId(), {
                    timestamp: Date.now(),
                    keyFormat: e.keyFormat,
                    keyuri: e.keyuri
                })
            }
            licenseChallengeCreated(e) {
                this.rtcStore.updateLicenseChallengeCreated(this.rtcEventItemId(), {
                    timestamp: Date.now(),
                    cdmVersion: e.cdmVersion,
                    keyuri: e.keyuri
                }), this.rtcStore.updateLicenseResponseRequested(this.rtcEventItemId(), {
                    timestamp: Date.now(),
                    keyuri: e.keyuri
                })
            }
            licenseResponseSubmitted(e) {
                this.rtcStore.updateLicenseResponseReceived(this.rtcEventItemId(), {
                    timestamp: Date.now(),
                    keyuri: e.keyuri
                }), this.rtcStore.updateLicenseResponseSubmitted(this.rtcEventItemId(), {
                    timestamp: Date.now(),
                    keyuri: e.keyuri
                })
            }
            licenseResponseProcessed(e) {
                this.rtcStore.updateLicenseResponseProcessed(this.rtcEventItemId(), {
                    timestamp: Date.now(),
                    keyuri: e.keyuri,
                    currentTime: this.hls.realCurrentTime
                }), this.sendAndFinalize(this.rtcEventItemId(), Nf.KeySessionComplete)
            }
            licenseChallengeError(e) {
                this.rtcStore.updateLicenseChallengeError(this.rtcEventItemId(), {
                    timestamp: Date.now(),
                    keyuri: e.keyuri
                }), this.sendAndFinalize(this.rtcEventItemId(), Nf.KeySessionComplete)
            }
            licenseResponseError(e) {
                this.rtcStore.updateLicenseResponseError(this.rtcEventItemId(), {
                    timestamp: Date.now(),
                    keyuri: e.keyuri
                }), this.sendAndFinalize(this.rtcEventItemId(), Nf.KeySessionComplete)
            }
            keyAborted(e) {
                var t;
                null != (null === (t = this.rtcQuery.getEntity(this.rtcEventItemId())) || void 0 === t ? void 0 : t.sessionControlRecord.activeKeySessions[e.keyuri]) ? (this.rtcStore.updateKeyAborted(this.rtcEventItemId(), {
                    timestamp: Date.now(),
                    keyuri: e.keyuri
                }), this.sendAndFinalize(this.rtcEventItemId(), Nf.KeySessionComplete)) : this.logger.warn(`keyAbort called without active key session ${le(e.keyuri)}`)
            }
            setPeriodic(e) {
                this.clearPeriodic(), this.intervalFunc = setInterval(this.handlePeriodic.bind(this, e), this.periodicInterval)
            }
            handlePeriodic(e) {
                this.rtcStore.updatePeriodic(e, !1), this.sendAndFinalize(e, Nf.Periodic)
            }
            clearPeriodic() {
                this.intervalFunc && clearInterval(this.intervalFunc), this.intervalFunc = null
            }
            sendAndFinalize(e, t) {
                switch (this.accessLog.addPlayTime(e), t) {
                    case Nf.PlayEnded:
                        this.rtcComponent.sendPlayEnded(e);
                        break;
                    case Nf.Periodic:
                        this.rtcComponent.sendPeriodic(e);
                        break;
                    case Nf.PlayStalled:
                        this.accessLog.updateStallCount(e), this.rtcComponent.sendPlayStalled(e);
                        break;
                    case Nf.KeySessionComplete:
                        this.rtcComponent.sendKeySessionComplete(e);
                        break;
                    case Nf.PlayLikelyToKeepUp:
                        this.accessLog.updateCanPlay(e), this.rtcComponent.sendPlayLikelyToKeepUp(e);
                        break;
                    case Nf.PlayRateChanged:
                        this.rtcComponent.sendPlayRateChange(e);
                        break;
                    case Nf.PlayError:
                        this.accessLog.addToErrorLog(e, "mediaError"), this.rtcComponent.sendPlayError(e);
                        break;
                    case Nf.MediaEngineStalled:
                        this.accessLog.updateMediaEngineStallCount(e), this.rtcComponent.sendMediaEngineStalled(e);
                        break;
                    case Nf.SwitchComplete:
                        this.accessLog.addToAccessLog(e), this.rtcComponent.sendSwitchComplete(e);
                        break;
                    case Nf.VariantEnded:
                        this.rtcComponent.sendVariantEnded(e);
                        break;
                    case Nf.NwError:
                        this.accessLog.addToErrorLog(e, "networkError"), this.rtcComponent.sendNwError(e);
                        break;
                    default:
                        return void this.logger.error(Vf, `Unknown rtc event eventGroupId:${e}`)
                }
                this.rtcStore.finalize(e, t)
            }
        }
        const qf = a => (e, t) => {
                let i = 0,
                    r = 0;
                for (var {
                        timestamp: n,
                        value: s
                    } of e) {
                    const e = Math.pow(Math.max(0, n - t) / 1e3, a);
                    i += e * s, r += e
                }
                return i / r
            },
            Hf = {
                "uniform-time-weighted": qf(0),
                "linear-time-weighted": qf(1),
                "quadratic-time-weighted": qf(2)
            };
        class jf {
            constructor(e, t = "quadratic-time-weighted", i = {
                avgLatencyMs: NaN,
                avgBandwidth: NaN
            }) {
                this.windowSize = e, this.aggregationMethod = t, this.latencyEntries = [], this.bandwidthEntries = [], this.minEntries = 1, this.cleanUpExpiredEntries = this.cleanUpExpiredEntries.bind(this), this.bwSubject = new yi(i)
            }
            get estimate$() {
                return this.bwSubject.asObservable()
            }
            record(e) {
                var {
                    trequest: t,
                    tfirst: i,
                    tload: r,
                    bitsDownloaded: e
                } = e;
                t !== r && (this.recordLatency(t, i), this.recordBandwidth(t, r, 1e3 * e / (r - t)), this.bwSubject.closed || (t = this.getEstimate(), this.bwSubject.next(t)))
            }
            getEstimate() {
                if (this.latencyEntries.length < this.minEntries) return {
                    avgLatencyMs: NaN,
                    avgBandwidth: NaN
                };
                const e = performance.now() - this.windowSize,
                    t = Hf[this.aggregationMethod],
                    i = this.latencyEntries.map(({
                        start: e,
                        end: t
                    }) => ({
                        timestamp: t,
                        value: t - e,
                        duration: 1
                    }));
                this.bandwidthEntries = function(r) {
                    function n(t, i) {
                        if (t.length) {
                            for (let e = 0; e < t.length; e++)
                                if (t[e].start > i.start || t[e].start === i.start && t[e].end > i.end) {
                                    t.splice(e, 0, i);
                                    break
                                }
                        } else t.push(i)
                    }
                    const s = [...r].sort((e, t) => e.start !== t.start ? e.start - t.start : e.end - t.end),
                        t = [];
                    for (; s.length;) {
                        const r = s[0];
                        let e;
                        if (s.shift(), t.length && (e = t[t.length - 1]), 0 === t.length || e.end <= r.start) t.push(r);
                        else if (r.start === e.start) r.end === e.end ? e.bitsPerSec += r.bitsPerSec : r.end < e.end || (e.bitsPerSec += r.bitsPerSec, r.start = e.end, n(s, r));
                        else {
                            var a = e.end,
                                o = e.bitsPerSec;
                            e.end = r.start;
                            var i = {
                                start: r.start,
                                end: Math.min(a, r.end),
                                bitsPerSec: r.bitsPerSec + o
                            };
                            if (t.push(i), a !== r.end) {
                                let e = 0,
                                    t = 0,
                                    i = 0;
                                i = a < r.end ? (e = a, t = r.end, r.bitsPerSec) : (e = r.end, t = a, o), n(s, {
                                    start: e,
                                    end: t,
                                    bitsPerSec: i
                                })
                            }
                        }
                    }
                    return t
                }(this.bandwidthEntries);
                var r = this.bandwidthEntries.map(({
                    end: e,
                    bitsPerSec: t
                }) => ({
                    timestamp: e,
                    duration: 1,
                    value: t
                }));
                return {
                    avgLatencyMs: t(i, e),
                    avgBandwidth: t(r, e)
                }
            }
            getLatest() {
                if (0 === this.latencyEntries.length) return {
                    avgLatencyMs: NaN,
                    avgBandwidth: NaN
                };
                var e = this.latencyEntries[this.latencyEntries.length - 1],
                    t = this.bandwidthEntries[this.bandwidthEntries.length - 1];
                return {
                    avgLatencyMs: e.end - e.start,
                    avgBandwidth: t.bitsPerSec
                }
            }
            recordLatency(e, t) {
                this.latencyEntries.push({
                    start: e,
                    end: t
                }), this.updateCleanupTimeout(t)
            }
            recordBandwidth(e, t, i) {
                this.bandwidthEntries.push({
                    start: e,
                    end: t,
                    bitsPerSec: i
                }), this.updateCleanupTimeout(t)
            }
            setCleanupTimeout(e) {
                this.cleanupTimeout = setTimeout(this.cleanUpExpiredEntries, Math.max(e - performance.now(), 0)), this.cleanupTimestamp = e
            }
            clearCleanupTimeout() {
                void 0 !== this.cleanupTimeout && (clearTimeout(this.cleanupTimeout), this.cleanupTimeout = void 0), this.cleanupTimestamp = void 0
            }
            updateCleanupTimeout(e) {
                e += this.windowSize;
                (!this.cleanupTimestamp || e < this.cleanupTimestamp) && (this.clearCleanupTimeout(), this.setCleanupTimeout(e))
            }
            cleanUpExpiredEntries() {
                this.clearCleanupTimeout();
                const t = performance.now() - this.windowSize;
                if (this.latencyEntries = this.latencyEntries.filter(e => e.end >= t), this.bandwidthEntries = this.bandwidthEntries.filter(e => e.end >= t), this.bwSubject.closed || this.bwSubject.next(this.getEstimate()), 0 < this.latencyEntries.length || 0 < this.bandwidthEntries.length) {
                    const t = Math.min(...this.latencyEntries.map(e => e.end), ...this.bandwidthEntries.map(e => e.end));
                    this.updateCleanupTimeout(t)
                }
            }
            destroy() {
                this.clearCleanupTimeout()
            }
        }
        const Qf = {
            setCombinedEstimate: function(t, i, r) {
                const n = Qe();
                if (void 0 !== t.storage.set) {
                    var s = t.bandwidthHistoryStorageKey,
                        a = {
                            avgLatencyMs: i.avgLatencyMs,
                            avgBandwidth: i.avgBandwidth
                        },
                        a = Object.assign({}, a, {
                            expires: Date.now() + t.bandwidthHistoryTTL
                        });
                    try {
                        t.storage.set(s, JSON.stringify(a))
                    } catch (t) {
                        n.warn(`Error stringifying! Not persisting bandwidth estimates: ${t.message}`)
                    }
                    i = {
                        maxDuration: i.maxDurationSec,
                        avgFragParseTimeMs: i.avgParseTimeMs,
                        avgFragBufferCreationDelayMs: i.avgBufferCreateMs,
                        avgPlaylistLoadTimeMs: i.avgPlaylistLoadTimeMs,
                        avgPlaylistParseTimeMs: i.avgPlaylistParseTimeMs,
                        avgInitFragAppendMs: i.avgInitFragAppendMs,
                        avgDataFragAppendMs: i.avgDataFragAppendMs
                    };
                    let e = t.storageKeyPrefix;
                    r && (e += r);
                    try {
                        t.storage.set(e, JSON.stringify(i))
                    } catch (t) {
                        n.warn(`Error stringifying! Not persisting bandwidth estimates: ${t.message}`)
                    }
                } else n.warn("storage.set is not supported! Not persisting bandwidth estimates")
            },
            getCombinedEstimate: function(t, e) {
                const i = Qe();
                let r = {};
                if (void 0 === t.storage.get) return i.warn("storage.get is not supported! unable to retreive bandwidth estimates"), this.convertStorageJsonToCombinedEstimate(r);
                try {
                    let e = JSON.parse(t.storage.get(t.bandwidthHistoryStorageKey));
                    e = null != e && e.expires && e.expires < Date.now() ? null : {
                        avgLatencyMs: null == e ? void 0 : e.avgLatencyMs,
                        avgBandwidth: null == e ? void 0 : e.avgBandwidth
                    }, r = Object.assign(Object.assign({}, r), e)
                } catch (t) {
                    i.warn(`Unable to get persisted bandwidth history: ${t.message}`)
                }
                let n = t.storageKeyPrefix;
                e && (n += e);
                try {
                    const e = JSON.parse(t.storage.get(n));
                    r = Object.assign(Object.assign({}, r), e)
                } catch (t) {
                    i.warn(`Unable to get persisted bandwidth history: ${t.message}`)
                }
                return this.convertStorageJsonToCombinedEstimate(r)
            },
            convertStorageJsonToCombinedEstimate: function(e) {
                return {
                    avgLatencyMs: (null == e ? void 0 : e.avgLatencyMs) || NaN,
                    avgBandwidth: (null == e ? void 0 : e.avgBandwidth) || NaN,
                    maxDurationSec: (null == e ? void 0 : e.maxDuration) || NaN,
                    avgParseTimeMs: (null == e ? void 0 : e.avgFragParseTimeMs) || NaN,
                    avgBufferCreateMs: (null == e ? void 0 : e.avgFragBufferCreationDelayMs) || NaN,
                    avgPlaylistLoadTimeMs: (null == e ? void 0 : e.avgPlaylistLoadTimeMs) || NaN,
                    avgPlaylistParseTimeMs: (null == e ? void 0 : e.avgPlaylistParseTimeMs) || NaN,
                    avgInitFragAppendMs: (null == e ? void 0 : e.avgInitFragAppendMs) || NaN,
                    avgDataFragAppendMs: (null == e ? void 0 : e.avgDataFragAppendMs) || NaN
                }
            },
            getBandwidthEstimate: function(e, t) {
                const i = this.getCombinedEstimate(e, t),
                    r = {
                        avgLatencyMs: null == i ? void 0 : i.avgLatencyMs,
                        avgBandwidth: null == i ? void 0 : i.avgBandwidth
                    };
                return ne(r.avgLatencyMs) || (r.avgLatencyMs = NaN), ne(r.avgBandwidth) || (r.avgBandwidth = NaN), r
            },
            getPlaylistEstimate: function(e, t) {
                const i = this.getCombinedEstimate(e, t),
                    r = {
                        avgPlaylistLoadTimeMs: null == i ? void 0 : i.avgPlaylistLoadTimeMs,
                        avgPlaylistParseTimeMs: null == i ? void 0 : i.avgPlaylistParseTimeMs
                    };
                return ne(r.avgPlaylistLoadTimeMs) || (r.avgPlaylistLoadTimeMs = NaN), ne(r.avgPlaylistParseTimeMs) || (r.avgPlaylistParseTimeMs = NaN), r
            },
            getFragEstimate: function(e, t) {
                const i = this.getCombinedEstimate(e, t),
                    r = {
                        maxDurationSec: null == i ? void 0 : i.maxDurationSec,
                        avgParseTimeMs: null == i ? void 0 : i.avgParseTimeMs
                    };
                return ne(r.maxDurationSec) || (r.maxDurationSec = NaN), ne(r.avgParseTimeMs) || (r.avgParseTimeMs = NaN), r
            },
            getBufferEstimate: function(e, t) {
                const i = this.getCombinedEstimate(e, t),
                    r = {
                        avgBufferCreateMs: null == i ? void 0 : i.avgBufferCreateMs,
                        avgInitFragAppendMs: null == i ? void 0 : i.avgInitFragAppendMs,
                        avgDataFragAppendMs: null == i ? void 0 : i.avgDataFragAppendMs
                    };
                return ne(r.avgBufferCreateMs) || (r.avgBufferCreateMs = NaN), ne(r.avgInitFragAppendMs) || (r.avgInitFragAppendMs = NaN), ne(r.avgDataFragAppendMs) || (r.avgDataFragAppendMs = NaN), r
            }
        };
        var Wf = Qf;
        class Gf {
            constructor(e = 0) {
                this._minSamples = e, this._sum = 0, this._max = Number.NEGATIVE_INFINITY, this._numSamples = 0
            }
            get avg() {
                return this._numSamples < this._minSamples ? NaN : this._sum / this._numSamples
            }
            get max() {
                return 0 < this.count ? this._max : NaN
            }
            get count() {
                return this._numSamples
            }
            reset() {
                this._sum = 0, this._numSamples = 0, this._max = Number.NEGATIVE_INFINITY
            }
            add(e) {
                this._sum += e, this._max = Math.max(this._max, e), ++this._numSamples
            }
        }
        class zf extends kl {
            constructor(e, t) {
                super(e), this.id = t
            }
            getBandwidthEstimate(e, t) {
                var i;
                const r = Object.assign({}, null === (i = this.statsEntity) || void 0 === i ? void 0 : i.bandwidthEstimate);
                if (ne(r.avgBandwidth) && ne(r.avgLatencyMs)) return r;
                if (e) {
                    const i = Qf.getBandwidthEstimate(e, t);
                    ne(r.avgBandwidth) || (r.avgBandwidth = i.avgBandwidth), ne(r.avgLatencyMs) || (r.avgLatencyMs = i.avgLatencyMs)
                }
                return r
            }
            getPlaylistEstimate(e, t) {
                var i;
                const r = Object.assign({}, null === (i = this.statsEntity) || void 0 === i ? void 0 : i.playlistEstimate),
                    n = e => ne(e.avgPlaylistLoadTimeMs) && ne(e.avgPlaylistParseTimeMs);
                if (n(r)) return r;
                if (e) {
                    const i = Qf.getPlaylistEstimate(e, t);
                    if (ne(r.avgPlaylistLoadTimeMs) || (r.avgPlaylistLoadTimeMs = i.avgPlaylistLoadTimeMs), ne(r.avgPlaylistParseTimeMs) || (r.avgPlaylistParseTimeMs = i.avgPlaylistParseTimeMs), n(r)) return r;
                    ne(r.avgPlaylistLoadTimeMs) || (r.avgPlaylistLoadTimeMs = e.statDefaults.playlistLoadTimeMs), ne(r.avgPlaylistParseTimeMs) || (r.avgPlaylistParseTimeMs = e.statDefaults.playlistParseTimeMs)
                }
                return r
            }
            getBufferEstimate(e, t) {
                var i;
                const r = Object.assign({}, null === (i = this.statsEntity) || void 0 === i ? void 0 : i.bufferEstimate),
                    n = e => ne(e.avgBufferCreateMs) && ne(e.avgDataFragAppendMs) && ne(e.avgInitFragAppendMs);
                if (n(r)) return r;
                if (e) {
                    const i = Qf.getBufferEstimate(e, t);
                    if (ne(r.avgBufferCreateMs) || (r.avgBufferCreateMs = i.avgBufferCreateMs), ne(r.avgDataFragAppendMs) || (r.avgDataFragAppendMs = i.avgDataFragAppendMs), ne(r.avgInitFragAppendMs) || (r.avgInitFragAppendMs = i.avgInitFragAppendMs), n(r)) return r;
                    ne(r.avgBufferCreateMs) || (r.avgBufferCreateMs = e.statDefaults.fragBufferCreationDelayMs), ne(r.avgDataFragAppendMs) || (r.avgDataFragAppendMs = e.statDefaults.dataFragAppendMs), ne(r.avgInitFragAppendMs) || (r.avgInitFragAppendMs = e.statDefaults.initFragAppendMs)
                }
                return r
            }
            getFragEstimate(e, t) {
                var i;
                const r = Object.assign({}, null === (i = this.statsEntity) || void 0 === i ? void 0 : i.fragEstimate),
                    n = e => ne(e.maxDurationSec) && ne(e.avgParseTimeMs);
                if (n(r)) return r;
                if (e) {
                    const i = Qf.getFragEstimate(e, t);
                    if (ne(r.maxDurationSec) || (r.maxDurationSec = i.maxDurationSec), ne(r.avgParseTimeMs) || (r.avgParseTimeMs = i.avgParseTimeMs), n(r)) return r;
                    ne(r.maxDurationSec) || (r.maxDurationSec = e.defaultTargetDuration), ne(r.avgParseTimeMs) || (r.avgParseTimeMs = e.statDefaults.fragParseTimeMs)
                }
                return r
            }
            getCombinedEstimate() {
                return Object.assign(Object.assign(Object.assign(Object.assign({}, this.getFragEstimate()), this.getPlaylistEstimate()), this.getBufferEstimate()), this.getBandwidthEstimate())
            }
            get statsEntity() {
                return this.getEntity(this.id)
            }
            get bandwidthSample() {
                var e;
                return null === (e = this.statsEntity) || void 0 === e ? void 0 : e.bandwidthSample
            }
            get bandwidthStatus() {
                var e;
                return null === (e = this.statsEntity) || void 0 === e ? void 0 : e.bandwidthStatus
            }
            get fragSample() {
                var e;
                return null === (e = this.statsEntity) || void 0 === e ? void 0 : e.fragSample
            }
            get bandwidthEstimate$() {
                return this.selectEntity(this.id, "bandwidthEstimate")
            }
            get fragEstimate$() {
                return this.selectEntity(this.id, "fragEstimate")
            }
            get playlistEstimate$() {
                return this.selectEntity(this.id, "playlistEstimate")
            }
            get bufferEstimate$() {
                return this.selectEntity(this.id, "bufferEstimate")
            }
            get bandwidthSample$() {
                return this.selectEntity(this.id, ({
                    bandwidthSample: e
                }) => e).pipe(Kp())
            }
            get fragSample$() {
                return this.selectEntity(this.id, ({
                    fragSample: e
                }) => e).pipe(Kp())
            }
            get playlistSample$() {
                return this.selectEntity(this.id, ({
                    playlistSample: e
                }) => e).pipe(Kp())
            }
            get bufferMetric$() {
                return this.selectEntity(this.id, ({
                    bufferMetric: e
                }) => e).pipe(Kp())
            }
        }
        class Xf {
            constructor(e) {
                this.statsStore = e
            }
            getQuery() {
                return new kl(this.statsStore)
            }
            getQueryForItem(e) {
                return new zf(this.statsStore, e)
            }
            remove(e) {
                this.statsStore.remove(e)
            }
            removeAll() {
                this.statsStore.remove()
            }
            setBandwidthSample(e) {
                this.statsStore.bandwidthSample = e
            }
            setFragSample(e) {
                this.statsStore.fragSample = e
            }
            setPlaylistSample(e) {
                this.statsStore.playlistSample = e
            }
            setBufferMetric(e) {
                this.statsStore.bufferMetric = e
            }
            setBandwidthEstimate(e) {
                this.statsStore.bandwidthEstimate = e
            }
            setFragEstimate(e) {
                this.statsStore.fragEstimate = e
            }
            setPlaylistEstimate(e) {
                this.statsStore.playlistEstimate = e
            }
            setBufferEstimate(e) {
                this.statsStore.bufferEstimate = e
            }
        }
        const Yf = new class extends fl {
            constructor() {
                super({}, {
                    name: "stats-store",
                    producerFn: su
                })
            }
            set statsEntity(e) {
                Do("statsStore.set.stats"), al(() => {
                    this.add(e), this.setActive(e.id)
                })
            }
            set playlistSample(t) {
                Do(`stats.set.playlistSample: ${t}`), this.updateActive(e => {
                    e.playlistSample = t
                })
            }
            set bandwidthSample(t) {
                Do(`stats.set.bandwidthSample: ${t}`), this.updateActive(e => {
                    e.bandwidthSample = t, e.bandwidthStatus.bandwidthSampleCount += 1, e.bandwidthStatus.instantBw = 8e3 * t.loaded / (t.tload - t.trequest)
                })
            }
            set fragSample(t) {
                Do(`stats.set.fragSample: ${t}`), this.updateActive(e => {
                    e.fragSample = t
                })
            }
            set bufferMetric(t) {
                Do(`stats.set.bufferMetric: ${t}`), this.updateActive(e => {
                    e.bufferMetric = t
                })
            }
            set bandwidthEstimate(t) {
                Do(`stats.set.bandwidthEstimate: ${t}`), this.updateActive(e => {
                    e.bandwidthEstimate = t
                })
            }
            set fragEstimate(t) {
                Do(`stats.set.fragEstimate: ${t}`), this.updateActive(e => {
                    e.fragEstimate = t
                })
            }
            set playlistEstimate(t) {
                Do(`stats.set.playlistEstimate: ${t}`), this.updateActive(e => {
                    e.playlistEstimate = t
                })
            }
            set bufferEstimate(t) {
                Do(`stats.set.bufferEstimate: ${t}`), this.updateActive(e => {
                    e.bufferEstimate = t
                })
            }
        };
        let Jf = null;
        const Zf = e => new zf(Yf, e);

        function em(e, t) {
            if (e === t) return !0;
            if (!e || !t) return !1;
            let i = Object.keys(e).length === Object.keys(t).length;
            for (const r of Object.keys(e)) i = i && (isNaN(e[r]) && isNaN(t[r]) || e[r] === t[r]);
            return i
        }

        function tm(f, m, g) {
            return new $t(e => {
                (e => {
                    const t = Zf(e);
                    t.hasEntity(e) ? $i(t) : (i = Yf, e = e, Do("stats.loading"), i.setLoading(!0), i.statsEntity = {
                        id: e,
                        bandwidthEstimate: {
                            avgLatencyMs: NaN,
                            avgBandwidth: NaN
                        },
                        bandwidthStatus: {
                            bandwidthSampleCount: 0,
                            instantBw: NaN
                        },
                        fragEstimate: {
                            maxDurationSec: NaN,
                            avgParseTimeMs: NaN
                        },
                        playlistEstimate: {
                            avgPlaylistLoadTimeMs: NaN,
                            avgPlaylistParseTimeMs: NaN
                        },
                        bufferEstimate: {
                            avgBufferCreateMs: NaN,
                            avgInitFragAppendMs: NaN,
                            avgDataFragAppendMs: NaN
                        }
                    }, i.setLoading(!1), Do("stats.loaded"));
                    var i
                })(g.itemId);
                const t = Zf(g.itemId),
                    {
                        fragSample$: i,
                        playlistSample$: r,
                        bandwidthSample$: n,
                        bufferMetric$: s
                    } = t;
                return an(r.pipe(ji(tr), (h = f, p = m, e => e.pipe(tc("statsPlaylistProcessingEpic.in"), sa((e, t) => (e.playlistLoadTimeMs.add(t.playlistLoadTimeMs), e.playlistParseTimeMs.add(t.playlistParseTimeMs), e), {
                    playlistLoadTimeMs: new Gf(h.minPlaylistCount),
                    playlistParseTimeMs: new Gf(h.minPlaylistCount)
                }), hr(e => ({
                    avgPlaylistLoadTimeMs: e.playlistLoadTimeMs.avg,
                    avgPlaylistParseTimeMs: e.playlistParseTimeMs.avg
                })), Is(em), Za(e => {
                    p.setPlaylistEstimate(e)
                })))), n.pipe(ji(tr), (u = f, c = m, n => new $t(e => {
                    let t = new jf(u.bandwidthHistoryWindowSize, u.bandwidthHistoryAggregationMethod, {
                        avgLatencyMs: NaN,
                        avgBandwidth: NaN
                    });
                    const i = t.estimate$,
                        r = an(n.pipe(ln(e => e.complete), Za(e => {}), hr(e => ({
                            trequest: e.trequest,
                            tfirst: e.tfirst,
                            tload: e.tload,
                            bitsDownloaded: 8 * e.loaded
                        })), tc("statsBandwidthProcessingEpic.in"), La(e => (t.record(e), Ii))), i.pipe(Is(), tc("statsBandwidthProcessingEpic.change"), Za(e => {
                            c && c.setBandwidthEstimate(e)
                        }))).subscribe(e);
                    return () => {
                        r.unsubscribe(), t.destroy(), t = void 0
                    }
                }))), i.pipe(ji(tr), (l = f, d = m, e => e.pipe(tc("statsFragProcessingEpic.in"), sa((e, t) => (e.durationSec.add(t.durationSec), e.fragParseMs.add(t.parseTimeMs), e), {
                    durationSec: new Gf,
                    fragParseMs: new Gf(l.minFragmentCount)
                }), hr(e => ({
                    maxDurationSec: e.durationSec.max,
                    avgParseTimeMs: e.fragParseMs.avg
                })), Is(em), Za(e => d.setFragEstimate(e))))), s.pipe(ji(tr), (a = f, o = m, e => e.pipe(tc("statsBufferMetricProcessingEpic.in"), sa((e, t) => (ne(t.bufferCreationStart) && ne(t.bufferCreationEnd) && e.bufferCreateMs.add(t.bufferCreationEnd - t.bufferCreationStart), ne(t.startInitAppend) && ne(t.endInitAppend) && e.initFragAppendMs.add(t.endInitAppend - t.startInitAppend), ne(t.startDataAppend) && ne(t.endDataAppend) && e.dataFragAppendMs.add(t.endDataAppend - t.startDataAppend), e), {
                    bufferCreateMs: new Gf,
                    initFragAppendMs: new Gf,
                    dataFragAppendMs: new Gf(a.minFragmentCount)
                }), hr(e => ({
                    avgBufferCreateMs: e.bufferCreateMs.avg,
                    avgInitFragAppendMs: e.initFragAppendMs.avg,
                    avgDataFragAppendMs: e.dataFragAppendMs.avg
                })), Is(em), Za(e => {
                    o.setBufferEstimate(e)
                }))))).pipe($a(Ii)).subscribe(e), () => {
                    Wf.setCombinedEstimate(f, Object.assign(Object.assign(Object.assign(Object.assign({}, t.getFragEstimate()), t.getPlaylistEstimate()), t.getBufferEstimate()), t.getBandwidthEstimate()), g.serviceName), m.remove(g.itemId)
                };
                var a, o, l, d, u, c, h, p
            })
        }
        const im = {
            isWebkitMediaElement: e => "webkitDroppedFrameCount" in e,
            isHtmlVideoElement: e => "getVideoPlaybackQuality" in e,
            timeRangeToArray(t) {
                const i = [];
                for (let e = 0; e < t.length; e++) i.push([t.start(e), t.end(e)]);
                return i
            }
        };
        class rm {
            constructor(e, t) {
                this.hls = e, this.sessionID = t, this.rtcQuery = null, this.accessLogData = this.createAccessLogEntry(), this.accesslog = [], this.errorlog = []
            }
            destroy() {
                this.rtcQuery = null, this.accesslog = [], this.errorlog = [], this.accessLogData = void 0, this.accessLogReporter = void 0
            }
            setRTCQuery(e) {
                this.rtcQuery = e
            }
            setupReporter(e) {
                this.accessLogReporter = {
                    SessionID: this.sessionID,
                    ClientName: null == e ? void 0 : e.clientName,
                    ServiceName: null == e ? void 0 : e.serviceName
                }
            }
            addPlayTime(e) {
                var t, e = null === (t = this.rtcQuery) || void 0 === t ? void 0 : t.getEntity(e);
                !e || "RTC_STATE_PLAY" === (e = e.sessionControlRecord).state && (this.accessLogData.PlayTimeWC = (this.accessLogData.PlayTimeWC || 0) + e.eventStartTime)
            }
            updatePlaybackInfo(e, t) {
                this.accessLogData.ViFrDr = this.rtcQuery.getEntity(e).sessionControlRecord.droppedVideoFrames || 0
            }
            updateStallCount(e) {
                "RTC_STATE_PLAY" === this.rtcQuery.getEntity(e).sessionControlRecord.state && this.accessLogData.StallCount++
            }
            updateMediaEngineStallCount(e) {
                "RTC_STATE_PLAY" === this.rtcQuery.getEntity(e).sessionControlRecord.state && this.accessLogData.MediaEngineStallCount++
            }
            updateCanPlay(e) {
                this.accessLogData.StartupTime = this.rtcQuery.getEntity(e).sessionControlRecord.eventStartTime
            }
            updateFragLoaded(e, t, i) {
                var r;
                i.fragType === gu.Variant ? (this.accessLogData.NetBytes += i.bytes, this.accessLogData.ADT += i.adt, r = this.aggregateFragObserverdBitrate(i, ++this.accessLogData.fragmentCnt, this.accessLogData.NetBytes, this.accessLogData.ADT), this.accessLogData.OBRLast = r.obrLast, this.accessLogData.OBRMean = r.obrMean, this.aggregateFragMinMaxBitrate(this.accessLogData, r.obr), this.hls.realCurrentTime > i.startPTS && !t && this.accessLogData.overdue++, this.hasGap(i.startPTS, i.endPTS, this.accessLogData.lastStartPTS, this.accessLogData.lastEndPTS) && this.addToAccessLog(e), this.accessLogData.startPTS || (this.accessLogData.startPTS = i.startPTS), this.accessLogData.lastStartPTS = i.startPTS, this.accessLogData.lastEndPTS = i.endPTS, this.accessLogData.videoBytes += i.bytes, this.accessLogData.videoDuration += i.duration) : i.fragType === gu.AltAudio && (this.accessLogData.audioBytes += i.bytes, this.accessLogData.audioDuration += i.duration)
            }
            addToAccessLog(e) {
                var t = this.getVariantInfo(e),
                    i = this.rtcQuery.getEntity(e).sessionControlRecord.curLevelUrl,
                    r = this.rtcQuery.getEntity(e).playEndedRecord.PlayType;
                if (i && "" !== i) {
                    r = this.translateToAccessLogItem(e, i, t, r);
                    if (r) {
                        const n = this.accesslog.length - 20;
                        0 < n && this.accesslog.splice(0, n), this.accesslog.push(r)
                    }
                    this.accessLogData = this.createAccessLogEntry();
                    e = this.rtcQuery.getEntity(e).switchCompleteRecord.MediaDur;
                    this.accessLogData.lastMediaDur = e || this.hls.bufferedDuration
                }
            }
            addToErrorLog(e, t) {
                var i = null === (r = this.rtcQuery) || void 0 === r ? void 0 : r.getEntity(e);
                if (i) {
                    var r = Number(("mediaError" === t ? i.playErrorRecord : i.nwErrorRecord).ErrCode),
                        i = i.sessionControlRecord.curLevelUrl,
                        r = this.translateToErrorLogItem(e, i, {
                            domain: t,
                            code: r
                        });
                    if (r) {
                        const e = this.errorlog.length - 20;
                        0 < e && this.errorlog.splice(0, e), this.errorlog.push(r)
                    }
                }
            }
            getAccessLog(e) {
                var t;
                const i = this.accesslog.slice(0),
                    r = null === (t = this.rtcQuery) || void 0 === t ? void 0 : t.getEntity(e);
                if (i && r) {
                    const t = r.sessionControlRecord.curLevelUrl;
                    if (t && "" !== t) {
                        const r = this.getVariantInfo(e),
                            n = this.translateToAccessLogItem(e, t, r, this.rtcQuery.getEntity(e).playEndedRecord.PlayType);
                        n && (n["c-provisional-entry"] = !0, i.push(n))
                    }
                }
                return i
            }
            get errorLog() {
                return this.errorlog
            }
            createAccessLogEntry() {
                return {
                    fragmentCnt: 0,
                    overdue: 0,
                    startPTS: 0,
                    obrMax: 0,
                    obrMin: 0,
                    audioBytes: 0,
                    audioDuration: 0,
                    videoBytes: 0,
                    videoDuration: 0,
                    svrAddrChanged: 0,
                    svrAddr: "",
                    PlayTimeWC: 0,
                    ViFrDr: 0,
                    StallCount: 0,
                    MediaEngineStallCount: 0,
                    ADT: 0,
                    NetBytes: 0,
                    StartupTime: 0,
                    OBRMean: 0,
                    OBRLast: 0
                }
            }
            convertStringObjectToPrimitive(e) {
                return e ? "object" == typeof e ? e.toString() : e : ""
            }
            updateSvrAddrStats(t) {
                const i = bu.parseURL(t);
                if (i && i.netLoc) {
                    const t = i.netLoc.indexOf(":");
                    let e = 0 <= t ? i.netLoc.slice(0, t) : i.netLoc;
                    e.startsWith("//") && (e = e.slice(2)), this.accessLogData.svrAddr ? e !== this.accessLogData.svrAddr && this.accessLogData.svrAddrChanged++ : this.accessLogData.svrAddrChanged = 0, this.accessLogData.svrAddr = e
                }
            }
            translateToAccessLogItem(e, t, i, r) {
                t = this.convertStringObjectToPrimitive(t);
                this.updateSvrAddrStats(t);
                let n = this.rtcQuery.getEntity(e).switchCompleteRecord.MediaDur;
                n = n || this.hls.bufferedDuration, n = n || 0;
                const s = {
                    uri: t,
                    "s-ip": this.accessLogData.svrAddr,
                    "s-ip-changes": this.accessLogData.svrAddrChanged,
                    "sc-wwan-count": -1,
                    "c-transfer-duration": this.accessLogData.ADT,
                    bytes: this.accessLogData.NetBytes,
                    "c-total-media-requests": this.accessLogData.fragmentCnt,
                    "cs-guid": this.accessLogReporter.SessionID,
                    "c-start-time": this.accessLogData.startPTS,
                    "c-startup-time": this.accessLogData.StartupTime,
                    "c-duration-watched": this.accessLogData.PlayTimeWC / 1e3,
                    "c-frames-dropped": this.accessLogData.ViFrDr,
                    "c-stalls": this.accessLogData.StallCount + this.accessLogData.MediaEngineStallCount,
                    "c-duration-downloaded": this.accessLogData.lastMediaDur ? n - this.accessLogData.lastMediaDur : n,
                    "c-overdue": this.accessLogData.overdue,
                    "c-avg-video-bitrate": 8 * this.accessLogData.videoBytes / (this.accessLogData.videoDuration || 1),
                    "c-observed-max-bitrate": this.accessLogData.obrMax,
                    "c-observed-min-bitrate": this.accessLogData.obrMin,
                    "sc-indicated-bitrate": i.bandwidth || 0,
                    "sc-indicated-avg-bitrate": i.avgBandwidth || 0,
                    "c-observed-bitrate": this.accessLogData.OBRMean,
                    "c-switch-bitrate": this.accessLogData.OBRLast,
                    "c-provisional-entry": !1
                };
                return s["s-playback-type"] = r, this.accessLogData.audioBytes && (s["c-avg-audio-bitrate"] = 8 * this.accessLogData.audioBytes / (this.accessLogData.audioDuration || 1)), s
            }
            translateToErrorLogItem(e, t, i) {
                t = this.convertStringObjectToPrimitive(t);
                return this.updateSvrAddrStats(t), {
                    date: new Date,
                    "cs-guid": this.accessLogReporter.SessionID + "-" + e,
                    uri: t,
                    "s-ip": this.accessLogData.svrAddr,
                    status: "" + i.code,
                    domain: i.domain
                }
            }
            hasGap(e, t, i, r) {
                return void 0 !== e && void 0 !== i && (1 < e - r || 1 < i - t)
            }
            aggregateFragObserverdBitrate(e, t, i, r) {
                r = 8 * i / (r / 1e3);
                return {
                    obr: r,
                    obrLast: 8 * e.bytes / (e.adt / 1e3),
                    obrMean: r / t
                }
            }
            aggregateFragMinMaxBitrate(e, t) {
                (!e.obrMax || t > e.obrMax) && (e.obrMax = t), (!e.obrMin || t < e.obrMin) && (e.obrMin = t)
            }
            getVariantInfo(e) {
                var t = this.rtcQuery.getEntity(e).sessionControlRecord.curLevelUrl,
                    e = null === (e = this.rtcQuery.getEntity(e).sessionControlRecord.manifestData) || void 0 === e ? void 0 : e.variantList;
                return t && e && e[t] ? e[t] : {}
            }
        }
        const nm = (r, e, t, i, n, s) => {
                var a, {
                        absoluteUrl: o,
                        byteRangeOffset: l,
                        keyTagInfo: d,
                        iframe: u,
                        isInitSegment: c
                    } = r,
                    h = o,
                    p = d["method"],
                    {
                        start: o,
                        end: d
                    } = l,
                    t = Lc({
                        url: h
                    }, t);
                let f, m = o,
                    g = d,
                    y = !1,
                    v = ne(o) || ne(d) ? l : void 0;
                if ("AES-128" === p && d && (u || c)) {
                    const r = d - o;
                    r % 16 && (g = d + (16 - r % 16)), 0 !== o && (y = !0, m = o - 16), v = {
                        start: m,
                        end: g
                    }
                }
                return n && ne(r.mediaSeqNum) && r.mediaOptionType === gu.Variant && (f = [], null === (n = t.reportHTTPResponseHeaders) || void 0 === n || n.forEach(function(e) {
                    Ou.includes(e) ? f.push(e) : Qe().warn({
                        name: "load-media-fragment"
                    }, `${e} is not in approved privacy list. Actions required.`)
                }), 0 === f.length && (f = void 0)), Rc({
                    url: h,
                    byteRangeOffset: v,
                    checkContentLength: !0,
                    extendMaxTTFB: s,
                    collectServerInstanceInfo: f,
                    onProgress: i,
                    xhrSetup: e.xhrSetup
                }, t).pipe(hr(([e, t, i]) => {
                    if (y) {
                        const t = e;
                        r.keyTagInfo.iv = new Uint8Array(t.slice(0, 16)), e = t.slice(16)
                    }
                    return [r, e, t, i]
                }), (a = r, e => e.pipe(Vn(e => {
                    if (e instanceof pc) throw new hc(!1, "Timeout", 0, $.FragmentTimeoutError, !0, a, e.stats);
                    if (e instanceof oc) throw new hc(!1, e.message, e.code, {
                        code: e.code,
                        text: "Fragment Network Error"
                    }, !1, a);
                    throw e
                }))))
            },
            sm = {
                clearkey: th,
                fairplaystreaming: Sc,
                playready: Fc,
                widevine: Bc
            },
            am = {
                getKeySystemFormat(e) {
                    e = sm[e];
                    return e ? e.keyFormatString : ""
                },
                getKeySystemSecurityLevel(e) {
                    e = sm[e];
                    return e ? e.securityLevels : null
                }
            },
            om = {
                NONE: "",
                "AES-128": "",
                "ISO-23001-7": "",
                "SAMPLE-AES": "",
                "SAMPLE-AES-CTR": ""
            },
            lm = {
                NONE: 0,
                "TYPE-0": 1,
                "TYPE-1": 2,
                "TYPE-2": 3
            };

        function dm(e) {
            return e in lm
        }

        function um(e) {
            return null == e ? 4 : lm[e]
        }
        const cm = ["SDR", "PQ", "HLG"],
            hm = {
                afr: "af",
                aka: "ak",
                amh: "am",
                ara: "ar",
                arg: "an",
                asm: "as",
                ava: "av",
                ave: "ae",
                aym: "ay",
                aze: "az",
                bam: "bm",
                bel: "be",
                ben: "bn",
                bih: "bh",
                bod: "bo",
                bos: "bs",
                bre: "br",
                bul: "bg",
                cat: "ca",
                ces: "cs",
                cha: "ch",
                che: "ce",
                chu: "cu",
                chv: "cv",
                cor: "kw",
                cos: "co",
                cre: "cr",
                cym: "cy",
                dan: "da",
                deu: "de",
                div: "dv",
                dzo: "dz",
                ell: "el",
                eng: "en",
                epo: "eo",
                est: "et",
                eus: "eu",
                ewe: "ee",
                fao: "fo",
                fas: "fa",
                fin: "fi",
                fra: "fr",
                fry: "fy",
                ful: "ff",
                gla: "gd",
                gle: "ga",
                glg: "gl",
                glv: "gv",
                grn: "gn",
                guj: "gu",
                hat: "ht",
                heb: "he",
                her: "hz",
                hin: "hi",
                hmo: "ho",
                hrv: "hr",
                hun: "hu",
                hye: "hy",
                ibo: "ig",
                ido: "io",
                iii: "ii",
                iku: "iu",
                ile: "ie",
                ina: "ia",
                ind: "id",
                isl: "is",
                ita: "it",
                jav: "jv",
                jpn: "ja",
                kal: "kl",
                kan: "kn",
                kas: "ks",
                kat: "ka",
                kau: "kr",
                kaz: "kk",
                khm: "km",
                kik: "ki",
                kin: "rw",
                kir: "ky",
                kom: "kv",
                kon: "kg",
                kor: "ko",
                kua: "kj",
                kur: "ku",
                lao: "lo",
                lat: "la",
                lav: "lv",
                lim: "li",
                lit: "lt",
                ltz: "lb",
                lub: "lu",
                lug: "lg",
                mah: "mh",
                mal: "ml",
                mar: "mr",
                mkd: "mk",
                mlg: "mg",
                mlt: "mt",
                mol: "mo",
                mon: "mn",
                mri: "mi",
                msa: "ms",
                mya: "my",
                nav: "nv",
                nbl: "nr",
                nde: "nd",
                ndo: "ng",
                nep: "ne",
                nld: "nl",
                nno: "nn",
                nob: "nb",
                nya: "ny",
                oci: "oc",
                oji: "oj",
                ori: "or",
                orm: "om",
                oss: "os",
                pan: "pa",
                pli: "pi",
                pol: "pl",
                por: "pt",
                pus: "ps",
                que: "qu",
                roh: "rm",
                ron: "ro",
                run: "rn",
                rus: "ru",
                san: "sa",
                sin: "si",
                slk: "sk",
                slv: "sl",
                sme: "se",
                snd: "sd",
                som: "so",
                spa: "es",
                sqi: "sq",
                srd: "sc",
                srp: "sr",
                sun: "su",
                swa: "sw",
                swe: "sv",
                tah: "ty",
                tam: "ta",
                tat: "tt",
                tel: "te",
                tgk: "tg",
                tgl: "tl",
                tha: "th",
                tir: "ti",
                ton: "to",
                tuk: "tk",
                tur: "tr",
                uig: "ug",
                ukr: "uk",
                urd: "ur",
                uzb: "uz",
                ven: "ve",
                vie: "vi",
                wln: "wa",
                yid: "yi",
                zha: "za",
                zho: "zh"
            },
            pm = {
                isLanguageCode: e => e in hm,
                shortenLanguageCode(e) {
                    let t;
                    var i, r;
                    return e && (r = 0 <= (i = e.indexOf("-")) ? e.slice(0, i) : e, pm.isLanguageCode(r) && (t = hm[r]), t = t || r, 0 < i && (t += "-" + e.slice(i + 1))), t
                }
            },
            fm = {
                getRichestVideoCodec(e) {
                    if (e && e.length) {
                        e = e.sort((e, t) => qp(t) - qp(e));
                        return e && e.length ? e[0] : void 0
                    }
                },
                getRichestAudioCodec(e) {
                    if (e && e.length) {
                        e = e.sort((e, t) => jp(t) - jp(e));
                        return e && e.length ? e[0] : void 0
                    }
                },
                getRichestChannelLayoutForGroupId(t, i) {
                    if (t && i && i.length) {
                        let e;
                        const r = i.filter(e => e.groupId === t);
                        if (r && r.length) {
                            const t = r.sort((e, t) => be.getChannelCount(t.channels) - be.getChannelCount(e.channels));
                            t && t.length && (e = t[0].channels)
                        }
                        return e
                    }
                }
            };

        function mm(e) {
            return new R(L, "steeringManifestParsingError", !1, e, $.FormatError)
        }
        class gm {
            constructor(e) {
                this._url = null, this._programDateTime = null, this._byteRange = null, this.relurl = null, this.baseurl = null, this.isInitSegment = !1, this.mediaSeqNum = NaN, this.cc = NaN, this.iframe = !1, this.bitrate = NaN, this.start = NaN, this.duration = NaN, this.lastByteRangeEndOffset = NaN, this.inheritQuery = e, this.tagList = new Array, this.iframe = !1
            }
            getMediaFragment(e, t, i) {
                const r = {
                    mediaOptionType: i,
                    absoluteUrl: this.url,
                    start: this.start,
                    duration: this.duration,
                    mediaSeqNum: this.mediaSeqNum,
                    discoSeqNum: this.cc,
                    mediaOptionId: t,
                    itemId: e,
                    isLastFragment: !1,
                    isInitSegment: this.isInitSegment
                };
                return null !== (e = this.byteRange) && void 0 !== e && e.length && (r.byteRangeOffset = {
                    start: this.byteRangeStartOffset,
                    end: this.byteRangeEndOffset
                }), this.iframe && (r.iframe = this.iframe), this.levelkey && (r.keyTagInfo = this.levelkey), this.programDateTime && (r.programDateTime = this.programDateTime), r
            }
            get url() {
                return !this._url && this.relurl && this.baseurl && (this._url = bu.buildAbsoluteURL(this.baseurl, this.relurl, {
                    alwaysNormalize: !0,
                    inheritQuery: this.inheritQuery
                })), this._url
            }
            set url(e) {
                this._url = e
            }
            get programDateTime() {
                return !this._programDateTime && this.rawProgramDateTime && (this._programDateTime = new Date(Date.parse(this.rawProgramDateTime))), this._programDateTime
            }
            get byteRange() {
                if (!this._byteRange) {
                    const i = new Array(2);
                    var e, t;
                    this.rawByteRange && (1 === (e = this.rawByteRange.split("@", 2)).length ? (t = this["lastByteRangeEndOffset"], i[0] = t || 0) : i[0] = parseInt(e[1]), i[1] = parseInt(e[0]) + i[0]), this._byteRange = i
                }
                return this._byteRange
            }
            get byteRangeStartOffset() {
                return this.byteRange[0]
            }
            get byteRangeEndOffset() {
                return this.byteRange[1]
            }
            get rangeString() {
                return 0 <= this.start && 0 <= this.duration ? `${this.start.toFixed(2)}-${(this.start+this.duration).toFixed(2)}` : "N/A"
            }
            get fragTag() {
                return `sn/cc/levelId: ${this.mediaSeqNum}/${this.cc}`
            }
        }
        const ym = {
                parseMediaCharacteristics: e => e ? e.split(/\s*,\s*/) : new Array,
                addMediaToSelectionArray(e, t, i) {
                    if (void 0 === e) return -1;
                    const r = e.MediaSelectionGroupOptions;
                    let n = r.find(e => e.MediaSelectionOptionsMediaType === t.mediaType && e.MediaSelectionOptionsName === t.name && e.MediaSelectionOptionsExtendedLanguageTag === t.lang);
                    return n || (n = {
                        MediaSelectionOptionsMediaType: t.mediaType,
                        MediaSelectionOptionsExtendedLanguageTag: t.lang,
                        MediaSelectionOptionsIsDefault: t.default,
                        MediaSelectionOptionsName: t.name,
                        MediaSelectionOptionsPersistentID: i,
                        MediaSelectionOptionsTaggedMediaCharacteristics: t.characteristics
                    }, t.mediaType === Su.SUBTITLE && (n.MediaSelectionOptionsDisplaysNonForcedSubtitles = t.forced ? vu.NO : vu.YES), i++, r.push(n)), t.persistentID = n.MediaSelectionOptionsPersistentID, i
                },
                addDefaultClosedCaptionOption(e, t, i, r) {
                    e = {
                        itemId: e,
                        mediaOptionType: gu.Subtitle,
                        id: 0,
                        mediaOptionId: "cc1_" + Zl(),
                        mediaType: Su.CLOSEDCAPTION,
                        inStreamID: "CC1",
                        groupId: "cc",
                        name: "English-CC",
                        type: "CLOSED-CAPTIONS",
                        default: !1,
                        autoselect: !1,
                        forced: !1,
                        lang: "en",
                        characteristics: ["public.accessibility.transcribes-spoken-dialog", "public.accessibility.describes-music-and-sound"],
                        persistentID: r
                    };
                    t.push(e), ym.addMediaToSelectionArray(i, e, r)
                }
            },
            vm = {
                BANDWIDTH: NaN,
                "AVERAGE-BANDWIDTH": NaN
            },
            Sm = {
                "TIME-OFFSET": NaN,
                "FRAME-RATE": NaN,
                SCORE: NaN,
                "PLANNED-DURATION": NaN,
                DURATION: NaN
            },
            bm = /^(\d+)x(\d+)$/,
            Tm = /\s*(.+?)\s*=((?:\".*?\")|.*?)(?:,|$)/g;
        class Em {
            constructor(e) {
                this.validTags = e
            }
            isKey(e) {
                return e in this.validTags
            }
            trySetValue(e, t, i) {
                return !!this.isKey(e) && (i[e] = this.parseFunc(t), !0)
            }
        }
        class Im {
            static parseTags(t) {
                let i;
                var r = {};
                if (!t) return r;
                for (Tm.lastIndex = 0; null !== (i = Tm.exec(t));) {
                    const t = i[1].toUpperCase();
                    let e = i[2];
                    0 === e.indexOf('"') && e.lastIndexOf('"') === e.length - 1 && (e = e.slice(1, -1));
                    for (const i of Im.tagParsers)
                        if (i.trySetValue(t, e, r)) break
                }
                return r
            }
        }
        Im.tagParsers = [new class extends Em {
            parseFunc(e) {
                return e
            }
        }({
            NAME: "",
            TYPE: "",
            DEFAULT: "",
            AUTOSELECT: "",
            FORCED: "",
            LANGUAGE: "",
            URI: "",
            AUDIO: "",
            "VIDEO-RANGE": "",
            "CLOSED-CAPTIONS": "",
            CODECS: "",
            BYTERANGE: "",
            "INSTREAM-ID": "",
            "GROUP-ID": "",
            CHANNELS: "",
            CHARACTERISTICS: "",
            KEYFORMAT: "",
            KEYFORMATVERSIONS: "",
            "DATA-ID": "",
            VALUE: "",
            METHOD: "",
            "HDCP-LEVEL": "",
            "ALLOWED-CPC": "",
            SUBTITLES: "",
            ID: "",
            CLASS: "",
            "START-DATE": "",
            "END-DATE": "",
            "END-ON-NEXT": "",
            "SERVER-URI": "",
            "PATHWAY-ID": ""
        }), new class extends Em {
            parseFunc(e) {
                e = parseInt(e);
                return e > Number.MAX_SAFE_INTEGER ? 1 / 0 : e
            }
        }(vm), new class extends Em {
            constructor() {
                super(...arguments), this.parseFunc = parseFloat
            }
        }(Sm), new class extends Em {
            parseFunc(e) {
                let t = (e || "0x").slice(2);
                t = (1 & t.length ? "0" : "") + t;
                const i = new Uint8Array(t.length / 2);
                for (let e = 0; e < t.length / 2; e++) {
                    var r = parseInt(t.slice(2 * e, 2 * e + 2), 16);
                    if (!ne(r)) return;
                    i[e] = r
                }
                return i
            }
        }({
            IV: null
        }), new class extends Em {
            parseFunc(e) {
                e = bm.exec(e);
                let t;
                return null !== e && (t = {
                    width: parseInt(e[1], 10),
                    height: parseInt(e[2], 10)
                }), t
            }
        }({
            RESOLUTION: null
        })];
        const wm = {
            ExtractVariableParameter: /{\$(.*?)}/g,
            LevelPlaylistFast: /#EXTINF:(\d*(?:\.\d+)?)(?:,(.*))?|(?!#)(\S.+)|#EXT-X-BYTERANGE: *(.+)|#EXT-X-PROGRAM-DATE-TIME:(.+)|#EXT-X-BITRATE:(.+)|#EXT-X-DATERANGE:(.+)|#.*/g,
            LevelPlaylistSlow: /(?:(?:#(EXTM3U))|(?:#EXT-X-(PLAYLIST-TYPE):(.+))|(?:#EXT-X-(MEDIA-SEQUENCE): *(\d+))|(?:#EXT-X-(TARGETDURATION): *(\d+))|(?:#EXT-X-(KEY):(.+))|(?:#EXT-X-(START):(.+))|(?:#EXT-X-(ENDLIST))|(?:#EXT-X-(DISCONTINUITY-SEQ)UENCE:(\d+))|(?:#EXT-X-(DIS)CONTINUITY))|(?:#EXT-X-(VERSION):(\d+))|(?:#EXT-X-(MAP):(.+))|(?:#EXT-X-(I-FRAMES)-ONLY)|(?:#EXT-X-(DEFINE):(.+))|(?:(#)(.*):(.*))|(?:(#)(.*))(?:.*)\r?\n?/,
            MasterPlaylist: /#EXT-X-STREAM-INF:([^\n\r]*)[\r\n]+([^\r\n]+)|#EXT-X-I-FRAME-STREAM-INF:([^\r\n]+)|#EXT-X-DEFINE:([^\n\r]*)|#EXT-X-CONTENT-STEERING:([^\n\r]*)/g,
            MasterPlaylistAlternateMedia: /#EXT-X-MEDIA:(.*)/g,
            SessionData: /#EXT-X-SESSION-DATA[^:]*:(.*)/g,
            SessionKeys: /#EXT-X-SESSION-KEY:([^\n\r]*)/g,
            VARIABLE_PLAYLIST_REGEX: /(NAME|VALUE)=\"(.*)\",(NAME|VALUE)=\"(.*)\"|(IMPORT)=\"(.*)\"/
        };

        function Am(e, t, i) {
            return cu.buildAbsoluteURL(t, e, {
                alwaysNormalize: !0,
                inheritQuery: i
            })
        }
        class Om {
            static isValidPlaylist(e) {
                return 0 === e.indexOf("#EXTM3U")
            }
            static isMediaPlaylist(e) {
                return 0 < e.indexOf("#EXTINF:") || 0 < e.indexOf("#EXT-X-PLAYLIST-TYPE:")
            }
            static replaceVariables(e, t) {
                let i, r = !1;
                return e && t && (i = e.replace(wm.ExtractVariableParameter, e => {
                    wm.ExtractVariableParameter.lastIndex = 0;
                    e = wm.ExtractVariableParameter.exec(e)[1];
                    if (e && t.hasOwnProperty(e)) return t[e];
                    r = !0
                })), {
                    updatedString: i,
                    error: r
                }
            }
            static parseDecryptData(e, t, i) {
                const r = Im.parseTags(e),
                    n = (e = r.METHOD) && e in om ? r.METHOD : null;
                e = null !== (e = r.KEYFORMAT) && void 0 !== e ? e : null;
                if (n && Om.shouldSelectKeyTag(e, n, i)) {
                    const s = r.URI,
                        i = r.IV || null;
                    if (s && r.IV && !i) {
                        const s = new R(L, _, !0, `Invalid IV: ${r.IV}`, $.PlaylistErrorInvalidEntry);
                        throw s.url = t, s
                    }
                    const a = s ? cu.buildAbsoluteURL(t, s, {
                            alwaysNormalize: !0
                        }) : t,
                        o = (r.KEYFORMATVERSIONS || "1").split("/").map(Number).filter(isFinite);
                    return new zc(n, a, i, e, o)
                }
            }
            static shouldSelectKeyTag(e, t, i) {
                return "AES-128" === t || "NONE" === t || null == i || e === am.getKeySystemFormat(i)
            }
            static optOutClosedCaption(t) {
                let i = !1,
                    r = !1;
                if (t)
                    for (let e = 0; e < t.length; ++e) {
                        const n = t[e];
                        if (n.videoCodec && ((r = !0) !== n.iframes && n.closedcaption && "none" === n.closedcaption.toLowerCase())) {
                            i = !0;
                            break
                        }
                    }
                return !r || i
            }
            static parseRootPlaylistAlternateMediaOptions(a, o, l, d, u, c) {
                let h, p;
                var f = {
                        MediaSelectionGroupAllowEmptySelection: 1,
                        MediaSelectionGroupMediaCharacteristics: ["public.audible"],
                        MediaSelectionGroupMediaType: Su.AUDIO,
                        MediaSelectionGroupOptions: []
                    },
                    m = {
                        MediaSelectionGroupAllowEmptySelection: 1,
                        MediaSelectionGroupMediaCharacteristics: ["public.legible"],
                        MediaSelectionGroupMediaType: Su.SUBTITLE,
                        MediaSelectionGroupOptions: []
                    },
                    g = {
                        videoAlternateOptions: [],
                        audioAlternateOptions: [],
                        subtitleAlternateOptions: [],
                        audioMediaSelectionGroup: f,
                        subtitleMediaSelectionGroup: m
                    };
                let y = 0;
                for (wm.MasterPlaylistAlternateMedia.lastIndex = 0; null != (h = wm.MasterPlaylistAlternateMedia.exec(o));) {
                    const o = Om.replaceVariables(h[1], c);
                    if (o.error) {
                        p = new R(L, N, !0, $.PlaylistErrorInvalidEXTXDEFINE.text, $.PlaylistErrorInvalidEXTXDEFINE);
                        break
                    }
                    var v = Im.parseTags(o.updatedString);
                    let e, t, i, r = Su.UNKNOWN;
                    const S = ym.parseMediaCharacteristics(v.CHARACTERISTICS),
                        b = v["GROUP-ID"],
                        T = v.CHANNELS;
                    let n, s = null;
                    switch (v.TYPE) {
                        case "VIDEO":
                            r = Su.VIDEO, t = g.videoAlternateOptions;
                            break;
                        case "AUDIO":
                            r = Su.AUDIO, s = gu.AltAudio, t = g.audioAlternateOptions, i = f;
                            const a = d.find(e => e.audioGroupId === b);
                            n = a ? a.audioCodecList : [];
                            break;
                        case "SUBTITLES":
                            r = Su.SUBTITLE, s = gu.Subtitle, t = g.subtitleAlternateOptions, i = m;
                            break;
                        case "CLOSED-CAPTIONS":
                            r = Su.CLOSEDCAPTION, s = gu.Subtitle, e = v["INSTREAM-ID"], t = g.subtitleAlternateOptions, i = m
                    }
                    const E = {
                        itemId: a,
                        mediaOptionType: s,
                        mediaType: r,
                        groupId: b,
                        channels: T,
                        groupCodecList: n,
                        name: v.NAME,
                        type: v.TYPE,
                        default: "YES" === v.DEFAULT,
                        autoselect: "YES" === v.AUTOSELECT,
                        forced: "YES" === v.FORCED,
                        characteristics: S,
                        persistentID: y,
                        id: t ? t.length : 0,
                        mediaOptionId: `${v.NAME}_${b}_${y}`,
                        lang: pm.shortenLanguageCode(v.LANGUAGE)
                    };
                    v.URI && (E.url = Am(v.URI, l, u)), E.name || (E.name = E.lang, E.mediaType === Su.CLOSEDCAPTION && (E.name += " CC")), E.mediaType === Su.CLOSEDCAPTION && e && (E.inStreamID = e), t && (E.id = t.length, t.push(E)), y = ym.addMediaToSelectionArray(i, E, y)
                }
                return 0 !== g.subtitleAlternateOptions.length || Om.optOutClosedCaption(d) || ym.addDefaultClosedCaptionOption(a, g.subtitleAlternateOptions, m, y), {
                    alternateMediaInfo: g,
                    playlistParsingError: p
                }
            }
            static parseMediaOptionPlaylist(e, t, i = !0, r, n, s, a, o, l, d = 0, u = !1) {
                var c;
                let h = 0,
                    p = 0;
                const f = {
                    itemId: s,
                    mediaOptionId: a,
                    mediaOptionType: o,
                    type: "",
                    version: 0,
                    url: t,
                    initSegments: {},
                    fragments: [],
                    liveOrEvent: !0,
                    startSN: 0,
                    endSN: 0,
                    iframesOnly: u,
                    targetduration: 0,
                    totalduration: 0,
                    averagetargetduration: 0,
                    ptsKnown: !1
                };
                let m, g, y, v = new zc("NONE", t, null, null, null),
                    S = !1,
                    b = !1,
                    T = 0,
                    E = null,
                    I = new gm(i),
                    w = 0;
                const A = {};
                let O, k, C, D = !0,
                    M = !0;
                wm.LevelPlaylistFast.lastIndex = 0;
                for (var x = () => new R(L, _, !0, "Invalid key system preference for the playlist", $.IncompatibleAsset); null !== (m = wm.LevelPlaylistFast.exec(e));) {
                    const e = m[1];
                    if (e) {
                        I.duration = parseFloat(e);
                        const t = (" " + m[2]).slice(1);
                        I.title = t || null, I.tagList.push(t ? ["INF", e, t] : ["INF", e])
                    } else if (m[3]) {
                        if (ne(I.duration)) {
                            const e = h++;
                            if (I.start = p + d, I.levelkey = v, b && !S) {
                                k = x();
                                break
                            }
                            if (S = !1, b = !1, I.mediaSeqNum = e, I.cc = T, I.iframe = f.iframesOnly, I.baseurl = t, (O = Om.replaceVariables((" " + m[3]).slice(1), A)).error) {
                                k = new R(L, N, !0, $.PlaylistErrorInvalidEXTXDEFINE.text, $.PlaylistErrorInvalidEXTXDEFINE);
                                break
                            }
                            if (I.relurl = O.updatedString, I.bitrate = ne(I.byteRangeEndOffset) ? 8 * (I.byteRangeEndOffset - I.byteRangeStartOffset) / I.duration : w, null != y) {
                                I.rawProgramDateTime = y, I.tagList.push(["PROGRAM-DATE-TIME", I.rawProgramDateTime]);
                                const e = I.programDateTime.getTime();
                                f.programDateTimeMap = null !== (c = f.programDateTimeMap) && void 0 !== c ? c : {}, f.programDateTimeMap[e] = I.mediaSeqNum, f.dateMediaTimePairs = null !== (c = f.dateMediaTimePairs) && void 0 !== c ? c : [], f.dateMediaTimePairs.push([e, I.start]), y = void 0
                            }
                            if (f.fragments.push(I.getMediaFragment(s, a, o)), E = I, p += I.duration, D || !f.initSegments[T] || M)
                                if (f.iframesOnly && 0 < I.byteRangeStartOffset && !f.initSegments[T] && !M) {
                                    const e = new gm(i);
                                    if (e.url = I.url, e.rawByteRange = Math.min(I.byteRangeStartOffset, 1316) + "@0", e.baseurl = t, e.isInitSegment = !0, e.cc = T, e.levelkey = v, e.iframe = !0, b && !S) {
                                        k = x();
                                        break
                                    }
                                    S = !1, b = !1, f.initSegments[T] = e.getMediaFragment(s, a, o)
                                } else C && (C.discoSeqNum = T, f.initSegments[T] = C);
                            D = !1, M = !1, I = new gm(i)
                        }
                    } else if (m[4]) {
                        if (I.rawByteRange = (" " + m[4]).slice(1), E) {
                            const e = E.byteRangeEndOffset;
                            e && (I.lastByteRangeEndOffset = e)
                        }
                    } else if (m[5]) y = (" " + m[5]).slice(1);
                    else if (m[6]) {
                        const e = parseInt(m[6]);
                        ne(e) && (w = 1e3 * e)
                    } else if (m[7]) {
                        const e = m[7],
                            t = Im.parseTags(e);
                        t.ID && (f.daterangeTags || (f.daterangeTags = {}), f.daterangeTags[t.ID] = t)
                    } else {
                        for (m = m[0].match(wm.LevelPlaylistSlow), g = 1; g < m.length && void 0 === m[g]; g++);
                        const e = Om.replaceVariables((" " + m[g + 1]).slice(1), A),
                            l = Om.replaceVariables((" " + m[g + 2]).slice(1), A);
                        if (e.error || l.error) {
                            k = new R(L, N, !0, $.PlaylistErrorInvalidEXTXDEFINE.text, $.PlaylistErrorInvalidEXTXDEFINE);
                            break
                        }
                        const d = e.updatedString,
                            u = l.updatedString;
                        switch (m[g]) {
                            case "#":
                                I.tagList.push(u ? [d, u] : [d]);
                                break;
                            case "PLAYLIST-TYPE":
                                f.type = d.toUpperCase(), "VOD" === f.type && (f.liveOrEvent = !1);
                                break;
                            case "MEDIA-SEQUENCE":
                                0 === f.fragments.length && (h = f.startSN = parseInt(d));
                                break;
                            case "TARGETDURATION":
                                f.targetduration = parseFloat(d);
                                break;
                            case "VERSION":
                                f.version = parseInt(d);
                                break;
                            case "EXTM3U":
                                break;
                            case "ENDLIST":
                                f.liveOrEvent = !1;
                                break;
                            case "DIS":
                                T++, I.tagList.push(["DIS"]), D = !0;
                                break;
                            case "DISCONTINUITY-SEQ":
                                T = parseInt(d);
                                break;
                            case "KEY":
                                const e = d;
                                if (b = !0, !S) {
                                    try {
                                        v = Om.parseDecryptData(e, t, r)
                                    } catch (e) {
                                        k = e
                                    }
                                    v && (S = !0)
                                }
                                break;
                            case "START":
                                const l = d,
                                    P = Im.parseTags(l)["TIME-OFFSET"];
                                ne(P) && (f.startTimeOffset = P);
                                break;
                            case "I-FRAMES":
                                f.iframesOnly = !0;
                                break;
                            case "MAP":
                                const c = Im.parseTags(d);
                                if (I.relurl = c.URI, I.rawByteRange = c.BYTERANGE, I.baseurl = t, I.isInitSegment = !0, I.levelkey = v, b && !S) {
                                    k = x();
                                    break
                                }
                                S = !1, b = !1, C = I.getMediaFragment(s, a, o), M = !0, I = new gm(i);
                                break;
                            case "DEFINE":
                                const p = wm.VARIABLE_PLAYLIST_REGEX.exec(d),
                                    m = "NAME" === p[1] ? p[2] : p[4],
                                    g = "VALUE" === p[1] ? p[2] : p[4],
                                    y = p[5],
                                    N = p[6];
                                if (m || g || "IMPORT" !== y || !n.hasOwnProperty(N)) {
                                    if (!m || y || p[1] === p[3] || A.hasOwnProperty(m)) {
                                        k = new R(L, _, !0, $.PlaylistErrorMissingImportReference.text, $.PlaylistErrorMissingImportReference);
                                        break
                                    }
                                    A[m] = g
                                } else A[N] = n[N]
                        }
                    }
                }
                return I = E, I && !I.relurl && (f.fragments.pop(), p -= I.duration), !f.liveOrEvent && 0 < f.fragments.length && (f.fragments[f.fragments.length - 1].isLastFragment = !0), f.totalduration = p, f.averagetargetduration = p / f.fragments.length, f.endSN = h - 1, {
                    mediaOptionDetails: f,
                    playlistParsingError: k
                }
            }
            static parseRootPlaylist(t, e, i, r) {
                const n = [],
                    s = {};
                let a, o, l, d, u = null,
                    c = !0;
                for (wm.MasterPlaylist.lastIndex = 0; null != (a = wm.MasterPlaylist.exec(e));)
                    if (a[4]) {
                        a = wm.VARIABLE_PLAYLIST_REGEX.exec(a[4]);
                        const t = "NAME" === a[1] ? a[2] : a[4],
                            e = "VALUE" === a[1] ? a[2] : a[4],
                            i = a[5];
                        if (!t || s.hasOwnProperty(t) || i || a[1] === a[3]) {
                            d = new R(L, _, !0, $.PlaylistErrorInvalidEXTXDEFINE.text, $.PlaylistErrorInvalidEXTXDEFINE);
                            break
                        }
                        s[t] = e
                    } else if (a[5]) {
                    const t = Om.replaceVariables(a[5], s);
                    if (t.error) {
                        d = new R(L, _, !0, $.PlaylistErrorInvalidEXTXDEFINE.text, $.PlaylistErrorInvalidEXTXDEFINE);
                        break
                    }
                    const e = Im.parseTags(t.updatedString);
                    if ("string" != typeof e["SERVER-URI"]) {
                        d = new R(L, _, !0, $.PlaylistErrorInvalidSERVERURI.text, $.PlaylistErrorInvalidSERVERURI);
                        break
                    }
                    if (null != e["PATHWAY-ID"] && "string" != typeof e["PATHWAY-ID"]) {
                        d = new R(L, _, !0, $.PlaylistErrorInvalidPATHWAYID.text, $.PlaylistErrorInvalidPATHWAYID);
                        break
                    }
                    u = {
                        serverURI: Am(e["SERVER-URI"], i, !1),
                        initPathwayID: e["PATHWAY-ID"] || "."
                    }
                } else {
                    l = Om.replaceVariables(a[1] || a[3], s);
                    const e = Im.parseTags(l.updatedString);
                    if (o = Om.replaceVariables(a[2] || e.URI, s), l.error || o.error) {
                        d = new R(L, _, !0, $.PlaylistErrorInvalidEXTXDEFINE.text, $.PlaylistErrorInvalidEXTXDEFINE);
                        break
                    }
                    if (void 0 !== e.SCORE && !ne(e.SCORE) || e.SCORE < 0) {
                        d = new R(L, _, !0, $.PlaylistErrorInvalidSCORE.text, $.PlaylistErrorInvalidSCORE), c = !1;
                        break
                    }
                    c && void 0 === e.SCORE && (c = !1);
                    const u = e.BANDWIDTH,
                        p = e["AVERAGE-BANDWIDTH"],
                        f = p || u,
                        m = null !== (h = e["VIDEO-RANGE"]) && void 0 !== h ? h : "SDR";
                    if (null == (h = m) || !cm.includes(h)) continue;
                    const g = {
                            itemId: t,
                            mediaOptionId: `level_${(f||0)+n.length%1e3/1e3}`,
                            mediaOptionType: gu.Variant,
                            attrs: e,
                            url: Am(o.updatedString, i, r),
                            name: e.NAME,
                            audioGroupId: e.AUDIO,
                            subtitleGroupId: e.SUBTITLES,
                            iframes: !!a[3],
                            bandwidth: u,
                            avgBandwidth: p,
                            bitrate: f,
                            videoRange: m,
                            frameRate: e["FRAME-RATE"],
                            allowedCPCMap: Om.parseAllowedCPC(e["ALLOWED-CPC"]),
                            closedcaption: e["CLOSED-CAPTIONS"],
                            levelCodec: e.CODECS,
                            score: e.SCORE,
                            pathwayID: e["PATHWAY-ID"] || "."
                        },
                        y = e["HDCP-LEVEL"];
                    dm(y) && (g.hdcpLevel = y);
                    var h = e.RESOLUTION;
                    if (h && (g.width = h.width, g.height = h.height), e.CODECS) {
                        g.videoCodecList = new Array, g.audioCodecList = new Array;
                        const t = e.CODECS.split(/[ ,]+/),
                            i = t["length"];
                        for (let e = 0; e < i; e++) {
                            const i = t[e];
                            switch (i.slice(0, 4)) {
                                case "avc1":
                                    g.videoCodec = be.avc1toavcoti(i), g.videoCodecList.push(g.videoCodec);
                                    break;
                                case "avc3":
                                case "dvav":
                                case "dva1":
                                case "hev1":
                                case "hvc1":
                                case "dvh1":
                                case "dvhe":
                                case "vp09":
                                    g.videoCodec = i, g.videoCodecList.push(g.videoCodec);
                                    break;
                                default:
                                    g.audioCodec = i, g.audioCodecList.push(g.audioCodec)
                            }
                        }
                        1 < g.audioCodecList.length && (g.audioCodec = fm.getRichestAudioCodec(g.audioCodecList)), 1 < g.videoCodecList.length && (g.videoCodec = fm.getRichestVideoCodec(g.videoCodecList))
                    }
                    if (null != (d = "string" != typeof(h = g.pathwayID) ? mm("invalid steering manifest PATHWAY-PRIORITY list item data type") : /^[\w\-\.]+$/.test(h) ? void 0 : mm("steering manifest contains invalid pathway ID: " + h))) break;
                    let cpc = g.allowedCPCMap ? JSON.stringify(g.allowedCPCMap) : "null";
                    if (!cpc.includes("WIDEVINE_HARDWARE") && !g.url.includes('trickPlay') && !g.videoCodec.includes("hvc1"))
                    n.push(g)
                }
                try{
                    // console.log(n,  window.screen.width)
                    let ok = (n.map(  function(item){return{height : item.height, content: item}}));
                    let screenHeight = (app.cfg.visual.videoRes ?? window.screen.height) ;
                    ok.sort(function (a, b) {
                        return a.height - b.height;
                      });
                    for (var i = 0; i < ok.length; i++){
                        if (ok[i].height > screenHeight){
                            if (i == 0){n.splice(0,n.length);n.push(ok[i].content)} 
                            else{n.splice(0,n.length);n.push(ok[i-1].content)}
                            console.log('selected' , n[0].height)
                            break; 
                            
                        }
                            
                    }
                    if (n.length > 1){
                        n.splice(0,n.length - 1);                      
                    }
                    // console.log(n)
                    // console.log(ok)
                    } catch (e){ console.log(e)}
                return {
                    variantMediaOptions: n,
                    contentSteeringOption: u,
                    masterVariableList: s,
                    playlistParsingError: d,
                    scoreAvailable: c
                }
            }
            static parseAllowedCPC(e) {
                if ("string" != typeof e) return null;
                const n = {};
                return e.split(",").forEach(e => {
                    const t = e.split(":");
                    let i, r;
                    if (2 === t.length) i = t[0].trim(), r = t[1].trim();
                    else {
                        if (!(2 < t.length)) return;
                        r = t[t.length - 1].trim(), t.pop(), i = t.join(":")
                    }
                    if (!(i in n)) {
                        let e = new Array;
                        "" !== r && (e = r.split("/").map(e => e.trim())), n[i] = e
                    }
                }), n
            }
            static parseSessionKeys(e, t, i) {
                var r;
                const n = [];
                for (wm.SessionData.lastIndex = 0; r = wm.SessionKeys.exec(e);) try {
                    const e = Om.parseDecryptData(r[1], t, i);
                    e && e.isEncrypted && n.push(e)
                } catch (e) {}
                return n
            }
            static parseSessionData(e, t) {
                var i;
                const r = [],
                    n = new Set;
                for (wm.SessionData.lastIndex = 0; null != (i = wm.SessionData.exec(e));) {
                    const e = Im.parseTags(i[1]);
                    e.LANGUAGE = pm.shortenLanguageCode(e.LANGUAGE);
                    const t = e.LANGUAGE ? e["DATA-ID"] + "|" + e.LANGUAGE : void 0;
                    "DATA-ID" in e ? t && n.has(t) || ("com.apple.hls.other-tags" === e["DATA-ID"] && (e.VALUE = function(t) {
                        let i;
                        try {
                            i = JSON.parse(qc.base64DecodeToStr(t))
                        } catch (e) {
                            i = t
                        }
                        return i
                    }(e.VALUE)), r.push(e), t && n.add(t)) : Qe().error(`Error processing DATA-ID ${e["DATA-ID"]} and LANGUAGE ${e.LANGUAGE}`)
                }
                return {
                    itemList: r,
                    baseUrl: t
                }
            }
        }
        var km, Cm, Dm, Mm, xm, Pm, Rm = Om;
        const Lm = (e, t, i) => {
                i = Object.assign(Object.assign({}, e), {
                    method: "GET",
                    responseType: "text",
                    extendMaxTTFB: i
                });
                return Tu(i.url) ? Pc().load(i, t).pipe(hr(e => ({
                    responseText: e.data.response.data.toString(),
                    responseURL: e.data.response.uri,
                    stats: e.stats
                }))) : Cc(i, t).pipe(hr(([e, t]) => ({
                    responseText: e.responseText,
                    responseURL: e.responseURL,
                    stats: t
                })))
            },
            _m = (e, n, t, i, s, a, o, l, r) => {
                const {
                    url: d,
                    itemId: u,
                    mediaOptionId: c,
                    mediaOptionType: h,
                    iframes: p = !1
                } = e, f = Lc(e, i);
                return Lm({
                    url: d,
                    xhrSetup: t.xhrSetup
                }, f, r).pipe(hr(({
                    responseText: e,
                    responseURL: t,
                    stats: i
                }) => {
                    t || (s.warn("Missing response url. Reusing request url as base url"), t = d);
                    var r = performance.now(),
                        e = Om.parseMediaOptionPlaylist(e, t, !0, a, l, u, c, h, s, n, p);
                    Nc(e.mediaOptionDetails);
                    var t = performance.now(),
                        e = e["mediaOptionDetails"],
                        r = {
                            playlistLoadTimeMs: i.tload - i.trequest,
                            playlistParseTimeMs: t - r
                        };
                    return o.setPlaylistSample(r), {
                        mediaOptionDetails: e,
                        stats: i
                    }
                }), (m = h, g = c, y = d, e => e.pipe(Vn(e => {
                    if (e instanceof pc) throw new uc(!1, "Timeout", 0, $.PlaylistTimeoutError, !0, m, g, y);
                    if (e instanceof oc) throw new uc(!1, e.message, e.code, {
                        code: e.code,
                        text: "Playlist Network Error"
                    }, !1, m, g, y);
                    throw e
                }))));
                var m, g, y
            },
            Nm = (f, e, m, t, g) => $i(e).pipe(La(e => {
                const {
                    keyTagInfo: t,
                    isInitSegment: i,
                    iframe: r,
                    byteRangeOffset: n
                } = f, s = t["method"], {
                    start: a,
                    end: o
                } = n;
                if ("AES-128" !== s) return $i(e); {
                    !t.uri || t.iv || t.format && "identity" !== t.format || (t.iv = function(t) {
                        const i = new Uint8Array(16);
                        for (let e = 12; e < 16; e++) i[e] = t >> 8 * (15 - e) & 255;
                        return i
                    }(f.mediaSeqNum));
                    const n = e,
                        s = t.key.buffer,
                        l = t.iv.buffer,
                        d = o && (r || i) ? o - a : void 0,
                        u = !m.enableWebCrypto || !!d,
                        c = s.slice(0),
                        h = l.slice(0),
                        p = {
                            useJSCrypto: u,
                            plainTextLength: d
                        };
                    return g.decrypt(c, h, "AES-CBC", n, p)
                }
            }));

        function Fm(e, t) {
            var i = e.fragments,
                r = t.mediaSeqNum - e.startSN;
            return 0 <= r && r < e.fragments.length && $p(t, i[r])
        }

        function Bm(t, r, n, s, a = !1, o = !1) {
            if (Fm(t, r)) {
                var l = r.mediaSeqNum - t.startSN;
                let i = t.fragments,
                    e = i[l];
                var {
                    startDtsTs: d,
                    startPts: u,
                    endPts: r
                } = r;
                a && (i = t.fragments = t.fragments.slice(), e = i[l] = Object.assign({}, e)), e.startDtsTs = d, e.startPts = u, e.endPts = r, !s && void 0 === e.isIframeStart || (e.isIframeStart = s), e.start = n, e.duration = b(r, u);
                for (let e = l, t = !0; 0 < e && (o || t); e--) t = Um(i, e, e - 1, s, u.timescale, a);
                for (let e = l, t = !0; e < i.length - 1 && (o || t); e++) t = Um(i, e, e + 1, s, u.timescale, a);
                l = i[i.length - 1];
                t.totalduration = l.start + l.duration - i[0].start, t.ptsKnown = !0
            }
        }

        function Um(e, t, i, r, n, s = !1) {
            var a = e[t];
            let o = e[i];
            var l = null != r && null != o.isIframeStart && o.isIframeStart !== r && o.discoSeqNum === a.discoSeqNum;
            let d = o.start;
            !l && null != o.startPts || (d = t < i ? a.start + a.duration : Math.max(a.start - o.duration, 0));
            n = ne(n) ? 1 / n : Number.EPSILON, n = Math.abs(o.start - d) > n;
            return !(!l && !n || (s && (o = e[i] = Object.assign({}, o)), n && (o.start = d), l && (o.isIframeStart = r), 0))
        }

        function $m(e) {
            if (e.programDateTimeMap) {
                e.dateMediaTimePairs = [];
                for (var [t, i] of Object.entries(e.programDateTimeMap)) {
                    t = Number(t), i = e.fragments[i - e.startSN];
                    i && (i = i.start, e.dateMediaTimePairs.push([t, i]))
                }
                e.dateMediaTimePairs.sort((e, t) => e[0] - t[0])
            }
        }
        class Vm {
            constructor(e) {
                this.option = e
            }
            get name() {
                return this.option.name
            }
            get priority() {
                return this.option.priority
            }
            get expiry() {
                return this.option.expiry
            }
            filter(i, e) {
                const r = this.option.initFn && this.option.initFn(i, e) || (e ? Object.assign({}, e) : {});
                let t = i;
                return this.option.firstPassFn && i.forEach((e, t) => this.option.firstPassFn(e, t, r, i)), this.option.filterFn && (t = i.filter((e, t) => this.option.filterFn(e, t, r, i))), null != this.option.filterFn && 0 !== t.length || !this.option.minSortingFn || (t = i.sort((e, t) => this.option.minSortingFn(e, t, r, i))), this.option.finalFn && this.option.finalFn(t, r, i), t
            }
        }

        function Km(e, t, i) {
            return (t || []).reduce((e, t) => t.filter(e, i), Array.from(e))
        }

        function qm(t, e) {
            return e.filter(e => {
                return Au(t, null !== (e = e.url) && void 0 !== e ? e : null)
            })
        }

        function Hm() {
            return [new Vm({
                name: "Remove Filter",
                priority: 0,
                filterFn: (t, e, i) => !i || i.removed.every(e => t.mediaOptionId !== e)
            }), new Vm({
                name: "Penalty Box Filter",
                priority: 1,
                filterFn: (t, e, i) => {
                    const r = performance.now();
                    return !i || i.penaltyBoxQueue.every(e => e.expiry <= r || t.mediaOptionId !== e.mediaOptionId)
                }
            }), new Vm({
                name: "Compatible IDs Filter",
                priority: 1,
                filterFn: (t, e, i) => !i || null == i.compatibleIds || i.compatibleIds.some(e => e === t.mediaOptionId)
            })]
        }
        class jm extends kl {
            constructor(e, t, i) {
                super(e), this.itemId = t, this.mediaOptionType = i, this.allowFilters = this._initFilters()
            }
            get mediaOptionList() {
                var e;
                return (null === (e = this.mediaOptionListInfo) || void 0 === e ? void 0 : e.mediaOptions) || null
            }
            get mediaOptionList$() {
                return this.mediaOptionListInfo$.pipe(hr(({
                    mediaOptions: e
                }) => e))
            }
            mediaOptionFromId(t) {
                var e;
                return null !== (e = (null !== (e = this.mediaOptionList) && void 0 !== e ? e : []).find(e => e.mediaOptionId === t)) && void 0 !== e ? e : null
            }
            _getFilteredList(e) {
                return Km(e.mediaOptions, this.allowFilters, e)
            }
            get filteredMediaOptionList() {
                return this.mediaOptionListInfo ? this._getFilteredList(this.mediaOptionListInfo) : null
            }
            get filteredMediaOptionList$() {
                return this.mediaOptionListInfo$.pipe(La(e => {
                    const t = [Wu],
                        i = performance.now();
                    for (const r of e.penaltyBoxQueue) ne(r.expiry) && r.expiry > i && t.push(bn(r.expiry - i));
                    return an(...t).pipe(hr(() => this._getFilteredList(e)))
                }), vl())
            }
            get preferredMediaOptionList() {
                return this.filteredMediaOptionList ? qm(this.preferredHost, this.filteredMediaOptionList) : []
            }
            get preferredMediaOptionList$() {
                return ed([this.preferredHost$, this.filteredMediaOptionList$]).pipe(hr(([e, t]) => qm(e, t)))
            }
            getNewHost(e) {
                e = this.getFallbackVariant(e, !1, !0);
                return null != e && e.url ? Eu(e.url) : this.preferredHost
            }
        }

        function Qm(e) {
            return "PQ" === e.videoRange || "HLG" === e.videoRange
        }

        function Wm(e, t) {
            return t.iframes === e
        }

        function Gm(e, t, i, r) {
            return !r || i.bitrate > r.bitrate && i.bitrate <= e.bitrate ? km.Better : i.bitrate === r.bitrate ? km.Same : km.Worse
        }

        function zm(e, t) {
            return e && !t ? -1 : !e && t ? 1 : 0
        }(dl = km = km || {})[dl.Better = 1] = "Better", dl[dl.Same = 0] = "Same", dl[dl.Worse = -1] = "Worse";
        class Xm extends jm {
            constructor(e, t) {
                super(e, t, gu.Variant)
            }
            static makeFilters() {
                return [...Hm().concat([new Vm({
                    name: "HDR Filter",
                    priority: 1,
                    filterFn: (e, t, i) => !i || (i.hasHdrLevels && i.preferHDR) === Qm(e)
                }), new Vm({
                    name: "Viewport Filter",
                    priority: 1,
                    firstPassFn: (e, t, i) => {
                        if (i && e && !e.iframes && e.videoCodec) {
                            const t = !i.lowestBitrate || e.bitrate < i.lowestBitrate ? e.bitrate : i.lowestBitrate;
                            i.lowestBitrate = t
                        }
                    },
                    filterFn: (e, t, i) => !(e && i && i.viewportInfo && e.videoCodec && i.lowestBitrate) || function(e, t) {
                        return e.width < 1.35 * t.width && e.height < 1.35 * t.height && e.width * e.height < t.width * t.height * 1.35
                    }({
                        width: e.width,
                        height: e.height
                    }, i.viewportInfo) || e.bitrate === i.lowestBitrate
                }), new Vm({
                    name: "HDCP Filter",
                    priority: 2,
                    filterFn: (e, t, i) => !i || !dm(i.maxHdcpLevel) || um(e.hdcpLevel) < um(i.maxHdcpLevel)
                })])].sort((e, t) => {
                    return (null !== (e = e.priority) && void 0 !== e ? e : Number.MAX_SAFE_INTEGER) - (null !== (t = t.priority) && void 0 !== t ? t : Number.MAX_SAFE_INTEGER)
                })
            }
            _initFilters() {
                return Xm.kAllowFilters
            }
            get preferredHost() {
                var e;
                return null !== (e = null === (e = this.mediaOptionListInfo) || void 0 === e ? void 0 : e.preferredHost) && void 0 !== e ? e : null
            }
            get preferredHost$() {
                return this.selectEntity(this.itemId, e => {
                    return null !== (e = null == e ? void 0 : e.mediaOptionListTuple[gu.Variant].preferredHost) && void 0 !== e ? e : null
                })
            }
            get mediaOptionListInfo() {
                var e;
                return null !== (e = null === (e = this.getEntity(this.itemId)) || void 0 === e ? void 0 : e.mediaOptionListTuple[gu.Variant]) && void 0 !== e ? e : null
            }
            get mediaOptionListInfo$() {
                return this.selectEntity(this.itemId, e => {
                    return null === (e = null == e ? void 0 : e.mediaOptionListTuple) || void 0 === e ? void 0 : e[gu.Variant]
                }).pipe(Kp())
            }
            get hdrMode$() {
                return this.mediaOptionListInfo$.pipe(hr(e => !0 === e.preferHDR && e.hasHdrLevels), Is())
            }
            get maxHdcpLevel$() {
                return this.selectEntity(this.itemId, e => {
                    e = null === (e = null == e ? void 0 : e.mediaOptionListTuple) || void 0 === e ? void 0 : e[gu.Variant];
                    return null == e ? void 0 : e.maxHdcpLevel
                }).pipe(Is())
            }
            listFallbackVariants(t, e, i, r, n) {
                var s = this.mediaOptionListInfo,
                    a = null === (o = this.mediaOptionList) || void 0 === o ? void 0 : o.find(e => e.mediaOptionId === t);
                if (!a || !s) return null;
                var o = this.makeFilteredListFromVariant(a, e, n);
                if (!o) return null;
                e = Eu(a.url), s = s.hasScore;
                return Xm._listFallbackVariants(o, a, e, s, i, r, n)
            }
            getFallbackVariant(t, e, i, r) {
                var n = this.mediaOptionListInfo,
                    s = null === (s = this.mediaOptionList) || void 0 === s ? void 0 : s.find(e => e.mediaOptionId === t);
                if (!s || !n) return null;
                e = this.makeFilteredListFromVariant(s, e, r);
                if (!e) return null;
                r = Eu(s.url), n = n.hasScore;
                return Xm._getFallbackVariant(e, s, r, n, i)
            }
            makeFilteredListFromVariant(e, t, i) {
                let r = this.mediaOptionListInfo;
                if (!e || !this.mediaOptionList || !r) return null;
                r = Object.assign(Object.assign({}, r), {
                    includeAllEligiblePathways: !0
                });
                e = Array.from(this.mediaOptionList);
                let n = t ? Km(e, this.allowFilters, Object.assign(Object.assign({}, r), {
                    preferHDR: !1,
                    compatibleIds: null
                })) : this._getFilteredList(r);
                return n ? (i && 0 < i.length && (n = n.filter(e => !i.includes(e.mediaOptionId))), n) : null
            }
            get hasIframes() {
                var e;
                return null !== (e = null === (e = this.mediaOptionListInfo) || void 0 === e ? void 0 : e.hasIframeLevels) && void 0 !== e && e
            }
            canSwitchToSDR(e, t, i = !1) {
                var r = this.mediaOptionListInfo;
                if (!this.mediaOptionList || !r) return !1;
                var n = this.mediaOptionFromId(e);
                if (!n) return !1;
                if (!Qm(n)) return !1;
                var s = Eu(n.url),
                    e = Km(Array.from(this.mediaOptionList), this.allowFilters, Object.assign(Object.assign({}, r), {
                        preferHDR: !1,
                        compatibleIds: null
                    })),
                    r = r.hasScore;
                return null != Xm._getFallbackVariant(e, n, s, r, t, i)
            }
            static _listFallbackVariants(e, r, n, t, s, a = !1, i = null) {
                let o = !1;
                const l = function(e, s, a) {
                    const t = [...e],
                        o = Eu(s.url),
                        l = s.audioGroupId;
                    return t.sort((e, t) => {
                        let i = 0;
                        var r = a && ne(e.score) && ne(t.score),
                            n = r ? e.score > t.score && e.score <= s.score : e.bitrate > t.bitrate && e.bitrate <= s.bitrate,
                            r = r ? e.score === t.score : e.bitrate === t.bitrate;
                        return n ? i = -1 : r ? (i = zm(Au(o, e.url), Au(o, t.url)), 0 === i && (i = zm(!l || e.audioGroupId === l, !l || t.audioGroupId === l))) : i = 1, i
                    }), t
                }(e.filter(e => {
                    var t = !(e.iframes !== r.iframes || s && Au(n, e.url)),
                        i = a ? e.bitrate < r.bitrate : e.bitrate <= r.bitrate,
                        i = t && i;
                    return r.mediaOptionId === e.mediaOptionId ? (o = i, !1) : i
                }), r, t);
                return !o || i && i.includes(r.mediaOptionId) || l.unshift(r), l
            }
            static _getFallbackVariant(e, t, i, r, n, s = !1) {
                let a = null;
                e = (e = s ? e.filter(e => e.bitrate < t.bitrate) : e).filter(e => e.mediaOptionId !== t.mediaOptionId && e.iframes === t.iframes);
                if (n && null != i)
                    for (const o of e) Gm(t, 0, o, a) !== km.Better || Au(i, o.url) || (a = o);
                else
                    for (const o of e) {
                        const r = Gm(t, 0, o, a);
                        r !== km.Better && (r !== km.Same || !Au(i, o.url) || Au(i, a.url) && o.audioGroupId !== t.audioGroupId) || (a = o)
                    }
                return a
            }
            getMatchingVariant(e, t) {
                var i = this.mediaOptionFromId(e),
                    r = Eu(null == i ? void 0 : i.url),
                    n = t.mediaOptionType === gu.AltAudio ? "audioGroupId" : "subtitleGroupId";
                let s = null;
                this.mediaOptionListInfo.hasScore;
                for (const e of this.filteredMediaOptionList)
                    if (e[n] === t.groupId) {
                        if (!i) {
                            s = e;
                            break
                        }
                        var a = Gm(i, 0, e, s);
                        a !== km.Better && (a !== km.Same || s.mediaOptionId === i.mediaOptionId || e.mediaOptionId !== i.mediaOptionId && !Au(r, e.url)) || (s = e)
                    } return s
            }
            get currentPathwayID() {
                var e;
                return null === (e = this.mediaOptionListInfo) || void 0 === e ? void 0 : e.currentPathwayID
            }
        }

        function Ym(e, t) {
            switch (e) {
                case Cm.SendAlternateToPenaltyBox:
                    e = Cm.RetryRequest, 401 !== t && 403 !== t && 407 !== t && t !== $.CorruptStream.code && t !== $.LivePlaylistUpdateError.code || (e = Cm.SendEndCallback);
                    break;
                case Cm.RemoveAlternatePermanently:
                    e = Cm.SendEndCallback
            }
            return e
        }

        function Jm(e, t, i, r, n, s, a, o = !1) {
            const l = s.mediaOptionListQueries[n],
                d = 0 != (e.errorActionFlags & Dm.MoveAllAlternatesMatchingHost),
                u = s.mediaOptionListQueries[n].mediaOptionFromId(r),
                c = a.getFallbackMediaOptionTupleFromMediaOptionId(s, n, r, u.backingMediaOptionId, !1, d, o);
            let {
                errorAction: h,
                errorActionFlags: p
            } = e;
            return s.isValidMediaOptionTuple(c) ? Au(l.preferredHost, c[n].url) && (p &= ~Dm.MoveAllAlternatesMatchingHost) : (t || (h = Ym(h, i), p = 0), l instanceof Xm && (!0 === l.mediaOptionFromId(r).iframes ? (h = Cm.DoNothing, p = 0) : !t && a.canSwitchToSDR(s, r, d, o) && (h = e.errorAction, p = Dm.SwitchToSDR))), {
                errorAction: h,
                errorActionFlags: p
            }
        }

        function Zm(e) {
            let t, i = 0;
            switch (e) {
                case 0:
                    t = Cm.SendAlternateToPenaltyBox, i = Dm.MoveAllAlternatesMatchingHost;
                    break;
                case 410:
                    t = Cm.RemoveAlternatePermanently;
                    break;
                case 500:
                case 502:
                case 503:
                case 504:
                case 404:
                case 409:
                case 401:
                case 403:
                case 407:
                case $.LivePlaylistUpdateError.code:
                case $.PlaylistNotReceived.code:
                default:
                    t = Cm.SendAlternateToPenaltyBox, i = 0
            }
            return {
                errorAction: t,
                errorActionFlags: i
            }
        }

        function eg(i, r, n, s, a, o, l) {
            var {
                errorAction: d,
                errorActionFlags: u
            } = i;
            let e = !0;
            switch (d) {
                case Cm.RemoveAlternatePermanently:
                case Cm.SendAlternateToPenaltyBox: {
                    if (null == a || null == o) return r.handled = !1;
                    const i = n.itemId;
                    let e = o,
                        t = n.mediaOptionListQueries[a].mediaOptionFromId(o);
                    t.backingMediaOptionId && (e = t.backingMediaOptionId, t = n.mediaOptionListQueries[a].mediaOptionFromId(e));
                    var c = 0 != (u & Dm.MoveAllAlternatesMatchingHost),
                        h = 0 != (u & Dm.MoveAllAlternatesMatchingHDCP),
                        p = 0 != (u & Dm.SwitchToSDR),
                        f = d === Cm.RemoveAlternatePermanently;
                    if (h && "hdcpLevel" in t) {
                        const r = t.hdcpLevel;
                        s.setMaxHdcpLevel(i, r)
                    }
                    if (p && s.switchToSDROnly(i), c) {
                        const r = Eu(t.url);
                        s.moveAllWithMatchingHosts(i, a, r, f)
                    } else f ? s.removePermanently(i, a, e) : s.addToPenaltyBox(i, a, e);
                    if (n.enabledMediaOptionIdByType(a) === o) {
                        let e = [Lu, Lu, Lu];
                        e = s.getFallbackMediaOptionTupleFromMediaOptionId(n, a, o, null, !1, c, l), n.isValidMediaOptionTuple(e) ? s.setPreferredHost(i, Eu(e[gu.Variant].url)) : r.fatal = !0, r.fatal && (e = [Lu, Lu, Lu]), s.setNextMediaOptions(n.itemId, e)
                    }
                    break
                }
                case Cm.SendEndCallback:
                    r.fatal = !0;
                    break;
                case Cm.RetryRequest:
                case Cm.DoNothing:
                default:
                    e = !1
            }
            return r.handled = e, e
        }

        function tg(e, t) {
            t instanceof dc || t instanceof uc || t instanceof hc || (t instanceof gc || t instanceof mc) && le(t.keyuri)
        }

        function ig(t, i, r) {
            if (t.handled = !0, r && i < r.maxNumRetry && ne(r.retryDelayMs)) {
                let e;
                return e = "linear" === r.backoff ? (i + 1) * r.retryDelayMs : Math.pow(2, i) * r.retryDelayMs, e = Math.min(r.maxRetryDelayMs, e), tg(0, t), bn(e)
            }
            return t.fatal = !0, tg(0, t), Vi(t)
        }

        function rg(e, t, i, r, n, s, a, o, l = !1) {
            return (null == r ? void 0 : r.errorAction) === Cm.RetryRequest ? ig(e, t, i, s.logger) : ng(e, 0, r, n, s, a, o, l)
        }

        function ng(e, t, i, r, n, s, a, o = !1) {
            const l = new er;
            return al(() => {
                i && (tg(n.logger, e), eg(i, e, r, n, s, a, o)), l.error(e)
            }), l
        }

        function sg(t, i, r, n) {
            return e => e.pipe(Vn(e => {
                if (t.logger.error(`Got demux error ${e.message}`), e instanceof D || e instanceof F) {
                    Cm.SendAlternateToPenaltyBox;
                    return ng(e, 0, {
                        errorAction: e.fatal ? Cm.SendEndCallback : e instanceof F ? Cm.SendAlternateToPenaltyBox : Cm.RemoveAlternatePermanently,
                        errorActionFlags: 0
                    }, i, t, r, n)
                }
                throw e
            }))
        }

        function ag(e, t, i, r, n) {
            e = null !== (e = null === (e = n.getKeyInfo(e)) || void 0 === e ? void 0 : e.mediaOptionIds) && void 0 !== e ? e : [];
            for (const s of e)
                for (const n of i.mediaOptionListQueries) null != n.mediaOptionFromId(s) && r.updateConsecutiveTimeouts(i.itemId, n.mediaOptionType, t, "key")
        }

        function og(r, t, e, n, s, a) {
            const o = n.logger,
                i = s.enabledMediaOptionKeys,
                l = [];
            for (const t of r.mediaOptionIds) {
                const r = i.some(e => e.mediaOptionId === t),
                    e = s.mediaOptionListQueries.find(e => null != e.mediaOptionFromId(t));
                if (e) {
                    const n = e.mediaOptionType,
                        a = {
                            mediaOptionId: t,
                            mediaOptionType: n
                        };
                    r ? l.push(a) : l.unshift(a)
                } else o.warn(`Couldn't find query for ${t}`)
            }
            const d = new er;
            return al(() => {
                const e = r instanceof mc;
                ag(r.keyuri, e, s, n, a);
                let t, i = !1;
                for (const {
                        mediaOptionId: e,
                        mediaOptionType: a
                    } of l) t = function(e, t, i, r, n) {
                    let s = {
                        errorAction: Cm.SendAlternateToPenaltyBox,
                        errorActionFlags: 0
                    };
                    if (e instanceof mc) s.errorAction = Cm.SendAlternateToPenaltyBox;
                    else {
                        const t = e.isOkToRetry;
                        e.keyErrorReason === rc.OutputRestricted ? (s.errorAction = Cm.RemoveAlternatePermanently, s.errorActionFlags |= Dm.MoveAllAlternatesMatchingHDCP) : t ? s = Zm(e.code) : s.errorAction = Cm.RemoveAlternatePermanently
                    }
                    s.errorActionFlags &= ~Dm.MoveAllAlternatesMatchingHost;
                    var a = r.enabledMediaOptionIdByType(i);
                    return t === a ? Jm(s, !1, e.code, a, i, r, n, e.isTimeout) : s
                }(r, e, a, s, n), o.error(`[Keys] handleNetworkError uri=${le(r.keyuri)} mediaOptionId=${e} mediaOptionType=${a} action=${JSON.stringify(t)}`), t.errorAction === Cm.RetryRequest && (i = !0), eg(t, r, s, n, a, e);
                i ? (d.next(), d.complete()) : (tg(0, r), d.error(r))
            }), d.pipe(La(() => ig(r, t, e, n.logger)))
        }

        function lg(t, i, r, n, s, a, o, l) {
            return n = Math.max(0, n), e => e.pipe(Za(() => {
                null != i && o.updateConsecutiveTimeouts(t, i, !1, "load")
            }), va(e => e.pipe(jr((e, t) => function(e, t, i, r, n, s, a, o) {
                var l;
                if (!(e instanceof p)) return Vi(e);
                let d, u, c, h = !1;
                if (e instanceof dc) c = {
                    errorAction: Ym(Zm((l = e).response.code).errorAction, l.response.code),
                    errorActionFlags: 0
                };
                else if (e instanceof uc || e instanceof hc) {
                    ({
                        mediaOptionType: u,
                        mediaOptionId: d,
                        isTimeout: h
                    } = e);
                    const t = null === (l = s.mediaOptionListQueries[u]) || void 0 === l ? void 0 : l.mediaOptionFromId(d);
                    if (!r && e.isTimeout && null != t && (!("iframes" in t) || !0 !== t.iframes) && (a.updateConsecutiveTimeouts(s.itemId, e.mediaOptionType, !0, "load"), e instanceof hc && e.stats)) {
                        const t = performance.now();
                        o.setBandwidthSample(Object.assign(Object.assign({}, e.stats), {
                            tfirst: e.stats.tfirst || t,
                            tload: e.stats.tload || t,
                            complete: !0,
                            mediaOptionType: u
                        }))
                    }
                    c = function(e, t, i, r, n) {
                        var s = e.response.code;
                        let a = Zm(s);
                        var {
                            mediaOptionId: o,
                            mediaOptionType: l
                        } = e;
                        return t ? a.errorActionFlags &= ~Dm.MoveAllAlternatesMatchingHost : a = function(e, t, i, r, n) {
                            let {
                                errorAction: s,
                                errorActionFlags: a
                            } = t;
                            if (e.isTimeout) {
                                const t = e["mediaOptionType"],
                                    o = null !== (n = null === (n = n.getErrorInfoByType(t)) || void 0 === n ? void 0 : n.timeouts.load) && void 0 !== n ? n : 0;
                                !i && r <= o && (s = Cm.DoNothing, a = 0)
                            }
                            return {
                                errorAction: s,
                                errorActionFlags: a
                            }
                        }(e, a, t, i, r), a = Jm(a, t, s, o, l, r, n, e.isTimeout), a
                    }(e, r, n, s, a)
                }
                return rg(e, t, i, c, s, a, u, d, h)
            }(e, t, _c(e, r), s, n, a, o, l)))))
        }
        Xm.kAllowFilters = Xm.makeFilters(), (dl = Cm = Cm || {})[dl.DoNothing = 0] = "DoNothing", dl[dl.SendEndCallback = 1] = "SendEndCallback", dl[dl.SendAlternateToPenaltyBox = 2] = "SendAlternateToPenaltyBox", dl[dl.RemoveAlternatePermanently = 3] = "RemoveAlternatePermanently", dl[dl.InsertDiscontinuity = 4] = "InsertDiscontinuity", dl[dl.RetryRequest = 5] = "RetryRequest", (dl = Dm = Dm || {})[dl.MoveAllAlternatesMatchingHost = 1] = "MoveAllAlternatesMatchingHost", dl[dl.MoveAllAlternatesMatchingHDCP = 2] = "MoveAllAlternatesMatchingHDCP", dl[dl.SwitchToSDR = 4] = "SwitchToSDR";
        class dg extends kl {
            constructor(e) {
                super(e)
            }
            get currentConfig() {
                var e;
                return null === (e = this.getActive()) || void 0 === e ? void 0 : e.config
            }
            get extendMaxTTFB() {
                var e;
                return null === (e = this.getActive()) || void 0 === e ? void 0 : e.extendMaxTTFB
            }
            get config$() {
                return this.selectActive(e => null == e ? void 0 : e.config)
            }
            get userSeek$() {
                return this.selectActive(e => null == e ? void 0 : e.userSeek)
            }
        }
        A();
        class ug extends fl {
            constructor() {
                super({}, {
                    name: "hls-store",
                    producerFn: su
                })
            }
        }
        class cg {
            constructor(e) {
                this.store = e
            }
            getQuery() {
                return new dg(this.store)
            }
            setHlsEntity(e) {
                const t = e.id;
                Do(`hls.set.entity ${t}`), al(() => {
                    this.store.add(de(e)), this.store.setActive(t)
                })
            }
            removeEntity(e) {
                Do(`hls.remove ${e}`), this.store.remove(e)
            }
            setStartTime(t) {
                this.store.updateActive(e => {
                    e.config.startPosition = t
                })
            }
            setUserSeek(t) {
                this.store.updateActive(e => {
                    e.userSeek = t
                })
            }
            setExtendMaxTTFB(t) {
                this.store.updateActive(e => {
                    e.extendMaxTTFB = t
                })
            }
        }
        let hg, pg;

        function fg() {
            return hg = hg || new cg(new ug), hg
        }

        function mg() {
            return fg().getQuery().currentConfig
        }

        function gg(r, n) {
            if ("VOD" !== r.type && "VOD" !== n.type && r.iframesOnly === n.iframesOnly) {
                const s = r.mediaOptionId === n.mediaOptionId,
                    a = Math.max(r.startSN, n.startSN) - n.startSN,
                    o = Math.min(r.endSN, n.endSN) - n.startSN,
                    l = n.startSN - r.startSN,
                    d = r.fragments,
                    u = n.fragments;
                let t = 0;
                for (let e = a; e <= o; ++e)
                    if (d[l + e] && u[e]) {
                        t = d[l + e].discoSeqNum - u[e].discoSeqNum;
                        break
                    } const c = {};
                let i = null;
                for (let e = 0; e < u.length; e++) {
                    const h = d[l + e],
                        a = u[e];
                    if (t) {
                        const r = a.discoSeqNum + t;
                        n.initSegments[a.discoSeqNum] && (n.initSegments[a.discoSeqNum].discoSeqNum = r, c[r] = n.initSegments[a.discoSeqNum], delete n.initSegments[a.discoSeqNum]), a.discoSeqNum = r
                    }
                    s && a.mediaSeqNum === (null == h ? void 0 : h.mediaSeqNum) && null != h.startPts && (a.start = h.start, a.duration = h.duration, a.startDtsTs = h.startDtsTs, a.endDtsTs = h.endDtsTs, a.startPts = h.startPts, a.endPts = h.endPts, i = a)
                }
                if (Object.keys(c).length && (n.initSegments = c), i) Bm(n, i, i.start, void 0, !1, !0);
                else if (0 <= l && l < d.length) {
                    const r = d[l].start,
                        h = n.fragments;
                    for (let e = 0; e < u.length; e++) h[e].start += r
                }
                n.ptsKnown = n.ptsKnown || s && !0 === r.ptsKnown && r.endSN >= n.startSN, $m(n)
            }
        }

        function yg(e, t, i) {
            let r = t.targetduration;
            return ne(i.liveSyncDuration) ? r = i.liveSyncDuration : ne(i.liveSyncDurationCount) && (r = i.liveSyncDurationCount * t.targetduration), e + Math.max(0, t.totalduration - r)
        }

        function vg(e, t, i, r, n) {
            if (!t.ptsKnown) return 0;
            var s = t.targetduration,
                a = t.fragments[0].start,
                r = n.canContinuePlaybackWithoutGap(t, i, {
                    avgPlaylistLoadTimeMs: 0,
                    avgPlaylistParseTimeMs: 0
                }, r);
            let o = Math.max(0, e - s);
            return e < a && !r && (o = a), o
        }

        function Sg(e) {
            return 1e3 * (e.averagetargetduration || e.targetduration)
        }

        function bg(e, t) {
            var i = Sg(e),
                t = performance.now() - t;
            return e.liveOrEvent && i <= t
        }

        function Tg(t, i, r = NaN) {
            var n = t.fragments;
            for (let e = r > t.startSN ? r - t.startSN : 0; e < n.length; ++e) {
                const t = n[e],
                    r = t["start"];
                if (i(t)) return {
                    timelineOffset: r,
                    mediaFragment: t
                }
            }
            return null
        }

        function Eg(e, t, i) {
            var r = 0 < i.duration,
                n = i.start + i.duration,
                n = null == t || t < n || t - n < 1 && i.isLastFragment,
                e = e.every(e => !$p(e.frag, i));
            return r && e && n
        }

        function Ig(e, t, i, r, n) {
            i = null !== (i = Tg(r, Eg.bind(null, n, void 0), i)) && void 0 !== i ? i : null;
            let s = null;
            i && (s = null !== (e = Tg(r, Eg.bind(null, n, e), i.mediaFragment.mediaSeqNum)) && void 0 !== e ? e : null, s || !r.liveOrEvent || r.ptsKnown || (s = i));
            let a = NaN;
            null != s && ne(t) && s.mediaFragment.discoSeqNum !== t && (a = s.mediaFragment.discoSeqNum, s = null);
            t = n.some(e => 0 < e.frag.framesWithoutIDR);
            return s && t && n[n.length - 1].frag.mediaOptionId !== r.mediaOptionId && (s = null !== (r = Tg(r, e => e.mediaSeqNum === s.mediaFragment.mediaSeqNum - 1)) && void 0 !== r ? r : s), {
                foundFrag: s,
                nextDisco: a
            }
        }

        function wg(e) {
            e = e.fragments[e.fragments.length - 1];
            return e ? e.start + e.duration : 0
        }
        class Ag extends kl {
            constructor(e, t) {
                super(e), this.mediaOption = t
            }
            get itemId() {
                return this.mediaOption.itemId
            }
            get mediaOptionId() {
                return this.mediaOption.mediaOptionId
            }
            get initSegmentEntities() {
                var e;
                return null === (e = this.mediaOptionDetailsEntity) || void 0 === e ? void 0 : e.initSegmentCacheEntities
            }
            get mediaLibraryEntity() {
                return this.getEntity(this.itemId)
            }
            get mediaOptionDetailsEntityRecord() {
                var e;
                return null === (e = this.mediaLibraryEntity) || void 0 === e ? void 0 : e.mediaOptionDetailsEntityRecord
            }
            get mediaOptionDetailsEntity() {
                return this.mediaOptionDetailsEntityRecord ? this.mediaOptionDetailsEntityRecord[this.mediaOptionId] : null
            }
            get mediaOptionDetails() {
                var e;
                return null === (e = this.mediaOptionDetailsEntity) || void 0 === e ? void 0 : e.mediaOptionDetails
            }
            get playlistDuration() {
                var e;
                return null === (e = this.mediaOptionDetailsEntity) || void 0 === e ? void 0 : e.playlistDuration
            }
            get mediaOptionDetailsEntity$() {
                const {
                    itemId: e,
                    mediaOptionId: t
                } = this;
                return this.selectEntity(e, e => {
                    if (null != e && e.mediaOptionDetailsEntityRecord) return null == e ? void 0 : e.mediaOptionDetailsEntityRecord[t]
                })
            }
            get mediaOptionDetails$() {
                return this.selectEntity(this.itemId, e => {
                    return null === (e = null == e ? void 0 : e.mediaOptionDetailsEntityRecord[this.mediaOptionId]) || void 0 === e ? void 0 : e.mediaOptionDetails
                }).pipe(Kp())
            }
            get playlistDuration$() {
                return this.mediaOptionDetailsEntity$.pipe(hr(e => null == e ? void 0 : e.playlistDuration), Kp(), Is())
            }
            get live$() {
                return this.mediaOptionDetails$.pipe(hr(e => null == e ? void 0 : e.liveOrEvent), Is())
            }
        }
        class Og extends fl {
            constructor() {
                super({}, {
                    name: "media-library-store",
                    idKey: "itemId",
                    producerFn: su
                })
            }
        }
        class kg {
            constructor(e) {
                this.store = e
            }
            getQuery() {
                return new kl(this.store)
            }
            getQueryForOption(e) {
                return new Ag(this.store, e)
            }
            createMediaLibraryEntity(e) {
                var t = {
                    itemId: e,
                    mediaOptionDetailsEntityRecord: {}
                };
                Do(`library.entity.create: ${e}`), this.store.add(t)
            }
            setDetailsLoading(e) {
                const {
                    itemId: t,
                    mediaOptionId: i
                } = e;
                Do(`library.details.loading: ${i}`), this.store.update(t, ({
                    mediaOptionDetailsEntityRecord: e
                }) => {
                    e[i] || (e[i] = {
                        initSegmentCacheEntities: {},
                        unchangedCount: 0
                    }), e[i].detailsLoading = !0
                })
            }
            archiveMediaOptionDetails(i, r, n) {
                const {
                    itemId: e,
                    mediaOptionId: s
                } = i, a = performance.now(), o = wg(i);
                Do(`library.details.loaded: ${s}`), this.store.update(e, e => {
                    const t = e.mediaOptionDetailsEntityRecord[s];
                    t.detailsLoading = !1, t.mediaOptionDetails = i, t.lastUpdateMillis = a, n ? t.unchangedCount = 0 : ++t.unchangedCount, t.playlistDuration = o, t.stats = r, e.liveOrEvent = i.liveOrEvent
                })
            }
            setInitSegmentLoading(e) {
                const {
                    itemId: t,
                    mediaOptionId: i,
                    discoSeqNum: r
                } = e;
                Do(`library.initsegs.loading: ${i}/${r}`), this.store.update(t, e => {
                    e.mediaOptionDetailsEntityRecord[i].initSegLoading = r
                })
            }
            archiveInitSegmentEntity(i, r) {
                const {
                    itemId: e,
                    mediaOptionId: n,
                    discoSeqNum: s
                } = i;
                Do(`library.initseg.loaded: ${n}/${s}`), this.store.update(e, ({
                    mediaOptionDetailsEntityRecord: e
                }) => {
                    const t = e[n];
                    t.initSegmentCacheEntities[s] = [i, r], t.initSegLoading = null
                })
            }
            updatePTSDTS(e, i, t, r) {
                var n = null === (n = this.getQueryForOption({
                    itemId: e,
                    mediaOptionId: i
                })) || void 0 === n ? void 0 : n.mediaOptionDetails;
                if (n && Fm(n, r)) {
                    const s = r["startDtsTs"],
                        {
                            variantDTS: a,
                            timelineOffset: o,
                            iframeMode: l
                        } = t,
                        d = b(s, a) + o,
                        u = Object.assign({}, n);
                    Bm(u, r, d, l, !0), $m(u);
                    const c = wg(u);
                    this.store.update(e, ({
                        mediaOptionDetailsEntityRecord: e
                    }) => {
                        const t = e[i];
                        null != t && t.mediaOptionDetails && (t.mediaOptionDetails = u, t.playlistDuration = c)
                    })
                }
            }
            remove(e) {
                this.store.remove(e)
            }
            clear() {
                this.store.remove()
            }
        }

        function Cg() {
            return pg = pg || new kg(new Og), pg
        }
        const Dg = e => Cg().getQueryForOption(e),
            Mg = (d, e, t = !1, i = !1) => {
                if (null == e || !_u(e)) return $i(null);
                const r = e["itemId"],
                    n = d["mediaLibraryService"],
                    s = n.getQueryForOption(e);
                s.hasEntity(r) || n.createMediaLibraryEntity(r);
                var a = s.mediaOptionDetailsEntity,
                    o = s.mediaOptionDetails;
                return null == o || i || "VOD" !== o.type && (!o.liveOrEvent || bg(o, a.lastUpdateMillis)) ? (n.setDetailsLoading(e), function(u, e) {
                    var t;
                    const {
                        logger: i,
                        config: c,
                        rootPlaylistQuery: h,
                        rootPlaylistService: p,
                        statsService: r,
                        mediaLibraryService: f,
                        mediaSink: n
                    } = d, m = n.mediaQuery, s = c.playlistLoadPolicy, a = c.keySystemPreference, o = h.masterVariableList, l = null === (t = null === (t = fg()) || void 0 === t ? void 0 : t.getQuery()) || void 0 === t ? void 0 : t.extendMaxTTFB;
                    return _m(u, h.itemStartOffset, c, s, i, a, r, o, l).pipe(hr(e => {
                        const t = f.getQueryForOption(u),
                            i = t.mediaOptionDetails,
                            r = e["mediaOptionDetails"],
                            n = e["stats"];
                        let s = !0;
                        if (r.liveOrEvent) {
                            const d = r["mediaOptionType"];
                            e = r, s = null == i || e.endSN !== i.endSN || e.liveOrEvent !== i.liveOrEvent, i && gg(i, r);
                            const u = h.lastLoadedMediaOptionByType(d),
                                t = u ? null === (l = f.getQueryForOption(u)) || void 0 === l ? void 0 : l.mediaOptionDetails : null;
                            !r.ptsKnown && t && t.mediaOptionId !== (null == i ? void 0 : i.mediaOptionId) && gg(t, r)
                        }
                        r && al(() => {
                            f.archiveMediaOptionDetails(r, n, s), p.setLastLoadedMediaOptionByType(h.itemId, u.mediaOptionType, u)
                        });
                        const a = !s && t.mediaOptionDetailsEntity.unchangedCount >= c.liveMaxUnchangedPlaylistRefresh,
                            o = function(e, t, i, r) {
                                t = vg(r.currentTime, e, t, i, r), i = e.fragments[e.fragments.length - 1], r = (null == i ? void 0 : i.start) + (null == i ? void 0 : i.duration);
                                return {
                                    expired: null != i && e.liveOrEvent && e.ptsKnown && r < t,
                                    windowEnd: r,
                                    minPosition: t
                                }
                            }(r, n.tload, c.maxBufferHole, m);
                        if (a || o.expired) {
                            var l = a ? $.LivePlaylistUpdateError : {
                                text: `Live window too far in the past end:${o.windowEnd.toFixed(3)} minPosition:${o.minPosition}`,
                                code: 0
                            };
                            throw new uc(!1, l.text, l.code, l, !1, u.mediaOptionType, u.mediaOptionId, u.url)
                        }
                        return r
                    }), tc("getMediaOptionDetailsCommon.emit.loaded"), lg(u.itemId, u.mediaOptionType, Lc(u, s), c.maxNumAddLevelToPenaltyBox, e, h, p, r)).pipe(Ds(1))
                }(e, t)) : $i(o).pipe(tc("retrieveMediaOptionDetails.emit.cached")).pipe(Ds(1))
            };
        const xg = (t, i) => {
            if (!i) return $i(null);
            const r = t["logger"],
                {
                    mediaLibraryService: e,
                    mediaParser: n
                } = t,
                s = e.getQueryForOption(i),
                {
                    mediaOption: a,
                    mediaOptionDetailsEntityRecord: o,
                    mediaOptionDetails: l
                } = s,
                d = a["mediaOptionId"];
            if (null == o || !o[d]) throw new Error("retrieveInitSegmentCacheEntity no details entity");
            if (!l) throw new Error("retrieveInitSegmentCacheEntity no details");
            var u = o[d]["initSegmentCacheEntities"],
                c = l["initSegments"],
                h = i["discoSeqNum"];
            if (u[h]) {
                const [t, r] = u[h];
                let e = t;
                return r && (e = n.willBeTrackSwitch(i) ? t : r), $i(e)
            }
            const p = c[h];
            return p ? (e.setInitSegmentLoading(p), r.child({
                name: "timing"
            }), Rg(t, p, !1, !1).pipe(Za(() => {}), ji(tr), La(e => Pg(e, p, t)), Za(() => {}))) : $i(null)
        };

        function Pg(e, n, t) {
            const {
                logger: s,
                mediaSink: i,
                rootPlaylistService: r,
                rootPlaylistQuery: a,
                mediaParser: o,
                mediaLibraryService: l,
                gaplessInstance: d
            } = t, u = i["mediaQuery"], c = l.getQueryForOption(n), {
                mediaOption: h,
                mediaOptionDetails: p
            } = c, {
                itemId: f,
                mediaOptionId: m
            } = h, {
                keyTagInfo: g,
                discoSeqNum: y,
                mediaOptionType: v
            } = n, S = u.seeking, b = p.liveOrEvent, T = v === gu.Variant && p.ptsKnown;
            let E, I;
            n.isInitSegment ? I = new Uint8Array(e) : E = new Uint8Array(e);
            var e = {
                segment: E,
                initSegment: I,
                frag: n,
                ptsKnown: T,
                seeking: S,
                live: b,
                totalDuration: p.totalduration
            };
            return o.parseInitSegment(e, null !== (e = null === navigator || void 0 === navigator ? void 0 : navigator.vendor) && void 0 !== e ? e : "").pipe(hr(e => {
                var {
                    track: t,
                    moovData: i,
                    mimeType: r
                } = e, e = t["initSegment"];
                d.inGaplessMode && be.isVideoCodec(t.codec) && (s.warn(`Video codec discovered in gapless mode codec:${t.codec}`), d.dequeueSource("InvalidFormat"));
                r = {
                    itemId: f,
                    mediaOptionId: m,
                    discoSeqNum: y,
                    initParsedData: i,
                    data: e,
                    mimeType: r,
                    keyTagInfo: g,
                    fragment: n
                };
                return l.archiveInitSegmentEntity(r), r
            }), sg(r, a, v, m))
        }

        function Rg(n, s, i, r) {
            var e;
            const {
                rootPlaylistQuery: t,
                rootPlaylistService: a,
                config: o,
                rtcService: l,
                statsService: d
            } = n, {
                itemId: u,
                mediaOptionType: c
            } = s, h = o.fragLoadPolicy, p = ne(s.mediaSeqNum);
            let f;
            p && (f = {
                getData: !1,
                cb: (e, t, i, r) => (a.updateInflightFrag(u, s.mediaOptionType, s, "loading", i), !1)
            });
            let m = !1;
            r && null === l.serverInfoInstance && (m = !0);
            const g = nm(s, o, h, f, m, null === (e = null === (e = fg()) || void 0 === e ? void 0 : e.getQuery()) || void 0 === e ? void 0 : e.extendMaxTTFB).pipe(Za(([, , e, t]) => {
                i && d.setBandwidthSample(Object.assign(Object.assign({}, e), {
                    mediaOptionType: s.mediaOptionType
                })), r && m && (l.serverInfoInstance = t), p && a.updateInflightFrag(u, s.mediaOptionType, s, "loaded", e)
            }), Za(([e, , t]) => {
                r && l.handleFragLoaded(e, t)
            }), lg(u, c, Lc(s, h), o.maxNumAddLevelToPenaltyBox, !1, t, a, d));
            return "AES-128" === (null === (e = s.keyTagInfo) || void 0 === e ? void 0 : e.method) ? en([_g(n, s.keyTagInfo, {
                itemId: s.itemId,
                mediaOptionId: s.mediaOptionId
            }), g]).pipe(La(([e, t]) => {
                const [i, r] = t;
                return i.keyTagInfo.key = e.key, Nm(i, r, o, n.logger, n.rpcClients.crypto)
            })) : g.pipe(hr(e => e[1]))
        }
        const Lg = (i, r, e) => {
            const {
                rootPlaylistService: n,
                rootPlaylistQuery: s
            } = i, {
                timelineOffset: a,
                mediaFragment: o
            } = e.foundFrag, {
                itemId: l,
                discoSeqNum: d
            } = o;
            return xg(i, o).pipe(La(t => (n.updateInflightFrag(l, o.mediaOptionType, o, "loading", null), Rg(i, o, !0, !0).pipe(La(e => {
                return n.updateInflightFrag(l, r, o, "parsing", null),
                    function(e, t, i, y, v, S) {
                        const r = new Uint8Array(e),
                            {
                                legibleSystemAdapter: n,
                                rootPlaylistService: s,
                                mediaSink: a,
                                mediaParser: o,
                                rootPlaylistQuery: l,
                                mediaLibraryService: b
                            } = S,
                            d = a["mediaQuery"],
                            u = b.getQueryForOption(y),
                            {
                                mediaOption: c,
                                mediaOptionDetails: h
                            } = u,
                            p = h["initSegments"],
                            {
                                itemId: T,
                                mediaOptionId: E
                            } = c,
                            {
                                discoSeqNum: I,
                                mediaSeqNum: w,
                                mediaOptionType: f,
                                isLastFragment: A
                            } = y,
                            m = d.seeking,
                            g = h.liveOrEvent,
                            O = p[I],
                            k = f === gu.Variant && h.ptsKnown,
                            C = {
                                segment: r,
                                frag: y,
                                seeking: m,
                                live: g,
                                ptsKnown: k,
                                totalDuration: h.totalduration,
                                defaultInitPTS: t,
                                iframeMediaStart: Up(y) ? y.iframeMediaStart : void 0,
                                iframeDuration: Up(y) ? y.iframeMediaDuration : void 0,
                                iframeOriginalStart: Up(y) ? y.iframeOriginalStart : void 0
                            };
                        let D;
                        if (null != i && (null === (t = y.keyTagInfo) || void 0 === t ? void 0 : t.uri) === (null === (t = i.keyTagInfo) || void 0 === t ? void 0 : t.uri)) D = $i(i);
                        else if (null != i) {
                            const M = Object.assign(Object.assign({}, i.fragment), {
                                keyTagInfo: y.keyTagInfo
                            });
                            D = Pg(O ? i.data : e, M, S)
                        } else D = Pg(e, y, S);
                        return D.pipe(La(m => {
                            const g = performance.now();
                            if (null != m) {
                                const g = m["data"],
                                    e = new Uint8Array(g);
                                C.initSegment = e
                            }
                            return y.mediaOptionType === gu.Variant && (null == n || n.setupForFrag(y)), o.parseSegment(C, "").pipe(hr(e => {
                                var t = performance.now(),
                                    {
                                        startPTS: i,
                                        startDTS: r,
                                        endPTS: n,
                                        endDTS: s,
                                        firstKeyframePts: a,
                                        framesWithoutIDR: o,
                                        dropped: l,
                                        data1: d,
                                        data2: u,
                                        captionData: c,
                                        id3Samples: h,
                                        parsedInitSegment: e
                                    } = e,
                                    t = {
                                        durationSec: n.baseTime / n.timescale - i.baseTime / i.timescale,
                                        parseTimeMs: t - g
                                    };
                                S.statsService.setFragSample(t);
                                let p = Object.assign({}, m);
                                if (e) {
                                    const {
                                        track: g,
                                        moovData: f,
                                        mimeType: v
                                    } = e, S = g["initSegment"];
                                    p = {
                                        itemId: T,
                                        mediaOptionId: E,
                                        discoSeqNum: I,
                                        initParsedData: f,
                                        data: S,
                                        mimeType: v,
                                        keyTagInfo: y.keyTagInfo,
                                        fragment: y
                                    }, b.archiveInitSegmentEntity(m, p)
                                }
                                e = y.keyTagInfo;
                                return [p, {
                                    itemId: T,
                                    mediaOptionId: E,
                                    mediaSeqNum: w,
                                    discoSeqNum: I,
                                    startDtsTs: r,
                                    endDtsTs: s,
                                    timelineOffset: v,
                                    firstKeyframePts: a,
                                    framesWithoutIDR: o,
                                    dropped: l,
                                    data1: d,
                                    data2: u,
                                    startPts: i,
                                    endPts: n,
                                    keyTagInfo: e,
                                    isLastFragment: A,
                                    iframe: null !== (e = y.iframe) && void 0 !== e && e,
                                    duration: y.duration,
                                    iframeMediaDuration: Up(y) ? y.iframeMediaDuration : void 0,
                                    iframeOriginalStart: Up(y) ? y.iframeOriginalStart : void 0,
                                    captionData: c,
                                    id3Samples: h
                                }]
                            }))
                        }), sg(s, l, f, E))
                    }(e, null === (e = s.getInitPTS(d)) || void 0 === e ? void 0 : e.offsetTimestamp, t, o, a, i)
            }), Za(e => {
                n.updateInflightFrag(l, r, o, "parsed", null)
            }), tc(`retrieveMediaFragmentCacheEntity.${r}.emit`)))), Ds(1))
        };

        function _g(e, t, i) {
            const {
                keySystemAdapter: r,
                rootPlaylistQuery: n,
                rootPlaylistService: s,
                config: a
            } = e;
            return r.getKeyFromDecryptData(t, i).pipe((o = t.uri, l = Lc({
                url: t.uri
            }, a.keyLoadPolicy), d = n, u = s, c = r.ksQuery, e => e.pipe(ll(() => {
                ag(o, !1, d, u, c)
            }), va(e => e.pipe(jr((e, t) => {
                if (e instanceof mc || e instanceof gc) return og(e, t, _c(e, l), u, d, c);
                throw e
            }))))));
            var o, l, d, u, c
        }
        class Ng {
            constructor(e, t, i) {
                this.hls = e, this.destroy$ = new Xt, this.iframeSwitchStart = 0, this.logger = t.child({
                    name: "hls-player-events"
                }), this.rtc = i, this.subscribeAndEmit()
            }
            destroy() {
                this.destroy$.next()
            }
            subscribeAndEmit() {
                var e = this.loaderQueryListener(new bc(Ec)),
                    t = this.hls.publicQueries$.pipe(La(([e, t]) => an(this.rootPlaylistQueryListener(e, t), this.mediaElementQueryListener(t, e))));
                an(e, t, this.activeItemListener(this.hls.itemQueue)).pipe(Vn(e => {
                    var t = e.message;
                    return this.logger.error(`Got error in HlsPlayerEvents ${t}`, e), Ii
                }), Va(this.destroy$), Vs(() => {})).subscribe()
            }
            activeItemListener(e) {
                return e.activeItemById$.pipe(Kp(), La(e => {
                    e = e.url;
                    return this.hls.trigger(P.MANIFEST_LOADING, {
                        url: e
                    }), Ii
                }))
            }
            rootPlaylistQueryListener(t, e) {
                var i = t.enabledMediaOptionByType$(gu.Variant).pipe(ln(e => !!e), La(e => {
                        var t;
                        return this.hls.trigger(P.LEVEL_SWITCHING, e), null === (t = this.rtc) || void 0 === t || t.handleLevelSwitching(e.url), Ii
                    })),
                    r = t.enabledMediaOptionByType$(gu.Variant).pipe(La(i => Dg(i).mediaOptionDetailsEntity$.pipe(ln(e => !0 === (null == e ? void 0 : e.detailsLoading)), Za(e => {
                        var t = {
                            url: le(null == i ? void 0 : i.url),
                            level: i.mediaOptionId,
                            type: Nu[i.mediaOptionType]
                        };
                        return this.hls.trigger(P.LEVEL_LOADING, t), Ii
                    })))),
                    n = t.enabledMediaOptionByType$(gu.Variant).pipe(La(e => {
                        const t = Dg(e);
                        let i = 0;
                        return t.mediaOptionDetailsEntity$.pipe(Kp(), ln(e => {
                            var t = null !== e.stats && !1 === e.detailsLoading && e.lastUpdateMillis > i;
                            return i = null !== (e = e.lastUpdateMillis) && void 0 !== e ? e : 0, t
                        }))
                    }), La(e => {
                        var t = e.mediaOptionDetails,
                            i = e.stats,
                            r = {
                                mediaOptionId: t.mediaOptionId,
                                details: t,
                                playlistType: t.type,
                                stats: i
                            };
                        if (null === (i = this.rtc) || void 0 === i || i.handleLevelLoaded(t, r.stats), this.hls.trigger(P.LEVEL_LOADED, r), 0 === e.unchangedCount) {
                            const e = {
                                level: 0,
                                details: t
                            };
                            this.hls.trigger(P.LEVEL_UPDATED, e)
                        }
                        if (null != t && t.daterangeTags) {
                            const e = {
                                daterangeTags: t.daterangeTags
                            };
                            this.hls.trigger(P.DATERANGE_UPDATED, e)
                        }
                        return Ii
                    })),
                    s = t.enableMediaOptionSwitchedForType$(gu.AltAudio).pipe(La(e => {
                        e = t.alternateMediaOptionById(gu.AltAudio, e.mediaOptionId);
                        return e && this.triggerAudioSwitch(e), Ii
                    })),
                    a = t.rootPlaylistEntity$.pipe(ln(e => null !== e.enabledMediaOptionKeys[gu.AltAudio].mediaOptionId), Ds(1), La(e => {
                        const t = e.enabledMediaOptionKeys[gu.AltAudio].mediaOptionId;
                        return t && (e = e.mediaOptionListTuple[gu.AltAudio].mediaOptions.find(e => e.mediaOptionId === t), this.triggerAudioSwitch(Object.assign(Object.assign({}, e), {
                            url: le(null == e ? void 0 : e.url)
                        }))), Ii
                    }));
                return an(i, s, Gu(e.textTracksCreated$, e => e).pipe(La(() => t.enabledMediaOptionByType$(gu.Subtitle).pipe(La(e => {
                    e = t.alternateMediaOptionById(gu.Subtitle, e.mediaOptionId);
                    return e ? this.hls.trigger(P.SUBTITLE_TRACK_SWITCH, {
                        track: Object.assign({}, e),
                        hidden: !1
                    }) : this.hls.trigger(P.SUBTITLE_TRACK_SWITCH, {
                        track: void 0,
                        hidden: !1
                    }), Ii
                })))), t.sessionData$.pipe(ln(e => null != e.complete), Ds(1), Za(e => {}), hr(e => {
                    this.hls.trigger(P.SESSION_DATA_COMPLETE, e)
                })), t.getPreferredMediaOptionsByType$(gu.Variant).pipe(ka(1), hr(e => {
                    const t = e;
                    null === (e = this.rtc) || void 0 === e || e.handleLevelsChanged(t), t.forEach(e => {}), this.hls.trigger(P.LEVELS_CHANGED, {
                        requiresReset: !1,
                        levels: t
                    })
                })), t.getPreferredMediaOptionsByType$(gu.AltAudio).pipe(hr(e => {
                    this.hls.trigger(P.AUDIO_TRACKS_UPDATED, {
                        audioTracks: e
                    })
                })), Gu(e.textTracksCreated$, e => e).pipe(La(() => t.getPreferredMediaOptionsByType$(gu.Subtitle).pipe(Ds(1), hr(e => {
                    this.hls.trigger(P.SUBTITLE_TRACKS_UPDATED, {
                        subtitleTracks: e
                    }), this.hls.trigger(P.SUBTITLE_TRACKS_CREATED)
                })))), n, r, a)
            }
            mediaElementQueryListener(s, e) {
                return an(s.seekTo$.pipe(hr(e => {
                    var t;
                    e && ne(e.pos) ? (null === (t = this.rtc) || void 0 === t || t.handleSeek("SEEKING"), this.hls.trigger(P.SEEKING, {
                        seekToPos: e.pos
                    })) : null === e && (null === (e = this.rtc) || void 0 === e || e.handleSeek("SEEKED"), this.hls.trigger(P.SEEKED))
                })), s.desiredRate$.pipe(Ra(0), ha(), hr(e => {
                    var t = e[0],
                        i = e[1];
                    Wp(i) ? 0 == this.iframeSwitchStart && (this.iframeSwitchStart = performance.now()) : this.iframeSwitchStart = 0, this.hls.trigger(P.DESIRED_RATE_CHANGED, {
                        oldRate: t,
                        newRate: i
                    }), null === (e = this.rtc) || void 0 === e || e.handleDesiredRateChanged(t, i)
                })), s.sourceBufferEntityByType$(yu.AltAudio).pipe(ln(e => !!e), Is((e, t) => e.totalBytes === t.totalBytes), hr(e => {
                    this.hls.trigger(P.BUFFER_APPENDED)
                })), s.sourceBufferEntityByType$(yu.Variant).pipe(ln(e => !!e), Is((e, t) => e.totalBytes === t.totalBytes), hr(e => {
                    var t;
                    null === (t = this.rtc) || void 0 === t || t.handleVariantBufferAppended(e.timestampOffset, e.totalBytes), this.hls.trigger(P.BUFFER_APPENDED)
                })), s.stallInfo$.pipe(Kp(), bo(s.combinedBuffer$), hr(([e]) => {
                    var t;
                    null === (t = this.rtc) || void 0 === t || t.handleStalled(e, s.getCombinedBufferInfo(e.currentTime, 0).len), this.hls.trigger(P.STALLED, e)
                })), Mr([$i(e), ed([s.timeupdate$, s.bufferedSegmentsByType$(yu.Variant)]).pipe(ao(1e3), hr(([t, e]) => null == e ? void 0 : e.find(e => e.startPTS <= t && e.endPTS > t)), ln(e => !!e), Ra(null), ha())]).pipe(La(([e, [t, i]]) => {
                    var r = null == i ? void 0 : i.frag,
                        t = null == t ? void 0 : t.frag;
                    if (r && !$p(t, r) && (this.hls.trigger(P.FRAG_CHANGED, i), this.hls.inGaplessMode && this.checkAndTriggerReadyForNext(s, i), !t || r.mediaOptionId !== t.mediaOptionId)) {
                        const s = e.mediaOptionListQueries[gu.Variant].mediaOptionFromId(r.mediaOptionId);
                        if (!s) return this.logger.warn("variantInfo is undefined in fragChangeMonitor"), Ii;
                        const n = t ? t.mediaOptionId : "",
                            i = r.mediaOptionId;
                        s.iframes && (performance.now(), this.iframeSwitchStart), null === (r = this.rtc) || void 0 === r || r.handleLevelSwitched({
                            url: s.url,
                            mediaOptionId: s.mediaOptionId,
                            oldVariant: "" !== n ? n : void 0,
                            newVariant: i
                        }), this.hls.trigger(P.LEVEL_SWITCHED, s)
                    }
                    return Ii
                })), s.isBufferedToEnd$(this.hls.config.maxBufferHole, !1).pipe(ln(e => !0 === e), ji(tr), hr(e => {
                    if (e && !this.hls.itemQueue.isPreloading() && this.hls.inGaplessMode) {
                        const i = s.getCombinedBufferInfo(s.currentTime, 0);
                        var t = 0;
                        i && (t = i.end, e = s.mediaElementDuration, 0 < t && e - s.currentTime < 10 && this.hls.trigger(P.READY_FOR_NEXT_ITEM, {
                            duration: t
                        }))
                    }
                })))
            }
            checkAndTriggerReadyForNext(e, t) {
                var i, r;
                t && t.frag && (i = e.currentTime, (r = e.getCombinedBufferInfo(i, 0)) && (i = r.end, r = e.mediaElementDuration, e = e.bufferMonitorInfo, e = Math.max(e.almostDryWaterLevelSeconds, e.lowWaterLevelSeconds / 2), (r - t.endPTS <= e || t.frag.isLastFragment) && this.hls.inGaplessMode && !this.hls.isPreloading && this.hls.trigger(P.READY_FOR_NEXT_ITEM, {
                    duration: i
                })))
            }
            loaderQueryListener(e) {
                return an(e.unresolvedUriLoading$.pipe(hr(e => e.map(e => {
                    e = {
                        uri: e.uri,
                        responseType: e.responseType,
                        userAgent: e.userAgent
                    };
                    this.hls.trigger(P.UNRESOLVED_URI_LOADING, e)
                }))))
            }
            triggerAudioSwitch(e) {
                e && this.hls.trigger(P.AUDIO_TRACK_SWITCHED, {
                    id: e.id
                })
            }
            triggerManifestLoaded(e) {
                e = {
                    levels: e.rootMediaOptionsTuple[gu.Variant],
                    audioTracks: e.rootMediaOptionsTuple[gu.AltAudio],
                    subtitleTracks: e.rootMediaOptionsTuple[gu.Subtitle],
                    url: e.baseUrl,
                    audioMediaSelectionGroup: e.audioMediaSelectionGroup,
                    subtitleMediaSelectionGroup: e.subtitleMediaSelectionGroup,
                    stats: e.stats,
                    isMediaPlaylist: e.isMediaPlaylist
                };
                this.hls.trigger(P.MANIFEST_LOADED, e)
            }
            triggerManifestParsed(e) {
                var t = {
                    levels: e.mediaOptionListQueries[gu.Variant].filteredMediaOptionList,
                    firstLevel: 0,
                    audio: !1,
                    video: !0,
                    altAudio: !1,
                    audioTracks: e.mediaOptionListQueries[gu.AltAudio].filteredMediaOptionList,
                    audioMediaSelectionGroup: e.audioMediaSelectionGroup,
                    subtitleMediaSelectionGroup: e.subtitleMediaSelectionGroup,
                    stats: e.loadStats
                };
                null === (e = this.rtc) || void 0 === e || e.handleManifestParsed(t), this.hls.trigger(P.MANIFEST_PARSED, t)
            }
            urlRedactedManifestLoaded(e) {
                const t = Object.assign({}, e);
                return t.url = le(t.url), t.levels = ue(t.levels), t.audioTracks = ce(t.audioTracks), t.subtitleTracks = ce(t.subtitleTracks), t
            }
            urlRedactedManifestParsed(e) {
                const t = Object.assign({}, e);
                return t.levels = ue(t.levels), t.audioTracks = ce(t.audioTracks), t
            }
        }(A = Mm = Mm || {}).LowBandwidth = "LowBandwidth", A.HighBandwidth = "HighBandwidth", A.PreferredListChanged = "PreferredListChanged", A.IframeModeChange = "IframeModeChange", A.None = "";
        const Fg = {
            minValidBitrate: 2e6,
            maxValidBitrate: 5e6,
            maxPreferredBitrate: 3e6,
            minValidHeight: 480,
            maxValidHeight: 720
        };

        function Bg(e, a, o, l, d, u) {
            return e.reduce((e, t) => {
                if (t.iframes) return e;
                let i = e;
                const r = (n = t.score, s = a && o && l && d && !Ug(t, a, o, l, d, u) ? mu.INVALID : mu.VALID, new Qp(s, n));
                var n, s;
                return (!e || r.isGreaterThan(e.bestRank) || r.isEqualTo(e.bestRank) && t.bandwidth < e.selected.bandwidth) && (i = {
                    selected: t,
                    bestRank: r
                }), i
            }, null).selected
        }

        function Ug(e, t, i, r, n, s) {
            var {
                targetDuration: a,
                targetStartupMs: o
            } = i, l = r["avgPlaylistLoadTimeMs"], d = n["avgParseTimeMs"], {
                avgBufferCreateMs: i,
                avgInitFragAppendMs: r,
                avgDataFragAppendMs: n
            } = s, {
                avgBandwidth: s,
                avgLatencyMs: t
            } = t;
            return e.bandwidth <= s && (e.avgBandwidth || e.bandwidth) * a / s * 1e3 + l + i + +(t + d + (r + n)) <= o
        }
        const $g = {
            name: "abr"
        };

        function Vg(e, t) {
            return ne(e) ? Math.min(e, t) : t
        }

        function Kg(e) {
            return ne(null == e ? void 0 : e.avgBandwidth)
        }

        function qg(e, t) {
            return e.getCurrentWaterLevelByType(yu.Variant, t) / (0 !== e.playbackRate ? Math.abs(e.playbackRate) : 1)
        }

        function Hg(t, i, e, r) {
            if (e) return t;
            let n = -1;
            if (t < 0) return n;
            for (let e = t; e < i.length; ++e) {
                const t = Qg(i[e], r);
                if (t.altAudio && t.subtitle) {
                    n = e;
                    break
                }
            }
            return n
        }

        function jg(t, e, i, r, n, s, a) {
            const o = i.preferredMediaOptions[gu.Variant].filter(e => e.iframes === t);
            if (!o.length) return {
                variantMediaOption: Lu.mediaOptionId,
                holdOffDuration: 0,
                lowestCandidate: null
            };
            let l = 0;
            const d = i.nextMinAutoOptionId;
            if (d !== Lu.mediaOptionId) {
                const t = o.findIndex(e => e.mediaOptionId === d);
                0 <= t && (l = t)
            }
            if (l = Hg(l, o, t, i), l < 0) return {
                variantMediaOption: Lu.mediaOptionId,
                holdOffDuration: 0,
                lowestCandidate: null
            };
            let u = o.length - 1;
            const c = i.nextMaxAutoOptionId;
            if (c !== Lu.mediaOptionId) {
                const t = o.findIndex(e => e.mediaOptionId === c);
                0 <= t && (u = t)
            }
            var h = i.variantMediaOptionById(r.mediaOptionId),
                p = r.mediaOptionDetails,
                f = (null == h ? void 0 : h.iframes) !== t ? 0 : qg(n, e.maxBufferHole);
            let m, g;
            if (t) {
                const t = e.desiredIframeFPS;
                g = p ? p.targetduration / t : 0, g = Math.max(1 / t, g)
            } else g = p ? p.targetduration : 0;
            h = e.abrBandWidthUpFactor, p = e.abrBandWidthFactor;
            return m = Wg(o, g, l, u, f, t, s.getCombinedEstimate(), s.bandwidthStatus, p, h, e, i, r, n, a), m.variantMediaOption === Lu.mediaOptionId && (m = Wg(o, g, l, u, f + Vg(g, e.maxStarvationDelay), t, s.getCombinedEstimate(), s.bandwidthStatus, p, h, e, i, r, n, a), m.variantMediaOption === Lu.mediaOptionId && 0 <= l && (m.variantMediaOption = o[l].mediaOptionId, m.alternates = t ? null : Qg(o[l], i))), m
        }

        function Qg(e, t) {
            var i = t.enabledMediaOptionKeys,
                r = i[gu.AltAudio],
                r = _u(r) ? t.mediaOptionListQueries[gu.AltAudio].getMatchingAlternate(r.mediaOptionId, e) : Lu,
                i = i[gu.Subtitle];
            return {
                altAudio: r,
                subtitle: _u(i) ? t.mediaOptionListQueries[gu.Subtitle].getMatchingAlternate(i.mediaOptionId, e) : Lu
            }
        }

        function Wg(i, r, n, e, s, a, o, l, t, d, u, c, h, p, f) {
            "bandwidth-history-controller" !== u.abrBandwidthEstimator && f.warn(`Unsupported configuration: ${u.abrBandwidthEstimator} for ABR bandwidth estimator`);
            const m = l.bandwidthSampleCount,
                g = c.abrStatus,
                y = p.maxBufferSize,
                v = u.minTargetDurations || 1,
                S = c.mediaOptionListQueries[gu.Variant].mediaOptionListInfo.hasScore;
            if (!i.length) return {
                variantMediaOption: Lu.mediaOptionId,
                holdOffDuration: -1,
                lowestCandidate: null
            };
            const b = c.enabledMediaOptionIdByType(gu.Variant),
                T = c.variantMediaOptionById(b),
                E = null != i.find(e => e.mediaOptionId === b),
                I = T && T.iframes === a,
                w = T && I ? T.score : void 0,
                A = T && I ? T.frameRate : void 0,
                O = T && I ? T.height : void 0,
                k = I ? qg(p, u.maxBufferHole) : 0;
            e = Math.max(0, Math.min(i.length - 1, e)), n = Math.max(0, Math.min(i.length - 1, n));
            var C = h.mediaOptionDetailsEntityRecord,
                D = Gg(o.avgBandwidth, d, t, m);
            let M;
            for (let t = e; t >= n; t--) {
                const n = i[t];
                let e = n.mediaOptionId;
                const u = n.score,
                    h = C && C[e] ? C[e].mediaOptionDetails : void 0,
                    p = C && C[e] ? C[e].lastUpdateMillis : null,
                    f = h ? h.totalduration / h.fragments.length : r,
                    B = null != T && n.bitrate > T.bitrate,
                    m = null != T && n.bitrate < T.bitrate,
                    U = !(null != A && (B && n.frameRate < A || m && n.frameRate > A)),
                    $ = !(B && null != O && O > n.height),
                    V = !(m && (n.bitrate === T.bitrate - 1 || n.bitrate === T.bitrate + 1)),
                    K = !(S && B && null != w && (u < w || u === w && T && n.bitrate >= T.bitrate)),
                    q = n.iframes === a;
                if (ne(f) && q && U && $ && V && K) {
                    var {
                        adjustedbw: x,
                        bitrate: P,
                        fetchDuration: R,
                        rejectLevelDueToPeakBW: L,
                        canFitMultipleSegments: _,
                        requireAlternates: N,
                        alternates: F
                    } = function(e, t, i, r, n, s, a, o, l, d, u, c) {
                        var h = n ? a.bwUp : a.bwDown,
                            n = e.bitrate,
                            a = t ? t.totalduration / t.fragments.length : o,
                            s = zg(e, t, o, h, ne(s.avgPlaylistLoadTimeMs) ? s.avgPlaylistLoadTimeMs : s.avgLatencyMs, d),
                            d = e.bandwidth,
                            i = n < h && h < d && i <= 2 * a,
                            l = r * ((d || n || 0) * ((null == t ? void 0 : t.targetduration) || a)) / 8 <= l;
                        let p = null;
                        u = !u;
                        return u && (p = Qg(e, c), p.altAudio && p.subtitle || (p = null)), {
                            adjustedbw: h,
                            bitrate: n,
                            fetchDuration: s,
                            rejectLevelDueToPeakBW: i,
                            canFitMultipleSegments: l,
                            requireAlternates: u,
                            alternates: p
                        }
                    }(n, h, k, v, B, o, D, r, y, p, a, c);
                    if (N && Boolean(F) && (M = e), P < x && _ && !L && (!N || Boolean(F)) && (a || !R || R < s)) {
                        if (L = x, N = g, x = (x = l).instantBw, (N.fragDownloadSlow || N.fragDownloadTooSlow || ne(x) && x < L) && E && I)
                            if (k <= 2 * f && B) e = b;
                            else if (B && d * l.instantBw < P) continue;
                        return {
                            variantMediaOption: e,
                            holdOffDuration: R,
                            alternates: F,
                            lowestCandidate: M
                        }
                    }
                }
            }
            return {
                variantMediaOption: Lu.mediaOptionId,
                holdOffDuration: -1,
                lowestCandidate: M
            }
        }

        function Gg(e, t, i, r) {
            let n, s;
            return 4 <= r ? (n = e * t, s = e * i) : n = s = e / 1.8, {
                bwUp: n,
                bwDown: s
            }
        }

        function zg(e, t, i, r, n, s) {
            let a = e.bitrate * (t ? t.totalduration / t.fragments.length : i) / r;
            return null == t || !t.liveOrEvent || t.ptsKnown && !Yg(t.totalduration, n, s) || (a *= 2), ne(n) && (!ne(s) || null != t && t.liveOrEvent) && (a += n / 1e3), a
        }

        function Xg(t, e) {
            let i = 1 / 0;
            if (t === Lu.mediaOptionId) return i;
            var r = e.find(e => e.mediaOptionId === t);
            if (!r) return 1 / 0;
            const n = r.iframes,
                s = r.bitrate,
                a = r.frameRate,
                o = e.find(e => e.iframes === n && (void 0 === a || e.frameRate >= a) && e.bitrate > s);
            return o && (i = o.bitrate), i
        }

        function Yg(e, t, i) {
            return t = ne(t) ? t : 0, !ne(i) || performance.now() - i + t > 1e3 * e
        }

        function Jg(e, t) {
            return (null == e ? void 0 : e.fragDownloadSlow) === (null == t ? void 0 : t.fragDownloadSlow) && e.fragDownloadTooSlow === (null == t ? void 0 : t.fragDownloadTooSlow)
        }

        function Zg(e) {
            return "loading" === (null == e ? void 0 : e.state) && ne(null === (e = e.bwSample) || void 0 === e ? void 0 : e.trequest)
        }
        const ey = 2e3;

        function ty(e, t, i, r) {
            let {
                fragDownloadSlow: n,
                fragDownloadTooSlow: s
            } = t;
            var a = i.variantMediaOptionById(e.mediaOptionId).bitrate,
                t = e.bwSample;
            r = r.child($g);
            i = t.total || Math.max(t.loaded, Math.round(e.duration * a / 8)), a = performance.now() - t.tfirst, i = t.loaded * e.duration * 1e3 / i;
            return a >= ey && 1e3 <= a - i && (n || r.warn(`flow indicates low bandwidth, after time/duration behind real time: ${a}/${a-i}`), n = !0), a >= 1e3 * e.duration && (s || r.warn(`too much time spent downloading fragment, likely to switch down ${a} > ${1e3*e.duration}`), s = !0), {
                fragDownloadSlow: n,
                fragDownloadTooSlow: s
            }
        }

        function iy(e, t, i, r, n) {
            var s;
            const a = n.logger.child($g),
                o = r.isIframeRate,
                l = i.mediaOptionListQueries[gu.Variant].preferredMediaOptionList,
                d = i.enabledMediaOptionKeys[gu.Variant];
            let u = e;
            if (u !== Mm.None || l.some(e => e.mediaOptionId === d.mediaOptionId) || (u = Mm.PreferredListChanged), u !== Mm.None && !(o && u !== Mm.IframeModeChange && r.getBufferedSegmentsByType(yu.Variant).filter(e => e.frag.iframe).length < t.minFramesBeforeSwitchingLevel)) {
                o && u === Mm.IframeModeChange && n.setEnabledVariantMediaOptionIdBeforeTrickplaySwitch(i.itemId, d.mediaOptionId);
                const h = Zf(i.itemId),
                    p = Dg(d),
                    f = [Lu, Lu, Lu];
                if (!o && e === Mm.IframeModeChange) {
                    const e = function(e, t, i, r) {
                        const n = i.mediaOptionListQueries[gu.Variant].preferredMediaOptionList,
                            s = t.targetStartupMs,
                            a = {
                                avgPlaylistParseTimeMs: 0,
                                avgPlaylistLoadTimeMs: 0
                            },
                            o = r.getFragEstimate(),
                            l = {
                                avgBufferCreateMs: 0,
                                avgInitFragAppendMs: 0,
                                avgDataFragAppendMs: 0
                            },
                            d = o.maxDurationSec,
                            u = {
                                avgLatencyMs: 0,
                                avgBandwidth: r.getBandwidthEstimate().avgBandwidth
                            },
                            c = {
                                targetDuration: d,
                                targetStartupMs: s,
                                metricsOverride: {
                                    maxValidHeight: 0,
                                    maxValidBitrate: 0,
                                    maxPreferredBitrate: 0
                                }
                            },
                            h = n.filter(e => !e.iframes && (!e.width || !e.height || e.width * e.height <= 2488320));
                        let p = e;
                        0 < h.length && (p = h[0].mediaOptionId);
                        e = h.filter(e => Ug(e, u, c, a, o, l));
                        return 0 < e.length && (p = e[e.length - 1].mediaOptionId), p
                    }(i.enabledVariantMediaOptionIdBeforeTrickplaySwitch, t, i, h);
                    n.setNextMaxAutoOptionId(i.itemId, e), n.setEnabledVariantMediaOptionIdBeforeTrickplaySwitch(i.itemId, void 0)
                }
                var c = function(e, t, i, r, n, s, a) {
                    let o = t.nextMaxAutoOptionId;
                    if (o === Lu.mediaOptionId || Kg(s.getBandwidthEstimate())) return l = e, d = t, u = r, e = n, r = s, s = a.child({
                        name: "abr"
                    }), a = e.isIframeRate, d.enabledMediaOptionIdByType(gu.Variant), jg(a, l, d, u, e, r, s);
                    if (n.isIframeRate) return {
                        variantMediaOption: o,
                        holdOffDuration: 0,
                        lowestCandidate: null
                    }; {
                        const c = t.variantMediaOptionById(o),
                            h = t.enabledAlternateMediaOptionByType(gu.Subtitle),
                            n = t.enabledAlternateMediaOptionByType(gu.AltAudio),
                            p = null == n ? void 0 : n.persistentID,
                            f = null == h ? void 0 : h.persistentID,
                            m = !t.preferHDR,
                            g = i.getBestMediaOptionTupleFromVariantAndPersistentId(t, c, p, f, void 0, [], m, !1, !1);
                        return t.isValidMediaOptionTuple(g) ? (o = g[gu.Variant].mediaOptionId, {
                            variantMediaOption: o,
                            holdOffDuration: 0,
                            alternates: {
                                altAudio: g[gu.AltAudio],
                                subtitle: g[gu.Subtitle]
                            },
                            lowestCandidate: null
                        }) : {
                            variantMediaOption: t.enabledMediaOptionKeys[gu.Variant].mediaOptionId,
                            holdOffDuration: 0,
                            lowestCandidate: null
                        }
                    }
                    var l, d, u
                }(t, i, n, p, r, h, a);
                if (o || e !== Mm.IframeModeChange || n.setNextMaxAutoOptionId(i.itemId, Lu.mediaOptionId), c.variantMediaOption !== d.mediaOptionId) {
                    f[gu.Variant] = {
                        itemId: i.itemId,
                        mediaOptionId: c.variantMediaOption
                    };
                    for (const e of [gu.AltAudio, gu.Subtitle]) {
                        const t = i.enabledMediaOptionIdByType(e);
                        if (t !== Lu.mediaOptionId) {
                            const r = e === gu.AltAudio ? null === (s = c.alternates) || void 0 === s ? void 0 : s.altAudio : null === (s = c.alternates) || void 0 === s ? void 0 : s.subtitle;
                            f[e] = r || {
                                itemId: i.itemId,
                                mediaOptionId: t
                            }
                        }
                    }
                    return n.setEnabledMediaOptions(i.itemId, f), 1
                }
            }
        }
        const ry = {
            name: "iframes"
        };
        (A = xm = xm || {})[A.DISABLED = 0] = "DISABLED", A[A.ERRORED = 1] = "ERRORED", A[A.SUCCESS = 2] = "SUCCESS";
        const ny = new fl({}, {
                name: "item-queue",
                producerFn: su,
                idKey: "itemId",
                resettable: !0
            }),
            sy = new class extends kl {}(ny);
        class ay {
            constructor() {
                this.firstItem = !0, this.playingEntity = null, this.loadingEntity = null
            }
            static createItem(e, t, i = NaN, r, n) {
                const s = new Date,
                    a = `${s.getHours()}:${s.getMinutes()}:${s.getSeconds()}`;
                Qe();
                var o = function(e) {
                    e = cu.parseURL(e).fragment.substr(1);
                    if (0 === e.length) return null;
                    const t = new URLSearchParams(e);
                    if (!t.has("t")) return null;
                    e = Number(t.get("t"));
                    return ne(e) ? e : null
                }(t);
                if (ne(o)) i = o;
                else {
                    const e = mg();
                    ne(null == e ? void 0 : e.startPosition) && (i = e.startPosition)
                }
                return {
                    itemId: `${e}_${a}`,
                    name: e,
                    url: t,
                    serviceName: n,
                    createTime: a,
                    initialSeekTime: i,
                    itemStartOffset: 0,
                    platformInfo: r,
                    config: {}
                }
            }
            get activeItemById$() {
                return sy.selectActiveId().pipe(hr(e => sy.getActive()))
            }
            get removedItems$() {
                return sy.selectEntityAction(Eo.Remove).pipe(hr(e => e))
            }
            get activeItem() {
                return sy.getActive()
            }
            get queueItems$() {
                return sy.selectAll().pipe(hr(e => null != e ? e : []))
            }
            get isFirstItem() {
                return this.firstItem
            }
            get playingItem() {
                return this.playingEntity
            }
            get loadingItem() {
                return this.loadingEntity
            }
            addQueueItem(e, t, i, r, n, s) {
                sy.getCount();
                const a = ay.createItem(e, t, i, r, s);
                null != this.playingEntity && (a.initialSeekTime = void 0), n && (a.itemStartOffset = n, this.firstItem = !1, this.playingEntity = this.activeItem, this.loadingEntity = a), Do(`queue.add.item: ${e}`), al(() => {
                    ny.add(a), ny.setActive(a.itemId)
                })
            }
            updatePlayingItemId() {
                this.playingEntity = this.loadingEntity, this.loadingEntity = null, this.clearAllButActive()
            }
            resetLoadingItem() {
                this.removeQueueItem(this.loadingEntity.itemId), this.loadingEntity = null, al(() => {
                    ny.setActive(this.playingEntity.itemId)
                })
            }
            isPreloading() {
                return null !== this.playingEntity && null !== this.loadingEntity
            }
            setQueueItem(t, i, r, n, s) {
                Do("queue.set.item"), this.loadingEntity = null, al(() => {
                    ny.reset();
                    var e = ay.createItem(t, i, r, n, s);
                    ny.add(e), ny.setActive(e.itemId)
                }), this.playingEntity = this.activeItem
            }
            removeQueueItem(e) {
                ny.remove(e)
            }
            clearQueue() {
                ny.reset()
            }
            clearAllButActive() {
                var e;
                const t = null === (e = this.activeItem) || void 0 === e ? void 0 : e.itemId;
                al(() => {
                    sy.getAll().forEach(e => {
                        e.itemId !== t && ny.remove(e.itemId)
                    })
                })
            }
            set earlyAudioSelection(t) {
                ny.updateActive(e => {
                    e.earlySelection || (e.earlySelection = {}), e.earlySelection.audioPersistentId = t
                })
            }
            get earlyAudioSelection() {
                var e;
                return null === (e = this.activeItem.earlySelection) || void 0 === e ? void 0 : e.audioPersistentId
            }
            set earlySubtitleSelection(t) {
                ny.updateActive(e => {
                    e.earlySelection || (e.earlySelection = {}), e.earlySelection.subtitlePersistentId = t
                })
            }
            get earlySubtitleSelection() {
                var e;
                return null === (e = this.activeItem.earlySelection) || void 0 === e ? void 0 : e.subtitlePersistentId
            }
        }

        function oy(e, t, i, r, n, s) {
            return ng(e, 0, Jm({
                errorAction: Cm.RemoveAlternatePermanently,
                errorActionFlags: 0
            }, !1, e.response.code, i, t, s, n), s, n, t, i).pipe(Vn(e => {
                throw !1 === e.fatal && r.resetMediaSource(), e
            }))
        }
        class ly {
            constructor(e, t, i, r, n, s) {
                this.logger = e, this._rootPlaylistService = t, this._rootQuery = i, this._mediaQuery = r, this._iframeMachine = n, this._anchorMSNs = [NaN, NaN], this._avDetails = [null, null], this.logger = e.child({
                    name: "fpicker"
                }), this._discoSeqNum = NaN, this.lookUpTolerance = Math.max(s.maxBufferHole, s.maxFragLookUpTolerance), this.firstAudioMustOverlapVideoStart = s.firstAudioMustOverlapVideoStart, this.lookUpToleranceAlt = s.firstAudioMustOverlapVideoStart ? 0 : s.maxFragLookUpTolerance
            }
            destroy() {
                this._anchorMSNs = [NaN, NaN], this._avDetails = [null, null], this._rootQuery = null, this._mediaQuery = null, this._rootPlaylistService = null, this._iframeMachine = null
            }
            get discoSeqNum() {
                return this._discoSeqNum
            }
            get _discoSeqNum() {
                return this._rootQuery.discoSeqNum
            }
            set _discoSeqNum(e) {
                this._rootPlaylistService.setDiscoSeqNum(this._rootQuery.itemId, e)
            }
            get anchorMSNs() {
                return this._anchorMSNs
            }
            _resolvePosition(e, t, i) {
                let r = e;
                var t = this._avDetails[t];
                if ((null == t ? void 0 : t.mediaOptionId) !== (null == i ? void 0 : i.mediaOptionId) && i.liveOrEvent && !1 === i.ptsKnown && (!t || Math.max(t.startSN, i.startSN) > Math.min(t.endSN, i.endSN))) {
                    const e = 3 * i.targetduration,
                        n = (null === (t = i.fragments[0]) || void 0 === t ? void 0 : t.start) + i.totalduration;
                    r = Math.max(0, n - e)
                }
                return r
            }
            getDiscoSeqNumForTime(e, t) {
                return this._mediaQuery.isIframeRate && e.iframesOnly ? Qu.discoSeqNumForTime(e.fragments, t) : (r = t, null == (e = null !== (e = Tg(e, e => {
                    var t = 0 < e.duration,
                        i = e.start + e.duration,
                        e = r < i || r - i < 1 && e.isLastFragment;
                    return t && e
                })) && void 0 !== e ? e : null) ? void 0 : e.mediaFragment.discoSeqNum);
                var r
            }
            _updateAnchorByPosition(e, t) {
                let i = NaN;
                const r = t[yu.Variant];
                let n = e;
                if (r) {
                    const t = r.fragments;
                    if (n = this._resolvePosition(e, yu.Variant, r), i = this.getDiscoSeqNumForTime(r, n), !ne(i)) {
                        const r = t[0],
                            s = t[t.length - 1],
                            a = null == r ? void 0 : r.start,
                            o = (null == s ? void 0 : s.start) + (null == s ? void 0 : s.duration);
                        this.logger.warn(`${e.toFixed(3)} out of range [${null==a?void 0:a.toFixed(3)},${null==o?void 0:o.toFixed(3)}]`), n <= a ? i = r.discoSeqNum : n >= o ? i = s.discoSeqNum : this.logger.warn(`Unable to determine newCC. fragFirst: ${JSON.stringify(r)} fragLast: ${JSON.stringify(s)}`), ne(i) || this.logger.warn(`Unable to determine newCC. fragFirst: ${JSON.stringify(r)} fragLast: ${JSON.stringify(s)}`)
                    }
                } else this.logger.warn("No variant details for anchoring");
                return this._updateAnchor(i, t), n
            }
            _updateAnchor(e, s) {
                const a = e !== this._discoSeqNum;
                a && (this._discoSeqNum = e), Bu.forEach(e => {
                    const t = this._avDetails[e],
                        i = s[e],
                        r = (null == t ? void 0 : t.mediaOptionId) !== (null == i ? void 0 : i.mediaOptionId);
                    if (a || r) this._updateAnchorForType($u(e), i);
                    else if (i) {
                        const {
                            mediaOptionId: s,
                            ptsKnown: a,
                            dateMediaTimePairs: t,
                            startSN: r,
                            endSN: n
                        } = i;
                        this._avDetails[e] = {
                            mediaOptionId: s,
                            ptsKnown: a,
                            dateMediaTimePairs: t,
                            startSN: r,
                            endSN: n
                        }
                    }
                })
            }
            getNextFragments(i, r, n) {
                const {
                    position: s,
                    bufferInfoTuple: e,
                    switchContexts: a
                } = i;
                let t = e.map((e, t) => dy(s, r[t], a[t], null == e ? void 0 : e.buffered, t === gu.AltAudio ? this.lookUpToleranceAlt : this.lookUpTolerance)).reduce((e, t) => Math.min(t, e), Number.POSITIVE_INFINITY);
                if (ne(i.discoSeqNum)) {
                    const s = r.reduce((e, t) => {
                        if (!t) return e;
                        t = Qu.getTimeRangeForCC(t.fragments, i.discoSeqNum, n);
                        return [Math.max(e[0], t[0]), Math.min(e[1], t[1])]
                    }, [Number.NEGATIVE_INFINITY, Number.POSITIVE_INFINITY]);
                    t = Math.min(Math.max(t, s[0]), s[1])
                }
                return i.position = this._updateAnchorByPosition(t, r), this._getNextFragmentsInternal(i, r)
            }
            _getNextFragmentsInternal(r, n) {
                const s = [null, null];
                let a;
                n.forEach((e, t) => {
                    var i;
                    this.firstAudioMustOverlapVideoStart && t === gu.AltAudio && this._mediaQuery.seeking && null !== (i = s[gu.Variant]) && void 0 !== i && i.foundFrag && (a = r.position, r.position = s[gu.Variant].foundFrag.mediaFragment.start), s[t] = this._getNextFragmentForType(r, n, t)
                });
                var e = s[yu.Variant],
                    t = s[yu.AltAudio],
                    i = null === (o = null == e ? void 0 : e.foundFrag) || void 0 === o ? void 0 : o.mediaFragment,
                    o = null === (o = null == t ? void 0 : t.foundFrag) || void 0 === o ? void 0 : o.mediaFragment;
                if (i && o && (o.start > i.start + i.duration ? (this.logger.warn("Audio too far ahead"), s[yu.AltAudio] = ly.noopResult) : i.start > o.start + o.duration && !this._mediaQuery.isIframeRate && (this.logger.warn("Video too far ahead"), s[yu.Variant] = ly.noopResult)), !isFinite(null == e ? void 0 : e.nextDisco) || null != t && !ne(t.nextDisco)) return s; {
                    const l = s[yu.Variant].nextDisco;
                    return this._updateAnchor(l, n), ne(a) && (r.position = a, a = NaN), this._getNextFragmentsInternal(r, n)
                }
            }
            _getNextFragmentForType(e, t, i) {
                var {
                    position: r,
                    bufferInfoTuple: n,
                    switchContexts: s
                } = e, a = t[i], o = null !== (d = null === (c = n[i]) || void 0 === c ? void 0 : c.buffered) && void 0 !== d ? d : {
                    start: r,
                    end: r,
                    len: 0
                }, l = this._mediaQuery.getBufferedSegmentsByType(i), d = null !== (c = null === (e = s[i]) || void 0 === e ? void 0 : e.userInitiated) && void 0 !== c && c, u = dy(r, a, s[i], o, this.lookUpTolerance);
                if (!a) return null;
                var {
                    highWaterLevelSeconds: e,
                    lowWaterLevelSeconds: c
                } = this._mediaQuery.bufferMonitorInfo, r = o.len;
                if (!d && e <= r) return ly.noopResult;
                var e = i === yu.Variant ? yu.AltAudio : yu.Variant,
                    n = null === (n = n[e]) || void 0 === n ? void 0 : n.buffered,
                    e = null !== (e = null === (e = s[e]) || void 0 === e ? void 0 : e.userInitiated) && void 0 !== e && e;
                let h = !1;
                i === yu.Variant && c <= r && 1 < this._mediaQuery.expectedSbCount && null != n && n.end < o.end && (e || n.end - n.start < c) && (h = !0);
                let p, f = null,
                    m = NaN;
                if (this._mediaQuery.isIframeRate && i === yu.Variant && a.iframesOnly) {
                    const g = function(e, t, i) {
                        e = i.nextFragment(a.fragments, (null == e ? void 0 : e.fragments) || [], t, u);
                        if (!e) return null;
                        var {
                            frag: t,
                            newMediaRootTime: e
                        } = e;
                        return {
                            foundFrag: {
                                timelineOffset: t.iframeMediaStart,
                                mediaFragment: t
                            },
                            nextDisco: NaN,
                            newMediaRootTime: e
                        }
                    }(t[yu.AltAudio], this._mediaQuery.desiredRate, this._iframeMachine);
                    if (g) {
                        ({
                            foundFrag: f,
                            nextDisco: m,
                            newMediaRootTime: p
                        } = g);
                        const i = f.mediaFragment;
                        i.discoSeqNum !== this._discoSeqNum && this._updateAnchor(i.discoSeqNum, t)
                    }
                } else {
                    const g = this._anchorMSNs[i];
                    ({
                        foundFrag: f,
                        nextDisco: m,
                        newMediaRootTime: p
                    } = Ig(u, this._discoSeqNum, g, a, l))
                }
                return h && this._rootQuery.getInitPTS(null == f ? void 0 : f.mediaFragment.discoSeqNum) ? ly.noopResult : {
                    foundFrag: f,
                    nextDisco: m,
                    newMediaRootTime: p
                }
            }
            _updateAnchorForType(e, t) {
                var i, r, n, s, a;
                if (!t) return this._anchorMSNs[e] = NaN, void(this._avDetails[e] = null);
                ne(this._discoSeqNum) ? (a = this._discoSeqNum, a = null !== (s = null == (n = (r = t.fragments, i = a, r.find(e => e.discoSeqNum === i))) ? void 0 : n.mediaSeqNum) && void 0 !== s ? s : t.startSN, this._anchorMSNs[e] = a, {
                    mediaOptionId: r,
                    ptsKnown: n,
                    dateMediaTimePairs: s,
                    startSN: a,
                    endSN: t
                } = t, this._avDetails[e] = {
                    mediaOptionId: r,
                    ptsKnown: n,
                    dateMediaTimePairs: s,
                    startSN: a,
                    endSN: t
                }) : this.logger.warn("Trying to anchor with non-finite discoSeqNum")
            }
        }

        function dy(e, t, i, r, n) {
            r = null != r ? r : {
                start: e,
                end: e,
                len: 0
            };
            i = null !== (i = null == i ? void 0 : i.userInitiated) && void 0 !== i && i, n = null != t && t.iframesOnly ? 0 : n;
            return i || 0 === r.len ? e : r.end + n
        }
        ly.noopResult = {
            foundFrag: null,
            nextDisco: NaN
        };
        const uy = {
            name: "avpipe"
        };

        function cy(r) {
            const {
                config: o,
                rootPlaylistService: l,
                rootPlaylistQuery: d,
                mediaSink: e,
                gaplessInstance: t
            } = r, u = e.mediaQuery, i = ed(Bu.map(e => d.enabledMediaOptionSwitchForType$(e).pipe(Za(e => {})))).pipe(La(e => {
                if (!_u({
                        itemId: d.itemId,
                        mediaOptionId: e[gu.Variant].toId
                    })) throw new V(!0, `No valid variant enabled id:${e[gu.Variant].toId}`, $.NoValidAlternates);
                e = e.map(({
                    fromId: e,
                    toId: t
                }, i) => function(t, i, r, n, s) {
                    var a, o;
                    const {
                        rootPlaylistQuery: l,
                        rootPlaylistService: d,
                        mediaSink: u,
                        mediaParser: c,
                        config: h,
                        iframeMachine: p
                    } = t, f = u.mediaQuery;
                    if (!n || !s || n === s && (r === gu.AltAudio || !p.isStarted)) return Wu;
                    switch (r) {
                        case gu.Variant: {
                            n !== s && c.reset(gu.Variant);
                            const t = $u(r),
                                g = l.variantMediaOptionById(n),
                                y = l.variantMediaOptionById(s),
                                v = l.itemId;
                            if (null == y || null == g) return Wu;
                            var e = !y.iframes && p.isStarted;
                            if (g.iframes !== y.iframes || e) return u.toggleTrickPlaybackMode(y.iframes), e && (ne(u.mediaQuery.postFlushSeek) || (u.postFlushSeek = p.iframeClockTimeSeconds), p.stop()), u.pause(), (e ? u.flushAll(0, 1 / 0, !0) : u.flushData(t, 0, 1 / 0, !0)).pipe(Za(() => {
                                var e = u.mediaQuery.postFlushSeek;
                                ne(e) && d.setPendingSeek(v, e)
                            }));
                            if (!h.allowFastSwitchUp || y.iframes) return Wu;
                            var m = Dg(g).mediaOptionDetails;
                            if (null != m && null != y && g.bitrate < y.bitrate) {
                                const r = m.targetduration,
                                    n = Dg(y),
                                    s = n.mediaOptionDetails,
                                    d = n.mediaOptionDetailsEntity.lastUpdateMillis,
                                    c = f.getCurrentWaterLevelByType(t, h.maxBufferHole),
                                    p = function(e, t, i, r, n, s, a, o) {
                                        if (n.nextMaxAutoOptionId !== Lu.mediaOptionId && !Kg(s.getBandwidthEstimate())) return Number.POSITIVE_INFINITY;
                                        a = Gg(s.getBandwidthEstimate().avgBandwidth, a.abrBandWidthUpFactor, a.abrBandWidthFactor, s.bandwidthStatus.bandwidthSampleCount), s = ne(s.getPlaylistEstimate().avgPlaylistLoadTimeMs) ? s.getPlaylistEstimate().avgPlaylistLoadTimeMs : s.getBandwidthEstimate().avgLatencyMs, a = t.bitrate > e.bitrate ? a.bwUp : a.bwDown;
                                        return null == i || !i.liveOrEvent || i.ptsKnown && !Yg(i.totalduration, s, o) ? zg(t, i, r, a, s, o) : Number.POSITIVE_INFINITY
                                    }(g, y, s, r, l.abrStatus, i, h, d) + h.maxStarvationDelay,
                                    S = f.currentTime + p,
                                    b = null === (o = null === (a = f.sourceBufferEntityByType(t)) || void 0 === a ? void 0 : a.bufferedSegments) || void 0 === o ? void 0 : o.find(e => e.startPTS >= S);
                                let e;
                                if (b) {
                                    const t = b.endPTS - b.startPTS;
                                    e = b.startPTS + Math.min(Math.max(t - h.maxFragLookUpTolerance, .5 * t), .75 * t)
                                }
                                if (ne(e) && c >= p) return u.flushData(t, e, 1 / 0)
                            }
                        }
                        break;
                        case gu.AltAudio:
                            e = l, m = s, o = "Nah" === (a = n) ? null : e.alternateMediaOptionById(gu.AltAudio, a), o = Boolean(o && o.url), m = "Nah" === a ? null : e.alternateMediaOptionById(gu.AltAudio, m), m = Boolean(m && m.url), o && !m && (d.setEnabledMediaOptionSwitchContextByType(l.itemId, gu.AltAudio, s, void 0), u.resetMediaSource(f.currentTime)), c.reset(gu.AltAudio)
                    }
                    return Wu
                }(r, n, i, e, t));
                return Jr($i(!0), en(e).pipe(Zs(!1)))
            }), tc("mediaOptionSwitch.audiovideo.out")), n = Zf(d.itemId), s = r.logger.child(uy), a = new ly(s, l, d, u, r.iframeMachine, o);
            return ed([d.anchorTime$.pipe(tc("anchorTime.audiovideo.in")), i]).pipe(La(([i, e]) => e ? Ii : u.needData$(o.maxBufferHole, t.inGaplessMode).pipe(hr(e => {
                var t = [d.enabledMediaOptionSwitchContexts[gu.Variant], d.enabledMediaOptionSwitchContexts[gu.AltAudio]];
                return u.getSourceBufferInfoAction(e, i, t, o.maxBufferHole)
            }), _s(e => e ? fn($i(e).pipe(hy(r, a), my(r)), Gu(function(e) {
                const {
                    mediaSink: t,
                    rootPlaylistQuery: i,
                    rootPlaylistService: r
                } = e, n = t.mediaQuery, s = e.logger.child($g);
                return an((a = i, o = s, ed([n.fellBelowLowWater$, a.getInFlightFragByType$(gu.Variant)]).pipe(La(e => {
                    var [, t] = e;
                    if (!Zg(t)) return Ii;
                    const i = performance.now() - t.bwSample.trequest,
                        r = ey - i,
                        n = 1e3 * t.duration - i,
                        s = [Wu];
                    return 0 < r && s.push(bn(r)), 0 < n && s.push(bn(n)), an(...s).pipe(Zs(e))
                }), sa((e, [t, i]) => {
                    const r = Object.assign({}, e);
                    return t && (r.fragDownloadSlow = !0), ty(i, r, a, o)
                }, {
                    fragDownloadSlow: !1,
                    fragDownloadTooSlow: !1
                }), Ra({
                    fragDownloadSlow: !1,
                    fragDownloadTooSlow: !1
                }), Is(Jg))), function(r) {
                    const s = r.mediaSink.mediaQuery,
                        {
                            rootPlaylistQuery: e,
                            config: a
                        } = r;
                    return s.desiredRate$.pipe(La(t => 0 === t ? Ii : ed([e.getInFlightFragByType$(gu.Variant), e.mediaOptionListQueries[gu.Variant].preferredMediaOptionList$.pipe(hr(e => e.filter(Wm.bind(null, Wp(t)))))])), ao(100), La(e => {
                        const [t, i] = e;
                        if (!Zg(t) || i.findIndex(e => e.mediaOptionId === t.mediaOptionId) <= 0) return Ii;
                        var r = performance.now() - t.bwSample.trequest,
                            n = Vg(t.duration, a.maxStarvationDelay),
                            n = Math.min(1e3 * n, 500 * t.duration / s.playbackRate);
                        return bn(Math.max(0, n - r), 100).pipe(Zs(e))
                    })).pipe(sa((e, [t, i]) => function(t, i, r, e) {
                        let {
                            fragDownloadSlow: n,
                            fragDownloadTooSlow: s
                        } = t;
                        const {
                            config: a,
                            rootPlaylistService: o,
                            rootPlaylistQuery: l,
                            mediaSink: d,
                            statsService: u,
                            mediaLibraryService: c
                        } = e, h = e.logger.child($g), p = d.mediaQuery;
                        if (p.paused) return t;
                        e = i.bwSample;
                        if (!ne(e.tfirst)) return t;
                        const f = performance.now(),
                            m = f - e.trequest,
                            g = Vg(i.duration, a.maxStarvationDelay),
                            y = gu.Variant,
                            v = i.mediaOptionId,
                            S = l.variantMediaOptionById(v),
                            b = c.getQueryForOption(S),
                            T = S.bitrate,
                            E = Math.max(1, 8e3 * e.loaded / m),
                            I = 8 * ((ne(e.total) ? e.total : Math.max(e.loaded, Math.round(i.duration * T / 8))) - e.loaded) / E,
                            w = qg(p, a.maxBufferHole);
                        let A;
                        if (ne(w) && 0 < w && !ne(null === (O = p.seekTo) || void 0 === O ? void 0 : O.pos)) A = w;
                        else {
                            const N = m / 1e3;
                            A = N < g ? g - N : g
                        }
                        var O = n;
                        ({
                            fragDownloadSlow: n,
                            fragDownloadTooSlow: s
                        } = ty(i, t, l, h));
                        t = 2 * ((null === (t = b.mediaOptionDetails) || void 0 === t ? void 0 : t.targetduration) || i.duration);
                        if (!(w <= t && (I >= A || n))) return fg().getQuery().extendMaxTTFB && fg().setExtendMaxTTFB(0), {
                            fragDownloadSlow: n,
                            fragDownloadTooSlow: s
                        };
                        O || h.warn(`likely to stall ${ae({maxTimeToLoadSec:A,minSwitchDuration:t,stats:e,elapsedMs:m,remainingTimeSec:I,instantBw:E,bufferAheadSec:w,fragDownloadSlow:n})}`), n = !0, fg().getQuery().extendMaxTTFB || fg().setExtendMaxTTFB(6e5);
                        let k;
                        const C = i.itemId,
                            D = u.getQueryForItem(C),
                            M = D.getCombinedEstimate(),
                            x = Object.assign(Object.assign({}, M), {
                                avgBandwidth: E
                            }),
                            P = D.bandwidthStatus,
                            R = S.iframes,
                            L = I >= A && !R,
                            _ = Hg(0, r, R, l);
                        if (_ < 0) return {
                            fragDownloadSlow: n,
                            fragDownloadTooSlow: s
                        };
                        t = Math.max(_, r.findIndex(e => e && e.mediaOptionId === S.mediaOptionId));
                        if (L) {
                            let e = Wg(r, i.duration, _, t, A, R, x, P, 1, 1, a, l, b, p, h);
                            const F = Lu.mediaOptionId;
                            k = e.variantMediaOption !== F || (e = Wg(r, i.duration, _, t, I, R, x, P, 1, 1, a, l, b, p, h)).variantMediaOption !== F ? e.variantMediaOption : e.lowestCandidate
                        } else {
                            const N = Hg(0, r.slice(_, t).reverse(), R, l),
                                i = t - 1 - N;
                            (0 <= N || t === _) && (k = r[i].mediaOptionId)
                        }
                        if (null != k && k !== l.abrStatus.nextMaxAutoOptionId && o.setNextMaxAutoOptionId(C, k), L) throw h.warn(`loading too slow, abort fragment loading and switch to level ${k}`), u.setBandwidthSample(Object.assign(Object.assign({}, e), {
                            tfirst: e.tfirst || f,
                            tload: e.tload || f,
                            complete: !0,
                            mediaOptionType: y
                        })), s = !0, new fc({
                            mediaOptionType: y,
                            mediaOptionId: v
                        }, k, $.FragmentAbortError);
                        return {
                            fragDownloadSlow: n,
                            fragDownloadTooSlow: s
                        }
                    }(e, t, i, r), {
                        fragDownloadSlow: !1,
                        fragDownloadTooSlow: !1
                    }), Ra({
                        fragDownloadSlow: !1,
                        fragDownloadTooSlow: !1
                    }), Is(Jg))
                }(e)).pipe(Ra({
                    fragDownloadSlow: !1,
                    fragDownloadTooSlow: !1
                }), sa((e, t) => ({
                    fragDownloadSlow: e.fragDownloadSlow || t.fragDownloadSlow,
                    fragDownloadTooSlow: e.fragDownloadTooSlow || t.fragDownloadTooSlow
                })), Is(Jg), hr(e => (r.setFragLoadSlow(i.itemId, e), !1)), Vn(e => {
                    if (e instanceof fc) {
                        const e = {
                            fragDownloadSlow: !0,
                            fragDownloadTooSlow: !0
                        };
                        return r.setFragLoadSlow(i.itemId, e), $i(!0)
                    }
                    return Vi(e)
                }));
                var a, o
            }(r), e => e)).pipe(Ds(1), Vs(() => {
                Bu.forEach(e => {
                    l.updateInflightFrag(d.itemId, e, null, null, null)
                })
            })) : Ii))), hr(() => {
                if (!d.getEntity(d.itemId).manualMode) {
                    let e = Mm.None;
                    var i, r, n, s;
                    i = Af(), r = u, n = o, s = null == r ? void 0 : r.clientWidth, a = null == r ? void 0 : r.clientHeight, r = "object" == typeof window && window.devicePixelRatio ? window.devicePixelRatio : 1, a = s && a ? {
                        width: s * r,
                        height: a * r
                    } : void 0, r = (r = (null === (r = i.getQuery()) || void 0 === r ? void 0 : r.viewportInfo) || {}) && a && (r.width !== a.width || r.height !== a.height), n.useViewportSizeForLevelCap && r && (i.updateViewportInfo(a), 1) && (e = Mm.PreferredListChanged);
                    let t = !1;
                    var a = d.enabledVariantMediaOption;
                    ! function(e, t) {
                        const i = l.logger.child($g),
                            r = e.abrStatus,
                            n = r.fragDownloadSlow || r.fragDownloadTooSlow,
                            s = ne(null === (t = t.seekTo) || void 0 === t ? void 0 : t.pos);
                        return n && !r.fragDownloadTooSlow && s ? (i.warn("could be ignoring low bandwidth due to seek"), 0) : n
                    }(d, u) ? u.playbackStarted && function(e, t) {
                        const i = Zf(t.itemId),
                            r = i.getBandwidthEstimate(),
                            n = t.abrStatus;
                        if (Kg(r)) {
                            var t = (null === (t = i.bandwidthStatus) || void 0 === t ? void 0 : t.bandwidthSampleCount) || 0,
                                t = Gg(r.avgBandwidth, e.abrBandWidthUpFactor, e.abrBandWidthFactor, t)["bwUp"];
                            return t > n.highBWTrigger
                        }
                    }(o, d) && (e = Mm.HighBandwidth, l.setNextMinAutoOptionId(a.itemId, a.mediaOptionId)): (e = Mm.LowBandwidth, d.nextMaxAutoOptionId === Lu.mediaOptionId && (l.setNextMaxAutoOptionId(a.itemId, a.mediaOptionId), t = !0)), iy(e, o, d, u, l), t ? l.setNextMaxAutoOptionId(a.itemId, Lu.mediaOptionId) : e === Mm.HighBandwidth && l.setNextMinAutoOptionId(a.itemId, Lu.mediaOptionId)
                }
            }), Vs(() => {}))
        }
        const hy = (r, n) => e => {
            const {
                rootPlaylistQuery: t,
                mediaSink: a
            } = r, i = r.logger.child(uy);
            return e.pipe(ji(tr), bo(t.enabledMediaOptionKeys$), La(([s, e]) => En(py(s, gu.Variant, r, e).pipe(Za(e => {
                var e = e.detailsEntity;
                if (!e.mediaOptionDetails.liveOrEvent || e.mediaOptionDetails.ptsKnown) {
                    const t = e.playlistDuration,
                        i = (null === (e = s.bufferInfoTuple[0]) || void 0 === e ? void 0 : e.buffered.end) || 0,
                        r = (null === (e = s.bufferInfoTuple[1]) || void 0 === e ? void 0 : e.buffered.end) || 0,
                        n = Math.max(i, r);
                    a.msDuration = ne(a.msDuration) ? Math.max(a.msDuration, t, n) : t
                }
            })), py(s, gu.AltAudio, r, e)).pipe(hr(e => ({
                action: s,
                detailsAndContext: e
            })))), La(({
                action: e,
                detailsAndContext: t
            }) => function t(n, s, a, i, d) {
                var e;
                const {
                    mediaSink: u,
                    iframeMachine: c,
                    rootPlaylistQuery: o
                } = a, r = [d[gu.Variant].detailsEntity.mediaOptionDetails, null === (e = null === (e = d[gu.AltAudio]) || void 0 === e ? void 0 : e.detailsEntity) || void 0 === e ? void 0 : e.mediaOptionDetails];
                let l = s.getNextFragments(i, r, n);
                const h = l.reduce((e, t) => Math.max(e, ne(null == t ? void 0 : t.newMediaRootTime) ? t.newMediaRootTime : -1 / 0), -1 / 0);
                return ne(h) && (u.seekTo = h, l = [null, null]), l.every(e => null == (null == e ? void 0 : e.foundFrag)) ? $i(null) : En(...l.map((t, l) => {
                    if (t && null != t.foundFrag) {
                        const i = t.foundFrag["mediaFragment"],
                            r = _g(a, i.keyTagInfo, {
                                itemId: i.itemId,
                                mediaOptionId: i.mediaOptionId
                            });
                        let e = Lg(a, l, t).pipe(Za(e => {
                            const t = e[1],
                                i = d[l].switchContext;
                            t.switchPosition = null == i ? void 0 : i.switchPosition;
                            const r = null !== (e = null == i ? void 0 : i.userInitiated) && void 0 !== e && e,
                                n = u["mediaQuery"],
                                {
                                    desiredRate: s,
                                    isIframeRate: a
                                } = n,
                                o = a && c.isStarted && s && s < 0 && s !== c.iframeRate;
                            (r || o) && (t.flushBeforeAppend = {
                                start: 0,
                                end: Number.POSITIVE_INFINITY
                            })
                        }));
                        return e = l === gu.Variant ? e.pipe(Za(e => {
                            const t = function(t, i, r, n) {
                                if (!r) return null;
                                const {
                                    rootPlaylistService: s,
                                    rootPlaylistQuery: a
                                } = i, o = a.itemId, l = r[1], d = l.iframe;
                                let u = a.getInitPTS(n);
                                if (null == u || !d && u.iframeMode) {
                                    const i = null !== (r = l.startDtsTs) && void 0 !== r ? r : null;
                                    if (null == i) return t.warn("updateInitPTS: Variant data missing."), null;
                                    let e = null !== (t = l.timelineOffset) && void 0 !== t ? t : 0;
                                    d && (e = null !== (t = l.iframeOriginalStart) && void 0 !== t ? t : 0), i.timescale < 1e3 && (i.timescale = 1e3 * i.timescale, i.baseTime = 1e3 * i.baseTime);
                                    const a = B(e, i.timescale),
                                        c = {
                                            baseTime: i.baseTime - a.baseTime,
                                            timescale: i.timescale
                                        };
                                    s.setInitPTS(o, n, i, e, c, d), u = {
                                        variantDTS: i,
                                        timelineOffset: e,
                                        offsetTimestamp: c,
                                        iframeMode: d
                                    }
                                }
                                return u
                            }(n, a, e, s.discoSeqNum);
                            fy(n, a, e, t)
                        })) : en([e, Gu(o.initPTS$(s.discoSeqNum), e => {
                            const t = u.mediaQuery.isIframeRate;
                            return null != e && (t || !e.iframeMode)
                        })]).pipe(hr(([e, t]) => (fy(n, a, e, t), e))), en([r, e]).pipe(hr(e => e[1]))
                    }
                    return $i(null)
                })).pipe(hr(e => function(g, t, e, i) {
                    const {
                        rootPlaylistQuery: r,
                        mediaSink: n,
                        config: y
                    } = t, v = n.mediaQuery, s = v.isIframeRate, a = r.getInitPTS(e);
                    if (null == a) return g.warn("No initPTS info found"), null;
                    const o = i[gu.Variant],
                        l = null == o ? void 0 : o[1];
                    if (l && l.iframe !== s) return g.warn(`frag mediaSeqNum ${l.mediaSeqNum} discoSeqNum ${l.discoSeqNum} mediaOptionId ${l.mediaOptionId} doesn't match mediaSink's iframeMode ${s}; discard`), null;
                    const S = [null, null];
                    if (o) {
                        const [g, t] = o;
                        let e = a.offsetTimestamp;
                        if (s) {
                            const g = t.startDtsTs,
                                i = B(t.timelineOffset, g.timescale);
                            e = {
                                baseTime: g.baseTime - i.baseTime,
                                timescale: g.timescale
                            }
                        }
                        S[yu.Variant] = {
                            initSeg: g,
                            dataSeg: t,
                            offsetTimestamp: e
                        }
                    }
                    const d = i[gu.AltAudio];
                    if (null != d) {
                        const [g, t] = d;
                        S[yu.AltAudio] = {
                            initSeg: g,
                            dataSeg: t,
                            offsetTimestamp: a.offsetTimestamp
                        }
                    }
                    const u = S.map((e, t) => {
                        const i = null == e ? void 0 : e.dataSeg;
                        if (i) {
                            const {
                                itemId: r,
                                mediaOptionId: n,
                                mediaSeqNum: s,
                                discoSeqNum: a,
                                startPts: o,
                                endPts: l,
                                duration: d,
                                iframe: u
                            } = i, c = e["offsetTimestamp"], h = b(o, c), p = b(l, c), f = Dg(i), m = S[0];
                            return m && m.dataSeg.dropped || i.flushBeforeAppend || !((null === (e = null === (e = v.getBufferInfo(h, y.maxBufferHole)[t]) || void 0 === e ? void 0 : e.buffered) || void 0 === e ? void 0 : e.len) >= p - h) ? {
                                start: h,
                                duration: u ? d : p - h,
                                itemId: r,
                                mediaOptionId: n,
                                mediaSeqNum: s,
                                discoSeqNum: a,
                                targetDuration: f.mediaOptionDetails.targetduration
                            } : (g.warn(`${Nu[t]} Discarding append due to complete overlap with existing buffer`), S[t] = null)
                        }
                        return null
                    });
                    return u.every(e => !e) ? null : {
                        appendDataTuple: S,
                        inFlightFrags: u,
                        initPTSInfo: a
                    }
                }(n, a, s.discoSeqNum, e)), La(e => {
                    if (e) return $i(e); {
                        const e = function(e, r) {
                            const n = e.enabledMediaOptionKeys,
                                s = [null, null],
                                a = [null, null];
                            return Bu.map(e => {
                                var t;
                                if (_u(n[e])) {
                                    const i = Dg(n[e]).mediaOptionDetailsEntity;
                                    a[e] = null === (t = i.mediaOptionDetails) || void 0 === t ? void 0 : t.ptsKnown, s[e] = {
                                        detailsEntity: i,
                                        switchContext: null === (e = r[e]) || void 0 === e ? void 0 : e.switchContext
                                    }
                                }
                            }), s
                        }(o, d);
                        return t(n, s, a, i, e)
                    }
                }))
            }(i, n, r, e, t)), tc("mediaProducerEpic.emit"))
        };

        function py(e, i, t, r) {
            const {
                rootPlaylistQuery: n,
                mediaLibraryService: s,
                config: a
            } = t, o = r[i];
            if (t.logger.child({
                    name: Nu[i]
                }), !o || "Nah" === o.mediaOptionId) return $i({
                detailsEntity: null,
                switchContext: null
            });
            const l = s.getQueryForOption(o);
            return Mr([$i(e), l.mediaOptionDetailsEntity$.pipe(Is((e, t) => (null == e ? void 0 : e.lastUpdateMillis) === (null == t ? void 0 : t.lastUpdateMillis)), ln(e => {
                var t = null == e ? void 0 : e.mediaOptionDetails;
                if (!t) return !0;
                var i = performance.now(),
                    r = e.lastUpdateMillis || i,
                    e = t.liveOrEvent,
                    t = t.targetduration;
                return !e || i - r < a.livePlaylistUpdateStaleness * t * 1e3
            }))]).pipe(ln(([, e]) => {
                if (i === gu.AltAudio && !n.altMediaOptionHasValidUrl(i, o.mediaOptionId)) return !0;
                var t = null == e ? void 0 : e.mediaOptionDetails;
                return null != t && (e = null !== (e = e.lastUpdateMillis) && void 0 !== e ? e : 0, !t.liveOrEvent || !t.ptsKnown || !Yg(null == t ? void 0 : t.totalduration, 0, e))
            }), Ds(1), bo(n.enabledMediaOptionSwitchContextsByType$(i)), hr(([
                [, e], t
            ]) => ({
                detailsEntity: e,
                switchContext: t
            })))
        }

        function fy(e, t, i, r) {
            const {
                mediaLibraryService: n,
                rootPlaylistQuery: s,
                mediaSink: a
            } = t, o = s.itemId;
            null != r && (a.mediaQuery.isIframeRate || !r.iframeMode ? i && !ne(i[1].iframeMediaDuration) && (performance.now(), n.updatePTSDTS(o, i[1].mediaOptionId, r, i[1])) : e.warn("updatePTSDTS iframeMode mismatch"))
        }
        const my = t => e => {
            const {
                rootPlaylistQuery: g,
                rootPlaylistService: y,
                mediaSink: v,
                legibleSystemAdapter: o,
                statsService: l,
                rtcService: d
            } = t;
            return e.pipe(tc("mediaConsumerEpic.in"), La(e => {
                if (!e) return $i(!1);
                const {
                    appendDataTuple: r,
                    inFlightFrags: m,
                    initPTSInfo: t
                } = e, i = t["offsetTimestamp"];
                return m.forEach((e, t) => {
                    e && y.updateInflightFrag(e.itemId, t, e, "appending", null)
                }), r.forEach(e => {
                    e && (e = e.dataSeg, o.addLegibleSamples(i, e.captionData, e.id3Samples, e.endPts))
                }), v.appendData(r, (e, t, i, r, n) => {
                    var s, a, o, l, d, u, c, h, p, f = null !== (f = m[t].targetDuration) && void 0 !== f ? f : 10;
                    return s = v, a = e, o = t, l = i, d = f, u = r, c = g, h = y, p = n, e => e.pipe(Za(() => {
                        h.updateConsecutiveTimeouts(c.itemId, o, !1, "append")
                    }), va(e => e.pipe(jr((e, t) => {
                        var i = e instanceof df && e.isTimeout;
                        if (h.updateConsecutiveTimeouts(c.itemId, o, i, "append"), i) return function(e, t, i, r, n, s, a, o) {
                            let l = {
                                errorAction: Cm.SendAlternateToPenaltyBox,
                                errorActionFlags: 0
                            };
                            var d = s.getCurrentWaterLevel(i.maxBufferHole),
                                u = d < i.almostDryBufferSec;
                            let c = NaN;
                            s = i.appendErrorMaxRetry, i = a.rootPlaylistEntity.errorsByType[r].timeouts.append;
                            u && s <= i || s <= t ? l.errorAction = Cm.SendEndCallback : c = 1e3 * d;
                            s = {
                                retryDelayMs: c,
                                maxNumRetry: s,
                                maxRetryDelayMs: c
                            };
                            return l = Jm(l, !1, e.response.code, n, r, a, o), rg(e, t, s, l, a, o, r, n).pipe()
                        }(e, t, u, o, l, p, c, h);
                        if (e instanceof uf) return function(e, t, i, r, n, s, a, o, l, d) {
                            var u = t.type,
                                u = o.getCurrentWaterLevelByType(u, n.maxBufferHole);
                            if (u >= n.almostDryBufferSec && !o.isIframeRate) {
                                const t = 1e3 * r,
                                    n = {
                                        errorAction: Cm.RetryRequest,
                                        errorActionFlags: 0
                                    };
                                return 1e3 * u < t && (d.hasFallbackMediaOptionTuple(l, s, a, !1) ? n.errorAction = Cm.SendAlternateToPenaltyBox : n.errorAction = Cm.SendEndCallback), rg(e, i, {
                                    retryDelayMs: t,
                                    maxNumRetry: 1 / 0,
                                    maxRetryDelayMs: t
                                }, n, l, d, s, a)
                            }
                            return i < n.appendErrorMaxRetry ? t.remove(0, Number.POSITIVE_INFINITY) : (e.fatal = !0, Vi(e))
                        }(e, a, t, d, u, o, l, p, c, h);
                        if (e instanceof hf) {
                            const {
                                mediaOptionType: a,
                                mediaOptionId: o
                            } = e;
                            return oy(e, a, o, s, h, c)
                        }
                        throw e
                    }))))
                }, g.highestVideoCodec).pipe(hr(e => {
                    m.forEach((e, t) => {
                        e && y.updateInflightFrag(e.itemId, t, e, "appended", null)
                    });
                    var t = e.filter(e => (null == e ? void 0 : e.fragmentType) === gu.Variant);
                    t.length && (l.setBufferMetric(t[0]), null == d || d.handleFragBuffered(t[0]));
                    e = r[yu.AltAudio];
                    if (null !== (t = null == e ? void 0 : e.dataSeg) && void 0 !== t && t.flushBeforeAppend || ne(null === (t = null == e ? void 0 : e.dataSeg) || void 0 === t ? void 0 : t.switchPosition)) {
                        const {
                            itemId: i,
                            mediaOptionId: r
                        } = e.dataSeg;
                        y.setEnabledMediaOptionSwitchContextByType(i, gu.AltAudio, r, void 0)
                    }
                    return !0
                }), (n = v, s = y, a = g, e => e.pipe(Vn(e => {
                    if (e instanceof lf) {
                        var {
                            mediaOptionType: t,
                            mediaOptionId: i
                        } = e;
                        return oy(e, t, i, n, s, a)
                    }
                    throw e
                }))));
                var n, s, a
            }))
        };

        function gy(d, u, c, h, p, f) {
            return u = u.child({
                name: "seek"
            }), e => e.pipe(La((e, t) => {
                if (null == e) return Ii;
                var i, r, n, s, a, o, l = c.mediaQuery.seekTo$.pipe(ka(1), Kp());
                return i = 0 === t, r = d, n = u, s = p, t = f, (null == (e = e) ? Ii : e instanceof Date ? (a = e, o = t, s.enabledMediaOptionByType$(gu.Variant).pipe(La(e => o.getQueryForOption(e).mediaOptionDetails$), hr(e => function(e, t) {
                    if (!e || 0 === e.length) return 0;
                    const i = [...e].sort((e, t) => t[0] - e[0]),
                        r = t.getTime(),
                        n = null !== (t = i.find(([e]) => r >= e)) && void 0 !== t ? t : i[i.length - 1],
                        [s, a] = n,
                        o = a + (r - s) / 1e3;
                    return Math.max(0, o)
                }(e.dateMediaTimePairs, a)), Ds(1))) : function(r, e, a, n, t, o) {
                    let i = n.enabledMediaOptionByType$(gu.Variant).pipe(La(e => t.getQueryForOption(e).mediaOptionDetails$), ln(e => ne(null == e ? void 0 : e.totalduration)), Ds(1), hr(s => {
                        var e = !s.liveOrEvent,
                            t = s.totalduration,
                            i = n.itemStartOffset;
                        return e ? ne(r) ? 0 <= r ? r : i + (t + r) : i + (ne(s.startTimeOffset) ? s.startTimeOffset : 0) : !ne(r) || r < 0 || 0 === r && a.liveEdgeForZeroStartPositon ? yg(0, s, a) : function(e, t) {
                            let i = e;
                            var r = s.fragments[0].start,
                                n = s.fragments[s.fragments.length - 1].start + s.fragments[s.fragments.length - 1].duration;
                            return e < r ? i = r : n < e && (i = yg(0, s, a)), (e < r || n < e) && t.warn(`[live] sanitizeLiveSeek seekTo:${se(e,3)}, sanitizedSeek:${se(i,3)}, liveWindowStart:${se(r,3)}, liveWindowEnd:${se(n,3)}`), i
                        }(r, o)
                    }));
                    return e && (i = i.pipe(Za(e => {}))), i
                }(e, i, r, s, t, n)).pipe(Vs(() => {
                    h.setPendingSeek(p.itemId, void 0)
                }), Va(l))
            }), Za(e => {
                ne(e) && (c.seekTo = e)
            }))
        }

        function yy(e) {
            const {
                logger: r,
                rootPlaylistService: n,
                rootPlaylistQuery: t
            } = e, s = t.itemId;
            return e => e.pipe(va(e => e.pipe(jr(e => {
                if (r.error(`Got error in pipeline ${e.message} fatal:${null==e?void 0:e.fatal} handled:${null==e?void 0:e.handled}`), !(e instanceof p) || e.fatal) throw e;
                return e.handled ? (t = n, i = s, bn(0).pipe(hr(() => {
                    t.updateEnabledMediaOptions(i)
                }))) : Ii;
                var t, i
            }))))
        }
        const vy = () => e => e.pipe(tc("mediaFragmentPipelineEpic.in"), La(i => {
                if (!i) return Ii;
                const {
                    logger: e,
                    config: t,
                    platformService: r,
                    rootPlaylistService: n,
                    rootPlaylistQuery: s,
                    keySystemAdapter: a,
                    mediaSink: o,
                    mediaParser: l,
                    gaplessInstance: d,
                    mediaLibraryService: u
                } = i, c = s["itemId"], h = o["mediaQuery"], p = a.keyStatusChange$.pipe((f = i, e => e.pipe(La(e => {
                    const {
                        decryptdata: t,
                        status: i,
                        error: r
                    } = e, n = f["rootPlaylistQuery"];
                    if ("needs-renewal" === i) return _g(f, t, null);
                    if ("error" !== i || !(r instanceof gc || r instanceof mc) || r.handled) return Ii; {
                        const {
                            rootPlaylistService: e,
                            keySystemAdapter: t
                        } = f;
                        return og(r, 0, null, e, n, t.ksQuery)
                    }
                }), La(() => Ii))));
                var f;
                const m = r.getQuery(),
                    g = m.displaySupportsHdr$.pipe(Is(), La(e => (n.setHDRPreference(c, e, !0), Ii))),
                    y = m.viewportInfo$.pipe(Is((e, t) => e && t && e.width === t.width && e.height === t.height), Za(e => {
                        t.useViewportSizeForLevelCap && n.setViewportInfo(c, e)
                    }), $a(Ii)),
                    v = ed([s.hdrMode$.pipe(Is()), s.maxHdcpLevel$.pipe(Is())]).pipe(La(([]) => (d.inGaplessMode || 0 !== s.itemStartOffset || (o.resetMediaSource(), l.reset()), Ii))),
                    S = an(function(i) {
                        const {
                            rootPlaylistQuery: t,
                            mediaSink: r
                        } = i, e = t.enabledMediaOptions$.pipe(Kp(), Za(e => {
                            e = e[gu.AltAudio], e = _u(e) && null != (null == e ? void 0 : e.url) ? 2 : 1;
                            r.setExpectedSbCount(e)
                        })), n = en([t.enabledMediaOptionByType$(gu.Variant).pipe(ln(e => _u(e)), La(e => Dg(e).mediaOptionDetails$), Ds(1)), Gu(r.mediaQuery.updating$, e => e)]).pipe(ji(tr), Za(([e]) => {
                            r.bufferMonitorTargetDuration = e.targetduration
                        })), s = Fu.map(e => t.enabledMediaOptionByType$(e).pipe(tc("mediaOptionRetrieve.switch"), La(t => {
                            if (!t || !t.url || !_u(t)) return Ii;
                            var e = r.mediaQuery.desiredRate$.pipe(hr(e => 0 !== e), Is());
                            return Mg(i, t).pipe(tc("mediaOptionRetrieve.first"), $a(e), La(e => e ? function e(t, i) {
                                const r = t.mediaLibraryService;
                                return function(e) {
                                    if (!e) return Ii;
                                    var {
                                        mediaOptionDetails: t,
                                        lastUpdateMillis: i,
                                        unchangedCount: e
                                    } = e;
                                    if (null == t || !t.liveOrEvent) return Ii;
                                    if (bg(t, i)) return bn(0).pipe(Za(() => {}));
                                    let r = Sg(t);
                                    return 0 < e && (r /= 2, r = Math.max(r, 5e3)), r -= performance.now() - i, r += 0, r = Math.max(1e3, Math.round(r)), bn(r).pipe(Za(() => {}))
                                }(r.getQueryForOption(i).mediaOptionDetailsEntity).pipe(La(() => Mg(t, i, !1, !0)), La(() => e(t, i)))
                            }(i, t) : Ii))
                        })));
                        return an(e, n, an(...s)).pipe($a(Ii))
                    }(i), cy(i), function(t) {
                        const {
                            rootPlaylistQuery: i,
                            mediaSink: e
                        } = t;
                        return Gu(e.mediaQuery.mediaElementEntity$, e => e).pipe(La(e => i.anchorTime$.pipe(tc("anchorTime.subtitle.in"), ln(e => ne(null == e ? void 0 : e.pos)), (s => e => {
                            const {
                                rootPlaylistQuery: i,
                                rootPlaylistService: t,
                                legibleSystemAdapter: r
                            } = s, n = i.enabledAlternateMediaOptionByType(gu.Subtitle);
                            if (r.gotTracks) r.selectedTrack = n;
                            else {
                                const s = i.preferredMediaOptions[gu.Subtitle];
                                r.setTracks(s, n, i.getDisabledMediaOption(gu.Subtitle))
                            }
                            return e.pipe(tc("subtitleEpic.select.in"), La(() => an(r.nativeSubtitleTrackChange$.pipe(La(e => (e.mediaOptionId !== r.selectedMediaOption.mediaOptionId && t.setEnabledMediaOptionByType(e.itemId, gu.Subtitle, e), Ii))), i.enabledMediaOptionByType$(gu.Subtitle).pipe(hr(e => {
                                const t = _u(e) ? i.alternateMediaOptionById(gu.Subtitle, e.mediaOptionId) : e;
                                return r.selectedMediaOption = t, t
                            })).pipe(Is((e, t) => (null == e ? void 0 : e.mediaOptionId) === (null == t ? void 0 : t.mediaOptionId))))), tc("subtitleEpic.select.emit"))
                        })(t), (s => e => {
                            const {
                                mediaSink: t,
                                rootPlaylistQuery: i,
                                legibleSystemAdapter: r,
                                logger: n
                            } = s;
                            return e.pipe(tc("subtitleEpic.process.in"), La(e => {
                                if (!e || !e.url || !_u(e)) return $i([null, null, null]);
                                return ed([Dg(e).mediaOptionDetails$, i.discoSeqNum$.pipe(ln(e => ne(e)))]).pipe(La(([e, t]) => ((i, r, e) => {
                                    const {
                                        legibleSystemAdapter: n,
                                        rootPlaylistQuery: t
                                    } = i;
                                    return t.initPTS$(e).pipe(La(t => !t || t.iframeMode ? on : n.findFrags$(r, e).pipe(La(e => r && (null == e ? void 0 : e.foundFrags) ? Sy(i, t.offsetTimestamp, e, r) : Wu))))
                                })(s, e, t)))
                            }), tc("subtitleEpic.process.emit"))
                        })(t))))
                    }(i), p).pipe(Zs(void 0), yy(i)),
                    b = h.seekTo$.pipe(ln(e => ne(null == e ? void 0 : e.pos)), Is((e, t) => Math.abs(e.pos - t.pos) < Number.EPSILON), La(e => (n.setAnchorTime(c, e), Ii))),
                    T = h.gotPlaying$.pipe(ln(e => e), Za(e => {
                        s.mediaOptionListQueries[gu.Variant].filteredMediaOptionList.forEach(e => {})
                    }), Ds(1), $a(Ii));
                return an(s.pendingSeek$.pipe(gy(t, e, o, n, s, u)), function() {
                    const {
                        config: n,
                        mediaSink: s,
                        rootPlaylistQuery: e,
                        mediaLibraryService: t
                    } = i, a = (i.logger.child({
                        name: "live"
                    }), s.mediaQuery);
                    return e.enabledMediaOptionByType$(gu.Variant).pipe(ln(_u), La(e => t.getQueryForOption(e).mediaOptionDetailsEntity$.pipe(ln(e => {
                        var t;
                        return (null === (t = null == e ? void 0 : e.mediaOptionDetails) || void 0 === t ? void 0 : t.ptsKnown) && e.mediaOptionDetails.liveOrEvent
                    }), Is((e, t) => (null == e ? void 0 : e.lastUpdateMillis) === (null == t ? void 0 : t.lastUpdateMillis)))), hr(e => {
                        var t = e.mediaOptionDetails,
                            i = a.currentTime;
                        a.msDuration < e.playlistDuration ? s.msDuration = e.playlistDuration : ne(s.msDuration) && (s.msDuration = s.msDuration + n.livePlaylistDurationNudge);
                        let r = NaN;
                        return i < vg(i, t, e.lastUpdateMillis, n.maxBufferHole, a) && (r = yg(t.fragments[0].start, t, n), s.seekTo = r), r
                    }))
                }(), b, S, g, y, v, function() {
                    const e = i.mediaSink.mediaQuery;
                    return Mr([$i(i), e.desiredRate$.pipe(ha())]).pipe(La(([e, [t, i]]) => {
                        const {
                            rootPlaylistQuery: s,
                            rootPlaylistService: r,
                            config: a,
                            mediaSink: n,
                            mediaLibraryService: o,
                            statsService: l
                        } = e, d = n.mediaQuery;
                        if (Wp(t) !== Wp(i)) iy(Mm.IframeModeChange, a, s, d, r);
                        else if (0 === t && 1 === i && !Bu.every(e => {
                                const t = s.enabledMediaOptionKeys[e],
                                    i = o.getQueryForOption(t),
                                    r = l.getQueryForItem(s.itemId),
                                    n = i.mediaOptionDetailsEntity;
                                return !(null !== (e = null == n ? void 0 : n.mediaOptionDetails) && void 0 !== e && e.ptsKnown) || d.canContinuePlaybackWithoutGap(n.mediaOptionDetails, n.lastUpdateMillis, r.getPlaylistEstimate(), a.maxBufferHole)
                            })) return n.pause(), n.flushAll(0, 1 / 0, !0);
                        return Ii
                    }), $a(Ii))
                }(), function(e) {
                    const t = e.rootPlaylistQuery,
                        i = e.mediaSink.mediaQuery,
                        r = t.enabledMediaOptionByType$(gu.Variant);
                    return Mr([$i(e), i.desiredRate$.pipe(ha())]).pipe(Is((e, t) => e[1] === t[1]), bo(r), La(([
                        [e, [t, i]], r
                    ]) => {
                        t = Wp(t), i = Wp(i);
                        if (t === i) return Ii;
                        const n = e["rootPlaylistService"];
                        return i && e.rootPlaylistQuery.nextMaxAutoOptionId === Lu.mediaOptionId && n.setNextMaxAutoOptionId(e.rootPlaylistQuery.itemId, r.mediaOptionId), Ii
                    }))
                }(i), T).pipe(tc("mediaFragmentPiplineEpic.emit"), Zs(void 0))
            })),
            Sy = (r, e, t, i) => {
                const n = r.legibleSystemAdapter,
                    s = t.foundFrags;
                return Fr(s).pipe(hr(t => {
                    return ((e, t, i) => {
                        const {
                            rootPlaylistQuery: r,
                            legibleSystemAdapter: n
                        } = e;
                        return Zr(() => ((t, i) => Rg(e, i, !1, !1).pipe(hr(e => ({
                            initPTS: t,
                            data: e,
                            mediaFragment: i
                        })), tc("retrieveSubtitleFragmentCacheEntity.emit")))(t, i).pipe(hr(({
                            initPTS: e,
                            data: t,
                            mediaFragment: i
                        }) => ({
                            frag: i,
                            cueRange: function(e, t, i, r, n) {
                                if (e) return n.processSubtitleFrag(e, t, i, r)
                            }(r.enabledAlternateMediaOptionByType(gu.Subtitle), i, e, t, n)
                        }))))
                    })(r, e, t).pipe((i = e => n.checkReadyToLoadNextSubtitleFragment$(t, s).pipe(ln(e => e)), function(e) {
                        return e.lift(new gs(i))
                    }));
                    var i
                }), Yr(r.config.vttConcurrentLoadCount), Za(e => {
                    n.reviewParsedFrag(e, t, i) !== kp.CloseEnough && r.legibleSystemAdapter.tryAgain$.next(!0)
                }))
            },
            by = (e, t) => {
                let i, r = "";
                return i = e.videoCodec && e.audioCodec ? (r = `${e.videoCodec}, ${e.audioCodec}`, t = null != t ? t : "video/mp4", "audiovideo") : e.videoCodec ? (r = `${e.videoCodec}`, t = null != t ? t : "video/mp4", "video") : (r = `${null!==(e=e.audioCodec)&&void 0!==e?e:""}`, t = null != t ? t : "audio/mp4", "audio"), {
                    mimeType: `${t};codecs=${r}`,
                    codec: r,
                    container: t,
                    type: i
                }
            };
        class Ty {
            constructor(e, t, i) {
                this.config = e, this.logger = t, this.demuxClient = i, this.typeSupported = {
                    mp4: MediaSource.isTypeSupported("video/mp4"),
                    mpeg: MediaSource.isTypeSupported("audio/mpeg"),
                    mp3: MediaSource.isTypeSupported('audio/mp4; codecs="mp3"'),
                    ac3: MediaSource.isTypeSupported('audio/mp4; codecs="ac-3"'),
                    ec3: MediaSource.isTypeSupported('audio/mp4; codecs="ec-3"')
                }, this.demuxers = [], this.lastInitFrags = [], this.lastFrags = []
            }
            parseInitSegment(h, e) {
                return this.getDemuxerInfo(h, this.lastInitFrags, e, this.demuxClient).pipe(La(({
                    demuxer: e,
                    contiguous: t,
                    trackSwitch: i,
                    discontinuity: r,
                    accurateTimeOffset: n
                }) => {
                    const s = h["frag"],
                        {
                            keyTagInfo: a,
                            start: o,
                            mediaOptionType: l
                        } = s;
                    if (this.lastInitFrags[l] = s, h.initSegment) {
                        const e = ze.remuxInitSegment(new Uint8Array(h.initSegment), this.logger, a),
                            t = Ze.parseInitSegment(e),
                            {
                                mimeType: i,
                                type: r,
                                codec: n,
                                container: s
                            } = by(t);
                        return $i({
                            moovData: t,
                            mimeType: i,
                            track: {
                                type: r,
                                codec: n,
                                initSegment: e,
                                container: s
                            }
                        })
                    }
                    const d = h.segment || h.initSegment,
                        u = d ? h.initSegment : void 0,
                        c = Oc(e.observer);
                    return $i(c.event(v.FRAG_PARSING_INIT_SEGMENT).pipe(hr(this.handleInitSegmentData)), c.event(x.INTERNAL_ERROR).pipe(La(this.handleError)), e.pushWithoutTransfer(d, a, u, o, r, i, t, h.totalDuration, n, void 0, h.iframeMediaStart, h.iframeDuration).pipe($a(Ii))).pipe(Yr(), Ds(1))
                }))
            }
            parseSegment(y, e) {
                return this.getDemuxerInfo(y, this.lastFrags, e, this.demuxClient).pipe(La(({
                    demuxer: e,
                    contiguous: t,
                    trackSwitch: i,
                    discontinuity: r,
                    accurateTimeOffset: n
                }) => {
                    const {
                        frag: h,
                        defaultInitPTS: p
                    } = y, {
                        keyTagInfo: s,
                        start: a,
                        duration: f,
                        mediaOptionType: m
                    } = h;
                    let g;
                    this.lastFrags[m] = h;
                    const o = Oc(e.observer);
                    return $i(o.event(v.FRAG_PARSING_INIT_SEGMENT).pipe(La(e => {
                        var t;
                        return e.track.initSegment.byteLength !== (null === (t = y.initSegment) || void 0 === t ? void 0 : t.byteLength) && (g = this.handleInitSegmentData(e)), Ii
                    })), o.event(v.FRAG_PARSING_DATA).pipe(hr(e => {
                        var {
                            startPTS: t,
                            startDTS: i,
                            firstKeyframePts: r,
                            framesWithoutIDR: n,
                            dropped: s,
                            data1: a,
                            data2: o,
                            captionData: l,
                            id3Samples: d
                        } = e;
                        let {
                            endPTS: u,
                            endDTS: c
                        } = e;
                        return null == u && (this.logger.warn(`${Nu[m]} ${Vp(h)}: null endPTS parsed, using duration ${f}`), u = Object.assign(Object.assign({}, t), {
                            baseTime: t.baseTime + B(f, t.timescale).baseTime
                        })), null == c && (this.logger.warn(`${Nu[m]} ${Vp(h)}: null endDTS parsed, using duration ${f}`), c = Object.assign(Object.assign({}, i), {
                            baseTime: i.baseTime + B(f, i.timescale).baseTime
                        })), ne(y.iframeMediaStart) || function(e, t, i, r) {
                            let n = NaN,
                                s = NaN;
                            if (ne(i)) s = i, n = .01, isFinite(s) && isFinite(r) && (s += r);
                            else {
                                {
                                    const o = void 0
                                }
                            }
                            var {
                                startPTS: a,
                                startDTS: i,
                                endPTS: r,
                                endDTS: t
                            } = t;
                            if (!(0 <= a.baseTime && 0 <= i.baseTime && 0 < e.duration && (null == r || 0 < b(r, a)) && (null == t || 0 < b(t, i)) && (!ne(n) || !ne(s) || Math.abs(S(i) - s) <= n))) throw new D(!1, `Failed demuxer sanity check frag=${Vp(e)} parsed=${JSON.stringify({startPTS:a,endPTS:r,startDTS:i,endDTS:t})} ${ae({expectedStartDTS:s,fudge:n})}`, $.FailedDemuxerSanityCheck)
                        }(h, e, (p, y.iframeMediaStart), this.config.audioPrimingDelay), {
                            startPTS: t,
                            endPTS: u,
                            startDTS: i,
                            endDTS: c,
                            firstKeyframePts: r,
                            framesWithoutIDR: n,
                            dropped: s,
                            data1: a,
                            data2: o,
                            captionData: l,
                            id3Samples: d,
                            parsedInitSegment: g
                        }
                    })), o.event(x.INTERNAL_ERROR).pipe(La(this.handleError)), e.push(y.segment, s, y.initSegment, a, r, i, t, y.totalDuration, n, p, y.iframeMediaStart, y.iframeDuration).pipe($a(Ii))).pipe(Yr(), Ds(1))
                }))
            }
            reset(e) {
                if (null == e) return this.demuxers.forEach(e => {
                    e && e.destroy()
                }), void(this.demuxers = []);
                const t = this.demuxers[e];
                null == t || t.destroy(), this.demuxers[e] = null
            }
            destroy(e) {
                null != e ? this.reset(e) : this.reset()
            }
            willBeTrackSwitch(e, t) {
                var {
                    mediaOptionType: i,
                    mediaOptionId: e
                } = e, i = (t || this.lastFrags)[i];
                return !(i && i.mediaOptionId === e)
            }
            getDemuxerInfo(e, r, t, i) {
                const {
                    frag: n,
                    ptsKnown: s,
                    seeking: a,
                    live: o
                } = e, {
                    discoSeqNum: l,
                    mediaSeqNum: d,
                    mediaOptionType: u
                } = n;
                return Zr(() => {
                    var e = this.demuxers[u];
                    return e ? $i(e) : i.init(this.typeSupported, this.config, t).pipe(Za(e => this.demuxers[u] = e))
                }).pipe(hr(e => {
                    var t = r[u],
                        i = this.willBeTrackSwitch(n, r);
                    return {
                        demuxer: e,
                        trackSwitch: i,
                        discontinuity: !(t && l === t.discoSeqNum),
                        contiguous: !!t && !i && t.mediaSeqNum + 1 === d,
                        accurateTimeOffset: !a && (s || !o)
                    }
                }))
            }
            handleInitSegmentData(e) {
                var t = e["track"],
                    i = t["initSegment"],
                    r = Ze.parseInitSegment(i),
                    {
                        mimeType: n,
                        type: s,
                        codec: a,
                        container: e
                    } = by(r, t.container);
                return {
                    moovData: r,
                    mimeType: n,
                    track: Object.assign(Object.assign({}, t), {
                        type: s,
                        codec: a,
                        initSegment: i,
                        container: e
                    })
                }
            }
            handleError(e) {
                return Vi(e)
            }
        }

        function Ey(a, e, t, h, p, i, r, n) {
            var s = h["combined"],
                o = function(e) {
                    let t = 1 / 0;
                    h.playingFrag && (t = null !== (s = null === (n = e.fragments[h.playingFrag.mediaSeqNum - e.startSN]) || void 0 === n ? void 0 : n.duration) && void 0 !== s ? s : 1 / 0);
                    var {
                        minRequiredStartDuration: i,
                        maxRequiredStartDuration: r,
                        startTargetDurationFactor: n
                    } = a, {
                        targetduration: s,
                        averagetargetduration: e
                    } = e, r = n * Math.min(t, e, s, r);
                    return Math.max(i, r)
                }(t.details);
            let l = function(e, t, i) {
                const {
                    pos: r,
                    combined: n,
                    playingFrag: s
                } = h;
                if (0 === n.len) return !1;
                var a = t.details,
                    o = a.fragments;
                let l = 0 != p && 1 != p || n.len >= i;
                var d = o[a.fragments.length - 1],
                    t = o[0].start + a.totalduration;
                let u = !1;
                if (s) {
                    const c = qu.search(o, e => s.discoSeqNum - e.discoSeqNum);
                    u = e && s.discoSeqNum !== e.discoSeqNum || null == c || $p(c, s)
                }
                return l && a.liveOrEvent ? l = r <= t - d.duration : a.liveOrEvent || (l = l || t - i <= r), l = l || u, l
            }(e, t, o);
            return !l && 0 < s.len && null != e && e.state && (l = function(n, e, t, i, r, s, a) {
                var o = null === (l = h.sbTuple[gu.Variant]) || void 0 === l ? void 0 : l.buffered,
                    l = null === (l = h.sbTuple[gu.AltAudio]) || void 0 === l ? void 0 : l.buffered;
                if ((null == o ? void 0 : o.len) >= t && (!l || l.len >= t)) return 0;
                if (!(o && n && (d = h.pos, (l = n.start + n.duration) > o.end && (n.start - o.end <= a || n.start <= o.end) && t <= l - d))) return 1 / 0;
                var d = n.state;
                let u = n.tstart,
                    c = 0;
                switch (d) {
                    case "loading":
                        c += function(e, t) {
                            var {
                                bwSample: i,
                                duration: r
                            } = n;
                            if (!i) return 1 / 0;
                            r = ne(i.total) ? 8 * i.total : Math.ceil(r * e), e = 8 * i.loaded, r -= e, i = e / (performance.now() - i.tfirst) * 1e3;
                            if (!ne(i)) return 1 / 0;
                            t = t.avgBandwidth;
                            return r / Math.min(t, i)
                        }(e, i), u = n.tstart + 1e3 * c;
                    case "loaded":
                    case "parsing":
                        c += function(e, t) {
                            t = ne(t.avgParseTimeMs) ? t.avgParseTimeMs : 0;
                            return performance.now() < e ? t / 1e3 : Math.max(0, t - (performance.now() - e)) / 1e3
                        }(u, r), u = n.tstart + 1e3 * c;
                    case "parsed":
                    case "appending":
                        c += function(e, t) {
                            t = ne(t.avgDataFragAppendMs) ? t.avgDataFragAppendMs : 0;
                            return performance.now() < e ? t / 1e3 : Math.max(0, t - (performance.now() - e)) / 1e3
                        }(u, s);
                        break;
                    default:
                        c = 1 / 0
                }
                return c
            }(e, t.variant.bitrate, o, i, r, n, a.maxBufferHole) <= s.len), l
        }

        function Iy(e, t, i, r) {
            if (200 === t && r && 10 < r.length) {
                if (Rm.isValidPlaylist(r)) return !0; {
                    const t = new R(o, _, !0, "response doesnt have #EXTM3U tag", $.PlaylistErrorMissingEXTM3U);
                    throw t.url = e, t
                }
            }
            return !1
        }
        const wy = {
            name: "pltfrm"
        };

        function Ay(e, t) {
            t = Ah.getKeySystemSecurityLevel(t);
            return null != e && void 0 !== t[e]
        }

        function Oy(e) {
            return e.every(e => e.iframes)
        }

        function ky(e, t) {
            return !ne(e) || !ne(t) || e <= t
        }

        function Cy() {
            const n = new Set,
                s = new Set;
            return e => {
                const i = (e, t) => {
                        t = t ? "audio" : "video";
                        n.has(e) || s.has(e) || (((e, t) => {
                            let i = MediaSource.isTypeSupported(`${e}/mp4;codecs=${t}`);
                            return "mp4a.40.34" !== t || i || (i = MediaSource.isTypeSupported(`${e}/mpeg`)), i
                        })(t, e) ? n : s).add(e)
                    },
                    t = (e, t) => (i(e, t), s.has(e));
                let r = !1;
                return e.audioCodecList && (r = e.audioCodecList.some(e => t(e, !0))), !r && e.videoCodecList && (r = e.videoCodecList.some(e => t(e, !1))), !r
            }
        }

        function Dy(e, t) {
            for (const i in e)
                if (e[i].type === t) return e[i];
            return {}
        }

        function My(e, t, i) {
            t.filter(e => !i.includes(e)).map(e => e.mediaOptionId)
        }

        function xy(e, i, s) {
            const a = new Map,
                r = new Array;
            return e.forEach(t => {
                var e = Array();
                ! function(e, t, i) {
                    var r = Wc.getCapabilities(t.videoCodecList, t.audioCodecList),
                        t = JSON.stringify(r);
                    let n;
                    a.has(t) ? n = a.get(t) : (n = Ah.requestKeySystemAccess(e, r, void 0, s).pipe(hr(() => !0), Vn(e => (s.warn(`Request key system error: ${e.message}`), $i(!1))), Oa({
                        bufferSize: 1,
                        refCount: !0
                    })), a.set(t, n)), i.push(n)
                }(i, t, e);
                e = en(e).pipe(hr(e => {
                    if (void 0 === e.find(e => !1 === e)) return t
                }));
                r.push(e)
            }), en(r).pipe(hr(e => e.filter(e => Boolean(e))))
        }

        function Py(e, r) {
            const o = new Set,
                l = new Set,
                d = !MediaSource.isTypeSupported('audio/mp4; codecs="mp4a.40.2"; channels="-1"'),
                u = d && !MediaSource.isTypeSupported('audio/mp4; codecs="mp4a.40.2"; channels="2"; features="INVALID"'),
                t = e.filter(e => {
                    let t = !1;
                    var i;
                    return e.audioCodecList && e.audioGroupId && (i = fm.getRichestChannelLayoutForGroupId(e.audioGroupId, r), 0 < e.audioCodecList.length && i && (t = ((e, t) => {
                        var i, r, n, s = be.isDolbyAtmos(e, t);
                        if (u || d && !s) {
                            n = `${i=e}/${r=t}`, o.has(n) || l.has(n) || (((e, t) => {
                                const i = t.split("/"),
                                    r = parseInt(i[0]);
                                let n, s;
                                if (1 < i.length) {
                                    const t = i[1].split(",")[0];
                                    n = `audio/mp4;codecs="${e}";channels="${r}";features="${t}"`, s = `audio/mp4;codecs="${e}";channels="8";features="${t}"`
                                } else n = `audio/mp4;codecs="${e}";channels="${r}"`;
                                let a = MediaSource.isTypeSupported(n);
                                return !a && s && (a = MediaSource.isTypeSupported(s)), a
                            })(i, r) ? o : l).add(n);
                            const a = `${e}/${t}`;
                            return l.has(a)
                        }
                        return !!s
                    })(fm.getRichestAudioCodec(e.audioCodecList), i))), !t
                });
            return My(0, e, t), t
        }

        function Ry(e, t, l) {
            const n = 0 < (null == t ? void 0 : t.length),
                i = e.filter(o => {
                    var e = function() {
                            if (!l) return {
                                highestPlayableAverageBitRate: void 0,
                                highestPlayablePeakBitRate: void 0,
                                highestPlayableWidth: void 0,
                                highestPlayableHeight: void 0,
                                highestPlayableFrameRate: void 0
                            };
                            const e = o.videoCodec,
                                t = o.videoRange,
                                i = l.videoDynamicRangeFormats,
                                r = l.videoCodecs,
                                n = be.getDynamicRangeType(t, e),
                                s = be.getCompressionType(e),
                                a = function(e, t, i, r) {
                                    if (!r && !i) return {};
                                    var n, s, t = i ? Dy(i, t) : {},
                                        r = r ? Dy(r, e) : {};
                                    let a, o;
                                    return o = e === fe.SDR ? (a = t, r) : (a = r, t), n = Object.assign({}, a), s = o, Object.keys(s).forEach(e => {
                                        n[e] || (n[e] = s[e])
                                    }), n
                                }(n, s, r, i);
                            return s !== me.VP09 && (a.highestPlayablePeakBitRateForClearContent = void 0), a
                        }(),
                        t = e["highestPlayablePeakBitRateForClearContent"],
                        i = o.allowedCPCMap || n,
                        r = ky(o.bandwidth, e.highestPlayablePeakBitRate);
                    return (i || !t ? r : r || ky(o.bandwidth, t)) && ky(o.avgBandwidth, e.highestPlayableAverageBitRate) && ky(o.width, e.highestPlayableWidth) && ky(o.height, e.highestPlayableHeight) && ky(o.frameRate, e.highestPlayableFrameRate)
                });
            return My(0, e, i), i
        }

        function Ly(e, a, o, l, d, u) {
            var r = (null == l ? void 0 : l.maxHdcpLevel) || void 0;
            let c = [...e];
            (0 < d.disableVideoCodecList.size || 0 < d.disableAudioCodecList.size) && (c = function(e, t, i) {
                let r = e.filter(e => !e.videoCodec || e.videoCodecList.every(e => {
                    e = qp(e);
                    return !t.has(e)
                }));
                return r = r.filter(e => !(!e.iframes && e.audioCodec) || e.audioCodecList.every(e => {
                    e = jp(e);
                    return !i.has(e)
                })), My(0, e, r), r
            }(c, d.disableVideoCodecList, d.disableAudioCodecList)), r && dm(r) && (c = function(e) {
                const t = um(r),
                    i = e.filter(e => {
                        e = e.hdcpLevel;
                        return !e || um(e) <= t
                    });
                return My(0, e, i), i
            }(c));
            var t = null == l ? void 0 : l.maxSecurityLevel,
                e = null == d ? void 0 : d.keySystemPreference;
            t && e && Ay(t, e) && (c = function(e, t, i) {
                function r(e) {
                    return Ay(e, i) ? n[e] : -1
                }
                const n = Ah.getKeySystemSecurityLevel(i),
                    s = Ah.getKeySystemFormat(i),
                    a = r(t),
                    o = e.filter(e => {
                        e = null !== (e = null === (e = e.allowedCPCMap) || void 0 === e ? void 0 : e[s]) && void 0 !== e ? e : [];
                        let t = !0;
                        for (const i of e)
                            if (t = r(i) <= a, !t) break;
                        return t
                    });
                return My(0, e, o), [...o]
            }(c, t, e)), c = c.map(t => {
                var e;
                return t.audioCodecList && t.audioGroupId && ((e = null == (e = a.find(e => e.groupId === t.audioGroupId)) ? void 0 : e.channels) && (t.audioChannelCount = parseInt(e))), t
            });
            const h = !(null == d || !d.useMediaKeySystemAccessFilter) && e && navigator && "function" == typeof navigator.requestMediaKeySystemAccess;
            return (h ? xy(c, e, u) : $i(c)).pipe(La(e => {
                if (0 === e.length || Oy(e)) throw new R(L, f, void 0, "no media option with compatible codecs found in playlist", void 0);
                h && My(0, c, e);
                const t = navigator && navigator.mediaCapabilities,
                    n = !(null == d || !d.useMediaCapabilities) && t && "function" == typeof t.decodingInfo;
                let i;
                return i = n ? function(e, n, s) {
                    const a = [],
                        o = Cy(),
                        l = function(o) {
                            const l = new Map,
                                d = navigator && navigator.mediaCapabilities;
                            return (i, e, t, n, r) => {
                                const s = {
                                    type: "media-source"
                                };
                                n ? s.video = function(e) {
                                    const t = {
                                        contentType: `video/mp4;codecs=${e}`,
                                        width: i.width,
                                        height: i.height,
                                        bitrate: i.bandwidth || i.avgBandwidth,
                                        framerate: i.iframes ? 8 : i.frameRate
                                    };
                                    if (i.videoRange) switch (i.videoRange) {
                                        case "PQ":
                                            be.isDolby(e) ? (t.hdrMetadataType = Pm.DoVi, t.colorGamut = "rec2020") : (be.isHEVC(e) || be.isVP09(e)) && (t.hdrMetadataType = Pm.HDR10, t.colorGamut = "rec2020"), t.transferFunction = "pq";
                                            break;
                                        case "HLG":
                                            t.colorGamut = "rec2020", t.transferFunction = "hlg"
                                    }
                                    return t
                                }(t) : s.audio = function(e, t, i) {
                                    const r = {
                                            contentType: `audio/mp4;codecs=${e}`
                                        },
                                        n = fm.getRichestChannelLayoutForGroupId(t.audioGroupId, i);
                                    return n && (r.channels = be.getChannelCount(n).toString(), r.spatialRendering = be.isDolbyAtmos(e, n)), r
                                }(t, i, e);
                                e = JSON.stringify(s);
                                let a;
                                return l.has(e) ? a = l.get(e) : (a = Fr(d.decodingInfo(s)).pipe(hr(e => {
                                    const t = e.configuration || e.supportedConfiguration,
                                        i = t instanceof Object && (!s.video || null == Object.keys(s.video).find(e => !(e in t.video))) && (!s.audio || null == Object.keys(s.audio).find(e => !(e in t.audio))),
                                        r = e.supported && (!n || e.powerEfficient) && i;
                                    return r || o.warn(wy, `Unsupported config ${e.supported}/${e.powerEfficient}/${i} ${JSON.stringify(s)} supportedConfig=${JSON.stringify(t)}`), r
                                })), l.set(e, a)), [...r, a]
                            }
                        }(s);
                    return e.forEach(t => {
                        var e;
                        let i = [];
                        if (null === (e = t.videoCodecList) || void 0 === e || e.forEach(e => {
                                i = l(t, n, e, !0, i)
                            }), 0 < (null === (e = t.audioCodecList) || void 0 === e ? void 0 : e.length)) {
                            const s = fm.getRichestAudioCodec(t.audioCodecList);
                            i = l(t, n, s, !1, i)
                        }
                        let r = $i(t);
                        0 < i.length && (r = en(i).pipe(hr(e => null == e.find(e => !1 === e) ? t : null), Vn(e => (s.warn(wy, `decodingInfo errror: ${e.message}`), $i(o(t) ? t : null))))), a.push(r)
                    }), en(a).pipe(hr(e => e.filter(e => Boolean(e))))
                }(e, a, u) : $i(e = Py((r = e, s = Cy(), s = r.filter(s), My(0, r, s), e = s), a)), i.pipe(hr(e => {
                    if (0 === e.length || Oy(e)) throw new R(L, f, void 0, "no media option with compatible codecs found in manifest", void 0);
                    if (0 === (t = e = Ry(e, o, l), r = t.filter(e => !e.iframes || !e.width || !e.height || e.width * e.height <= 2488320), My(0, t, r), (e = r).length) || Oy(e)) throw new R(L, f, void 0, "no media option with compatible codecs found in manifest", void 0);
                    var t;
                    let i = (null == l ? void 0 : l.videoDynamicRangeFormats) || [];
                    n && 0 === i.length && (i = [{
                        type: fe.SDR
                    }, {
                        type: fe.HDR
                    }, {
                        type: fe.HDR10
                    }, {
                        type: fe.DolbyVision
                    }, {
                        type: fe.HLG
                    }]);
                    var {
                        hdrMediaOptions: r,
                        sdrMediaOptions: e
                    } = function(e, t) {
                        const i = t.reduce((e, t) => {
                                switch (t.type) {
                                    case fe.DolbyVision:
                                        e.doViSupported = !0;
                                        break;
                                    case fe.HDR10:
                                        e.hdr10Supported = !0;
                                        break;
                                    case fe.HLG:
                                        e.hlgSupported = !0
                                }
                                return e
                            }, {
                                doViSupported: !1,
                                hdr10Supported: !1,
                                hlgSupported: !1
                            }),
                            {
                                doViSupported: r,
                                hdr10Supported: n,
                                hlgSupported: s
                            } = i;
                        return e.reduce((e, t) => {
                            var i;
                            switch (be.getDynamicRangeType(t.videoRange, null !== (i = t.videoCodec) && void 0 !== i ? i : "")) {
                                case fe.HDR:
                                case fe.HDR10:
                                    n && e.hdrMediaOptions.push(t);
                                    break;
                                case fe.DolbyVision:
                                    r && e.hdrMediaOptions.push(t);
                                    break;
                                case fe.HLG:
                                    s && e.hdrMediaOptions.push(t);
                                    break;
                                default:
                                    "SDR" !== t.videoRange && null != t.videoRange || e.sdrMediaOptions.push(t)
                            }
                            return e
                        }, {
                            hdrMediaOptions: new Array,
                            sdrMediaOptions: new Array
                        })
                    }(e, i);
                    if (0 === r.length && 0 === e.length || Oy(r) && Oy(e)) throw new R(L, "manifestIncompatibleVideoRangeError", void 0, "mediaOption with compatible VIDEO-RANGE not found in manifest", void 0);
                    return {
                        hdrMediaOptions: r,
                        sdrMediaOptions: e
                    }
                }), Vn(e => {
                    throw e instanceof R && (e.fatal = !0, e.response = $.IncompatibleAsset), e
                }));
                var r, s
            }))
        }

        function _y(e, t) {
            return t.mediaOptionId !== e.mediaOptionId && t.persistentID === e.persistentID && t.groupId !== e.groupId
        }(A = Pm = Pm || {}).HDR10 = "smpteSt2086", A.DoVi = "smpteSt2094-10", A.HDR10Plus = "smpteSt2094-40";
        class Ny extends jm {
            constructor(e, t, i) {
                super(e, t, i)
            }
            static makeFilters() {
                return Hm()
            }
            _initFilters() {
                return Ny.kAllowFilters
            }
            get _mediaOptionType() {
                return this.mediaOptionType
            }
            get preferredHost() {
                return null
            }
            get preferredHost$() {
                return $i(null)
            }
            get mediaOptionListInfo() {
                var e;
                return null !== (e = null === (e = this.getEntity(this.itemId)) || void 0 === e ? void 0 : e.mediaOptionListTuple[this._mediaOptionType]) && void 0 !== e ? e : null
            }
            get mediaOptionListInfo$() {
                return this.selectEntity(this.itemId, e => e && e.mediaOptionListTuple ? e.mediaOptionListTuple[this._mediaOptionType] : null).pipe(Kp())
            }
            getFallbackVariant(t, e, i, r) {
                var n;
                const s = null === (n = this.mediaOptionList) || void 0 === n ? void 0 : n.find(e => e.mediaOptionId === t);
                if (!s) return null;
                const a = this.filteredMediaOptionList;
                if (!a) return null;
                const o = Eu(s.url);
                if (i) return null !== (i = a.find(e => _y(s, e) && !Au(o, e.url))) && void 0 !== i ? i : null;
                let l = null;
                for (const t of a) !_y(s, t) || l && !Au(o, t.url) || (l = t);
                return l
            }
            getMatchingAlternateWithPersistentId(t, i, r) {
                var e;
                return null !== (e = this.preferredMediaOptionList.find(e => !(0 < (null == r ? void 0 : r.length) && r.includes(e.mediaOptionId)) && (!ne(t) || e.persistentID === t) && (!i || this.matchGroup(e, i.audioGroupId, i.subtitleGroupId, i.closedcaption)))) && void 0 !== e ? e : null
            }
            matchGroup(e, t, i, r) {
                let n = !1;
                switch (e.type) {
                    case "CLOSED-CAPTIONS":
                        n = !r || e.groupId === r;
                        break;
                    case "SUBTITLES":
                        n = !i || e.groupId === i;
                        break;
                    case "AUDIO":
                        n = !t || e.groupId === t
                }
                return n
            }
            getMatchingAlternate(e, t) {
                e = this.mediaOptionFromId(e);
                return this.getMatchingAlternateWithPersistentId(null == e ? void 0 : e.persistentID, t, [])
            }
            packageAlternateMediaOption(e, t, i) {
                return t.mediaType === Su.CLOSEDCAPTION ? this.augmentClosedCaptionsWithForcedSubtitles(null == e ? void 0 : e.subtitleGroupId, t, i) : t
            }
            augmentClosedCaptionsWithForcedSubtitles(e, t, i) {
                i = this.pairForcedSubtitleMediaOptionWithClosedCaption(e, t, i);
                return i ? Object.assign(Object.assign({}, t), {
                    url: i.url,
                    backingMediaOptionId: i.mediaOptionId
                }) : t
            }
            pairForcedSubtitleMediaOptionWithClosedCaption(t, i, r) {
                let n;
                if (i && i.mediaType === Su.CLOSEDCAPTION) {
                    let e = this.mediaOptionList;
                    r && (e = this.preferredMediaOptionList), n = Ny.pairForcedSubtitleMediaOptionWithClosedCaptionInList(t, i, e)
                }
                return n
            }
            static pairForcedSubtitleMediaOptionWithClosedCaptionInList(t, i, e) {
                return e.find(function(e) {
                    return e.mediaType === Su.SUBTITLE && e.lang === i.lang && e.forced && e.autoselect && (!t || e.groupId === t)
                })
            }
        }
        Ny.kAllowFilters = Ny.makeFilters();
        class Fy extends kl {
            constructor(e, t) {
                super(e), this.itemId = t, this.mediaOptionListQueries = [new Xm(e, this.itemId), new Ny(e, this.itemId, gu.AltAudio), new Ny(e, this.itemId, gu.Subtitle)]
            }
            get rootPlaylistEntity() {
                return this.getEntity(this.itemId)
            }
            get rootMediaOptionsTuple() {
                var e = null === (e = this.rootPlaylistEntity) || void 0 === e ? void 0 : e.mediaOptionListTuple;
                return e ? [e[0].mediaOptions, e[1].mediaOptions, e[2].mediaOptions] : [
                    [],
                    [],
                    []
                ]
            }
            get itemStartOffset() {
                var e, t;
                return null !== (e = this.rootPlaylistEntity) && void 0 !== e && e.itemStartOffset && ne(null === (t = this.rootPlaylistEntity) || void 0 === t ? void 0 : t.itemStartOffset) ? null === (t = this.rootPlaylistEntity) || void 0 === t ? void 0 : t.itemStartOffset : 0
            }
            get highestVideoCodec() {
                var e;
                return null === (e = this.rootPlaylistEntity) || void 0 === e ? void 0 : e.highestVideoCodec
            }
            get baseUrl() {
                var e;
                return null === (e = this.rootPlaylistEntity) || void 0 === e ? void 0 : e.baseUrl
            }
            get anchorTime() {
                var e;
                return null === (e = this.rootPlaylistEntity) || void 0 === e ? void 0 : e.anchorTime
            }
            get discoSeqNum() {
                var e;
                return null !== (e = null === (e = this.rootPlaylistEntity) || void 0 === e ? void 0 : e.discoSeqNum) && void 0 !== e ? e : NaN
            }
            get discoSeqNum$() {
                return this.selectEntity(this.itemId, "discoSeqNum")
            }
            get audioMediaSelectionGroup() {
                var e;
                return null !== (e = null === (e = this.rootPlaylistEntity) || void 0 === e ? void 0 : e.audioMediaSelectionGroup) && void 0 !== e ? e : null
            }
            get subtitleMediaSelectionGroup() {
                var e;
                return null !== (e = null === (e = this.rootPlaylistEntity) || void 0 === e ? void 0 : e.subtitleMediaSelectionGroup) && void 0 !== e ? e : null
            }
            get audioMediaSelectionOptions() {
                var e;
                return null !== (e = null === (e = null === (e = this.rootPlaylistEntity) || void 0 === e ? void 0 : e.audioMediaSelectionGroup) || void 0 === e ? void 0 : e.MediaSelectionGroupOptions) && void 0 !== e ? e : []
            }
            get subtitleMediaSelectionOptions() {
                var e;
                return null !== (e = null === (e = null === (e = this.rootPlaylistEntity) || void 0 === e ? void 0 : e.subtitleMediaSelectionGroup) || void 0 === e ? void 0 : e.MediaSelectionGroupOptions) && void 0 !== e ? e : []
            }
            get contentSteeringOption() {
                var e;
                return null === (e = this.rootPlaylistEntity) || void 0 === e ? void 0 : e.contentSteeringOption
            }
            get masterVariableList() {
                var e;
                return null === (e = this.rootPlaylistEntity) || void 0 === e ? void 0 : e.masterVariableList
            }
            get loadStats() {
                var e;
                return null === (e = this.rootPlaylistEntity) || void 0 === e ? void 0 : e.loadStats
            }
            get isMediaPlaylist() {
                var e;
                return null === (e = this.rootPlaylistEntity) || void 0 === e ? void 0 : e.isMediaPlaylist
            }
            getInitPTS(e) {
                var t;
                return null === (t = this.rootPlaylistEntity) || void 0 === t ? void 0 : t.initPtsRecord[e]
            }
            get abrStatus$() {
                return this.selectEntity(this.itemId, e => null == e ? void 0 : e.abrStatus)
            }
            get abrStatus() {
                var e;
                return null === (e = this.rootPlaylistEntity) || void 0 === e ? void 0 : e.abrStatus
            }
            get nextMaxAutoOptionId() {
                var e;
                return null === (e = null === (e = this.rootPlaylistEntity) || void 0 === e ? void 0 : e.abrStatus) || void 0 === e ? void 0 : e.nextMaxAutoOptionId
            }
            get nextMinAutoOptionId() {
                var e;
                return null === (e = null === (e = this.rootPlaylistEntity) || void 0 === e ? void 0 : e.abrStatus) || void 0 === e ? void 0 : e.nextMinAutoOptionId
            }
            initPTS$(t) {
                return this.selectEntity(this.itemId, ({
                    initPtsRecord: e
                }) => e[t])
            }
            get rootPlaylistEntity$() {
                return this.selectEntity(this.itemId).pipe(ln(e => Boolean(e)), hr(e => e))
            }
            get rootPlaylistEntityAdded$() {
                return this.selectEntityAction(Eo.Add).pipe(hr(e => e.map(e => this.getEntity(e))))
            }
            get rootMediaOptionsTuple$() {
                return ed([this.selectEntity(this.itemId, e => e.mediaOptionListTuple[0].mediaOptions), this.selectEntity(this.itemId, e => e.mediaOptionListTuple[1].mediaOptions), this.selectEntity(this.itemId, e => e.mediaOptionListTuple[2].mediaOptions)])
            }
            get sessionData() {
                var e;
                return null === (e = this.rootPlaylistEntity) || void 0 === e ? void 0 : e.sessionData
            }
            get sessionData$() {
                return this.selectEntity(this.itemId, ({
                    sessionData: e
                }) => e).pipe(Kp())
            }
            get anchorTime$() {
                return this.selectEntity(this.itemId, "anchorTime").pipe(La(e => {
                    var t;
                    return ne(null == e ? void 0 : e.pos) ? (null == e ? void 0 : e.pos) !== (null === (t = this.anchorTime) || void 0 === t ? void 0 : t.pos) ? (Qe().warn(`anchorTime doesn't match stored value! ${null==e?void 0:e.pos} !== ${null===(t=this.anchorTime)||void 0===t?void 0:t.pos}`), Ii) : $i(e) : Ii
                }))
            }
            get pendingSeek$() {
                return this.selectEntity(this.itemId, ({
                    pendingSeek: e
                }) => e).pipe(Is((e, t) => e === t || "number" == typeof e && "number" == typeof t && isNaN(e) && isNaN(t)))
            }
            get enabledMediaOptionKeys$() {
                return this.selectEntity(this.itemId, "enabledMediaOptionKeys").pipe(ln(e => Boolean(e)))
            }
            get enabledMediaOptionKeys() {
                var e;
                return null !== (e = null === (e = this.getEntity(this.itemId)) || void 0 === e ? void 0 : e.enabledMediaOptionKeys) && void 0 !== e ? e : [Lu, Lu, Lu]
            }
            get enabledMediaOptionSwitchContexts() {
                var e;
                return null !== (e = null === (e = this.getEntity(this.itemId)) || void 0 === e ? void 0 : e.mediaOptionSwitchContexts) && void 0 !== e ? e : [null, null, null]
            }
            enabledMediaOptionSwitchContextsByType$(t) {
                return this.selectEntity(this.itemId, "mediaOptionSwitchContexts").pipe(hr(e => null == e ? void 0 : e[t]))
            }
            get enabledMediaOptions$() {
                return ed([this.enabledMediaOptionByType$(gu.Variant), this.enabledMediaOptionByType$(gu.AltAudio), this.enabledMediaOptionByType$(gu.Subtitle)])
            }
            get enabledAVOptions$() {
                return ed([this.enabledMediaOptionByType$(gu.Variant), this.enabledMediaOptionByType$(gu.AltAudio)])
            }
            rawEnabledMediaOptionByType$(t) {
                return this.enabledMediaOptionKeys$.pipe(hr(e => {
                    const i = e[t];
                    return _u(i) && this.rootMediaOptionsTuple[t].find(e => {
                        return t = i, e.itemId === t.itemId && e.mediaOptionId === t.mediaOptionId;
                        var t
                    }) || Lu
                }))
            }
            enabledMediaOptionByType$(e) {
                return this.rawEnabledMediaOptionByType$(e).pipe(Is((e, t) => e.mediaOptionId === t.mediaOptionId && e.url === t.url))
            }
            enabledMediaOptionSwitchForType$(e) {
                return this.rawEnabledMediaOptionByType$(e).pipe(bo(this.enabledMediaOptionSwitchContextsByType$(e)), Ra(null), ha(), hr(([e, t]) => ({
                    fromId: null == e ? void 0 : e[0].mediaOptionId,
                    toId: null == t ? void 0 : t[0].mediaOptionId,
                    switchContext: null == t ? void 0 : t[1]
                })), Is((e, t) => e.fromId === t.fromId && e.toId === t.toId))
            }
            enableMediaOptionSwitchedForType$(t) {
                return this.enabledMediaOptionByType$(t).pipe(La(e => Gu(Mr([$i(e), this.enabledMediaOptionSwitchContextsByType$(t).pipe(ha())]), ([, e]) => e[0] && !e[1])), hr(([e]) => e))
            }
            enabledMediaOptionIdByType(e) {
                return this.getEntity(this.itemId).enabledMediaOptionKeys[e].mediaOptionId
            }
            get enabledVariantMediaOptionIdBeforeTrickplaySwitch() {
                return this.getEntity(this.itemId).enabledVariantMediaOptionIdBeforeTrickplaySwitch
            }
            variantMediaOptionById(e) {
                return this.mediaOptionListQueries[gu.Variant].mediaOptionFromId(e)
            }
            alternateMediaOptionById(e, t) {
                return this.mediaOptionListQueries[e].mediaOptionFromId(t)
            }
            enabledAlternateMediaOptionByType(e) {
                var t = this.enabledMediaOptionIdByType(e);
                return this.alternateMediaOptionById(e, t)
            }
            get enabledVariantMediaOption() {
                var e = this.enabledMediaOptionIdByType(gu.Variant);
                return this.variantMediaOptionById(e)
            }
            lastLoadedMediaOptionByType(e) {
                var t;
                return null === (t = this.getEntity(this.itemId).lastLoadedMediaOptionKeys) || void 0 === t ? void 0 : t[e]
            }
            get nextMediaOptionsKeys$() {
                return this.selectEntity(this.itemId, "nextMediaOptionKeys")
            }
            get preferredMediaOptions() {
                return [this.mediaOptionListQueries[0].preferredMediaOptionList, this.mediaOptionListQueries[1].preferredMediaOptionList, this.mediaOptionListQueries[2].preferredMediaOptionList]
            }
            get preferredMediaOptions$() {
                return ed([this.mediaOptionListQueries[0].preferredMediaOptionList$, this.mediaOptionListQueries[1].preferredMediaOptionList$, this.mediaOptionListQueries[2].preferredMediaOptionList$])
            }
            get filteredMediaOptions() {
                return [this.mediaOptionListQueries[0].filteredMediaOptionList, this.mediaOptionListQueries[1].filteredMediaOptionList, this.mediaOptionListQueries[2].filteredMediaOptionList]
            }
            getDisabledMediaOption(e) {
                return {
                    itemId: this.itemId,
                    mediaOptionType: e,
                    mediaOptionId: "Nah"
                }
            }
            getEnabledMediaOptionMask() {
                return this.enabledMediaOptionKeys.map(e => _u(e))
            }
            getPreferredMediaOptionsByType$(e) {
                return this.mediaOptionListQueries[e].preferredMediaOptionList$
            }
            altMediaOptionHasValidUrl(e, t) {
                t = this.alternateMediaOptionById(e, t);
                return Boolean(null == t ? void 0 : t.url)
            }
            get hdrMode$() {
                return this.mediaOptionListQueries[gu.Variant].hdrMode$
            }
            get maxHdcpLevel$() {
                return this.mediaOptionListQueries[gu.Variant].maxHdcpLevel$
            }
            get currentPathwayID() {
                return this.mediaOptionListQueries[gu.Variant].currentPathwayID
            }
            get preferredHost() {
                return this.mediaOptionListQueries[gu.Variant].preferredHost
            }
            getErrorInfoByType(e) {
                var t;
                return null != (null === (t = this.rootPlaylistEntity) || void 0 === t ? void 0 : t.errorsByType) ? this.rootPlaylistEntity.errorsByType[e] : null
            }
            getInFlightFragByType(e) {
                var t;
                return null !== (e = null === (t = null === (t = this.getEntity(this.itemId)) || void 0 === t ? void 0 : t.inFlightFrags) || void 0 === t ? void 0 : t[e]) && void 0 !== e ? e : null
            }
            getInFlightFragByType$(t) {
                return this.selectEntity(this.itemId, e => {
                    return null === (e = null == e ? void 0 : e.inFlightFrags) || void 0 === e ? void 0 : e[t]
                })
            }
            matchAlternates(e, t, i, r) {
                t = ne(t) ? this.mediaOptionListQueries[gu.AltAudio].getMatchingAlternateWithPersistentId(t, e, r) : void 0, r = ne(i) ? this.mediaOptionListQueries[gu.Subtitle].getMatchingAlternateWithPersistentId(i, e, r) : void 0;
                return [t || Lu, r || Lu]
            }
            getLegacyMatchingAlternateWithPersistentId(e, t, i) {
                let r = this.mediaOptionListQueries[e].getMatchingAlternateWithPersistentId(t, i, []);
                return r = r || this.mediaOptionListQueries[e].getMatchingAlternateWithPersistentId(t, void 0, []), r
            }
            isValidMediaOptionTuple(i, e) {
                const r = e || this.getEnabledMediaOptionMask();
                return [gu.Variant, gu.AltAudio, gu.Subtitle].reduce((e, t) => e && r[t] === _u(i[t]), !0)
            }
            matchGroup(e, t, i, r) {
                var n = e.mediaOptionType;
                return this.mediaOptionListQueries[n].matchGroup(e, t, i, r)
            }
            get preferHDR() {
                return this.mediaOptionListQueries[gu.Variant].mediaOptionListInfo.preferHDR
            }
        }
        const By = {
            name: "rps"
        };
        class Uy {
            constructor(e, t) {
                this.store = e, this.logger = t
            }
            getQuery() {
                return new kl(this.store)
            }
            getQueryForId(e) {
                return new Fy(this.store, e)
            }
            set rootPlaylistEntity(e) {
                Do("root.add.rootPlaylist"), this.store.add(e)
            }
            removeItems(e) {
                Do(`root.add.remove ${JSON.stringify(e)}`), this.store.remove(e)
            }
            removeAll() {
                Do("root.add.clear"), this.store.remove()
            }
            setRootPlaylistEntity(e, t) {
                Do("root.set.rootPlaylistEntity"), this.store.update(e, e => t)
            }
            setSessionData(e, t) {
                Do("root.set.sessionData"), this.store.update(e, e => {
                    e.sessionData = t
                })
            }
            setAnchorTime(e, t) {
                Do(`root.set.anchorTime: ${null==t?void 0:t.pos} ${null==t?void 0:t.discoSeqNum}`), this.store.update(e, e => {
                    e.anchorTime = t
                })
            }
            setDiscoSeqNum(e, t) {
                Do(`root.set.discoSeqNum: ${t}`), this.store.update(e, e => {
                    e.discoSeqNum = t
                })
            }
            setPendingSeek(e, t) {
                Do("root.set.pendingSeek"), this.store.update(e, e => {
                    e.pendingSeek = t
                }), void 0 === t && fg().setUserSeek(t)
            }
            setEnabledMediaOptionSwitchContextByType(e, i, r, n) {
                this.store.update(e, e => {
                    var t;
                    if (e.enabledMediaOptionKeys[i].mediaOptionId === r) {
                        const r = null !== (t = e.mediaOptionSwitchContexts) && void 0 !== t ? t : [null, null, null];
                        r[i] = n ? {
                            userInitiated: n.userInitiated,
                            switchPosition: n.switchPosition
                        } : null, e.mediaOptionSwitchContexts = r
                    } else Do(`root.set.mediaOptionSwitchContextByType ${r} doesn't match existing mediaOption ${e.enabledMediaOptionKeys[i].mediaOptionId}`)
                })
            }
            setEnabledVariantMediaOptionIdBeforeTrickplaySwitch(e, t) {
                this.store.update(e, e => {
                    e.enabledVariantMediaOptionIdBeforeTrickplaySwitch = t
                })
            }
            setEnabledMediaOptionByType(r, n, s, a = !1, o) {
                s = s || {
                    itemId: r,
                    mediaOptionType: n,
                    mediaOptionId: "Nah"
                }, this.store.update(r, e => {
                    var t;
                    const i = null !== (t = [...e.enabledMediaOptionKeys]) ? t : [Lu, Lu, Lu];
                    if (i[n] = {
                            itemId: r,
                            mediaOptionId: s.mediaOptionId
                        }, this._updateEnabledMediaOptionKeys(e, i), a) {
                        const r = null !== (t = e.mediaOptionSwitchContexts) && void 0 !== t ? t : [null, null, null];
                        r[n] = o ? {
                            userInitiated: o.userInitiated,
                            switchPosition: o.switchPosition
                        } : null, e.mediaOptionSwitchContexts = r
                    }
                })
            }
            _associateForcedSubtitleWithClosedCaption(e, t, i, r) {
                if ((null == i ? void 0 : i.mediaType) === Su.CLOSEDCAPTION) {
                    t = r.variantMediaOptionById(t), r = r.mediaOptionListQueries[gu.Subtitle].packageAlternateMediaOption(t, i, !0);
                    if (r.url !== i.url) {
                        const n = jy(t, r, e.mediaOptionListTuple[gu.Subtitle].mediaOptions, Qe());
                        e.mediaOptionListTuple[gu.Subtitle].mediaOptions = n
                    }
                }
            }
            _updateEnabledMediaOptionKeys(t, i) {
                var e, r;
                const n = null !== (e = t.enabledMediaOptionKeys) && void 0 !== e ? e : [Lu, Lu, Lu];
                let s;
                for (let e = 0; e < i.length; ++e) {
                    var a = i[e],
                        o = n[e].mediaOptionId !== a.mediaOptionId;
                    if (o && (n[e] = Object.assign({}, a)), e === gu.Variant) {
                        const i = this.getQueryForId(a.itemId).mediaOptionListQueries[e].mediaOptionList;
                        o ? t.abrStatus = (r = a.mediaOptionId, o = i, o = Xg(r, o), {
                            fragDownloadSlow: !1,
                            fragDownloadTooSlow: !1,
                            nextMinAutoOptionId: Lu.mediaOptionId,
                            nextMaxAutoOptionId: Lu.mediaOptionId,
                            highBWTrigger: o
                        }) : t.abrStatus.highBWTrigger = Xg(a.mediaOptionId, i), s = a
                    } else if (e === gu.Subtitle && _u(a)) {
                        const i = this.getQueryForId(a.itemId),
                            n = i.alternateMediaOptionById(e, a.mediaOptionId);
                        this._associateForcedSubtitleWithClosedCaption(t, s.mediaOptionId, n, i)
                    }
                }
                t.enabledMediaOptionKeys = n, t.nextMediaOptionKeys = void 0
            }
            setManualMode(e, t) {
                this.store.update(e, e => {
                    e.manualMode = t
                })
            }
            setEnabledMediaOptions(e, i) {
                this.store.update(e, e => {
                    var t = i.map(({
                        mediaOptionId: e,
                        itemId: t
                    }) => ({
                        mediaOptionId: e,
                        itemId: t
                    }));
                    this._updateEnabledMediaOptionKeys(e, t)
                })
            }
            setEnabledMediaOptionsAndSwitchContexts(e, i, r) {
                this.store.update(e, e => {
                    var t = i.map(({
                        mediaOptionId: e,
                        itemId: t
                    }) => ({
                        mediaOptionId: e,
                        itemId: t
                    }));
                    this._updateEnabledMediaOptionKeys(e, t), e.mediaOptionSwitchContexts = r
                })
            }
            setNextMediaOptions(e, i) {
                Do(`root.set.nextMediaOptions: ${JSON.stringify(null==i?void 0:i.map(e=>e.mediaOptionId))}`), this.store.update(e, e => {
                    var t = i ? i.map(({
                        itemId: e,
                        mediaOptionId: t
                    }) => ({
                        itemId: e,
                        mediaOptionId: t
                    })) : null;
                    e.nextMediaOptionKeys = t
                })
            }
            updateEnabledMediaOptions(e) {
                Do("root.set.updateEnabledMediaOptions"), this.store.update(e, e => {
                    e.nextMediaOptionKeys && !0 !== e.manualMode && (Do(`root.set.updateEnabledMediaOptions ${JSON.stringify(e.nextMediaOptionKeys)}`), this._updateEnabledMediaOptionKeys(e, [...e.nextMediaOptionKeys])), e.nextMediaOptionKeys = void 0
                })
            }
            setLastLoadedMediaOptionByType(r, n, s) {
                Do(`root.set.lastLoadedMediaOptionByType: ${n} ${(s=s||{itemId:r,mediaOptionType:n,mediaOptionId:"Nah"}).mediaOptionId}`), this.store.update(r, e => {
                    var t;
                    const i = null !== (t = e.lastLoadedMediaOptionKeys) && void 0 !== t ? t : [Lu, Lu, Lu];
                    i[n] = {
                        itemId: r,
                        mediaOptionId: s.mediaOptionId
                    }, e.lastLoadedMediaOptionKeys = i
                })
            }
            setPreferredHost(e, t) {
                Do(`root.set.preferredHost: ${t}`), this.store.update(e, e => {
                    e && (e.mediaOptionListTuple[gu.Variant].preferredHost = t)
                })
            }
            setViewportInfo(e, t) {
                Do(`root.set.viewportInfo: ${JSON.stringify(t)}`), this.store.update(e, e => {
                    e && (e.mediaOptionListTuple[gu.Variant].viewportInfo = t)
                })
            }
            static getExistingPersistentIds(e) {
                var t;
                const i = {},
                    r = null === (t = e.enabledMediaOptionKeys[gu.AltAudio]) || void 0 === t ? void 0 : t.mediaOptionId;
                if ("Nah" !== r) {
                    const s = e.mediaOptionListTuple[gu.AltAudio],
                        t = Km(s.mediaOptions, Ny.kAllowFilters, s).find(e => e.mediaOptionId === r);
                    i.audioPersistentId = null == t ? void 0 : t.persistentID
                }
                const n = null === (t = e.enabledMediaOptionKeys[gu.Subtitle]) || void 0 === t ? void 0 : t.mediaOptionId;
                if ("Nah" !== n) {
                    const s = e.mediaOptionListTuple[gu.Subtitle],
                        t = Km(s.mediaOptions, Ny.kAllowFilters, s).find(e => e.mediaOptionId === n);
                    i.subtitlePersistentId = null == t ? void 0 : t.persistentID
                }
                return i
            }
            static doUpdateRootHDRSwitch(e, t, i, r) {
                const n = e.mediaOptionListTuple.map(e => Object.assign({}, e));
                n[gu.Variant].preferHDR = t, n[gu.Variant].hasHdrLevels = i;
                const s = mg(),
                    a = sy.getEntity(e.itemId),
                    o = Zf(e.itemId),
                    l = o.getBandwidthEstimate(s, null == a ? void 0 : a.serviceName),
                    d = o.getPlaylistEstimate(s, null == a ? void 0 : a.serviceName),
                    u = o.getFragEstimate(s, null == a ? void 0 : a.serviceName),
                    c = o.getBufferEstimate(s, null == a ? void 0 : a.serviceName),
                    h = {
                        targetDuration: u.maxDurationSec || (null == s ? void 0 : s.defaultTargetDuration),
                        targetStartupMs: null == s ? void 0 : s.targetStartupMs
                    },
                    p = Uy.getExistingPersistentIds(e);
                return Qy(Object.assign(Object.assign({}, e), {
                    mediaOptionListTuple: n,
                    nextMediaOptionKeys: null
                }), p, r, l, h, d, u, c)
            }
            switchToSDROnly(e) {
                Do("root.switchToSDROnly"), this.store.update(e, e => {
                    var t = Uy.doUpdateRootHDRSwitch(e, !1, !1, this.logger)["mediaOptionListTuple"];
                    e.mediaOptionListTuple = t
                })
            }
            setHDRPreference(e, i, r) {
                Do(`root.set.HDRPreference: ${i}`), this.store.update(e, e => {
                    var t = e.mediaOptionListTuple[gu.Variant];
                    if (t.preferHDR !== i && (!i || t.hasHdrLevels)) {
                        t = Uy.doUpdateRootHDRSwitch(e, i, t.hasHdrLevels, this.logger);
                        if (r) return t;
                        e.mediaOptionListTuple = t.mediaOptionListTuple
                    }
                })
            }
            setPathwayPriority(e, i) {
                Do(`root.set.PathwayPriority: [ ${i.join(", ")} ]`), this.store.update(e, e => {
                    if (e) {
                        const t = e.mediaOptionListTuple[gu.Variant];
                        t.pathwayPriority = i, t.preferredHost = null
                    }
                })
            }
            setCurrentPathwayID(e, t) {
                Do(`root.set.currentPathwayID: ${t}`), this.store.update(e, e => {
                    e && (e.mediaOptionListTuple[gu.Variant].currentPathwayID = t)
                })
            }
            setInitPTS(e, t, i, r, n, s) {
                Do(`root.set.initPTS: ${e} ${t} variantDTS:${JSON.stringify(i)} timelineOffset: ${r}`), this.store.update(e, e => {
                    e.initPtsRecord[t] = {
                        variantDTS: i,
                        timelineOffset: r,
                        offsetTimestamp: n,
                        iframeMode: s
                    }
                })
            }
            static prunePenaltyBox(e, t) {
                return e.filter(e => !(e.expiry <= t))
            }
            static addToPenaltyBox(e, t, i) {
                return e.push({
                    mediaOptionId: i,
                    expiry: t + 12e4
                })
            }
            addToPenaltyBox(e, r, n) {
                Do(`root.set.penaltyBox: ${r}: ${n}`), this.store.update(e, ({
                    mediaOptionListTuple: e
                }) => {
                    const t = e[r],
                        i = performance.now();
                    t.penaltyBoxQueue = Uy.prunePenaltyBox(t.penaltyBoxQueue, i), Uy.addToPenaltyBox(t.penaltyBoxQueue, i, n)
                })
            }
            prunePenaltyBox(e, r = null) {
                Do(`root.set.prunePenaltyBox: ${r}`), this.store.update(e, ({
                    mediaOptionListTuple: e
                }) => {
                    var e = r ? [e[r]] : e,
                        t = performance.now();
                    for (const i of e) i.penaltyBoxQueue = Uy.prunePenaltyBox(i.penaltyBoxQueue, t)
                })
            }
            removePermanently(e, r, n) {
                Do(`root.set.removePermanently: ${r}: ${n}`), this.store.update(e, ({
                    mediaOptionListTuple: e
                }) => {
                    const t = e[r],
                        i = new Set(t.removed);
                    i.add(n), t.removed = Array.from(i)
                })
            }
            moveAllWithMatchingHosts(e, r, n, s) {
                Do(`root.set.moveAllMatchingHosts: ${r}:${n} remove:${s}`), this.store.update(e, ({
                    mediaOptionListTuple: e
                }) => {
                    const t = e[r],
                        i = [...t.mediaOptions].filter(e => Au(n, e.url)).map(e => e.mediaOptionId);
                    if (s) {
                        const e = new Set([...t.removed, ...i]);
                        t.removed = Array.from(e)
                    } else {
                        const e = performance.now();
                        t.penaltyBoxQueue = Uy.prunePenaltyBox(t.penaltyBoxQueue, e);
                        for (const r of i) Uy.addToPenaltyBox(t.penaltyBoxQueue, e, r)
                    }
                })
            }
            setMaxHdcpLevel(e, i, r = !1) {
                Do(`root.set.maxHdcpLevel: ${i}`), this.store.update(e, ({
                    mediaOptionListTuple: e
                }) => {
                    const t = e[gu.Variant];
                    (r || um(i) < um(t.maxHdcpLevel)) && (t.maxHdcpLevel = i)
                })
            }
            updateConsecutiveTimeouts(e, i, r, n) {
                this.store.update(e, e => {
                    const t = e.errorsByType || [{
                        timeouts: {
                            load: 0,
                            append: 0,
                            key: 0
                        }
                    }, {
                        timeouts: {
                            load: 0,
                            append: 0,
                            key: 0
                        }
                    }, {
                        timeouts: {
                            load: 0,
                            append: 0,
                            key: 0
                        }
                    }];
                    r ? ++t[i].timeouts[n] : t[i].timeouts[n] = 0, e.errorsByType = t
                })
            }
            updateInflightFrag(l, d, u, c, h) {
                Do("root.set.updateInflightFrag"), this.store.update(l, r => {
                    if (r.inFlightFrags || (r.inFlightFrags = [null, null]), !(d === gu.Subtitle || u && u.itemId !== l))
                        if (u) {
                            let {
                                start: e,
                                duration: t
                            } = u;
                            var {
                                mediaOptionId: n,
                                mediaSeqNum: s,
                                discoSeqNum: a
                            } = u, o = r.inFlightFrags[d];
                            let i = null == o ? void 0 : o.tstart;
                            c !== (null == o ? void 0 : o.state) && (i = performance.now()), $p(o, u) && (e = o.start, t = o.duration), r.inFlightFrags[d] = {
                                itemId: l,
                                mediaOptionId: n,
                                mediaSeqNum: s,
                                discoSeqNum: a,
                                start: e,
                                duration: t,
                                tstart: i,
                                state: c,
                                bwSample: Object.assign({}, h)
                            }
                        } else r.inFlightFrags[d] = null
                })
            }
            setNextMaxAutoOptionId(e, t) {
                Do(`root.set.nextMaxAutoOptionId: ${t}`), this.store.update(e, ({
                    abrStatus: e
                }) => {
                    e.nextMaxAutoOptionId = t
                })
            }
            setNextMinAutoOptionId(e, t) {
                Do(`root.set.nextMinAutoOptionId: ${t}`), this.store.update(e, ({
                    abrStatus: e
                }) => {
                    e.nextMinAutoOptionId = t
                })
            }
            setHighBWTrigger(e, t) {
                Do(`root.set.setHighBWTrigger: ${t}`), this.store.update(e, ({
                    abrStatus: e
                }) => {
                    e.highBWTrigger = t
                })
            }
            setFragLoadSlow(e, t) {
                Do(`root.set.setFragLoadSlow ${e} ${JSON.stringify(t)}`), this.store.update(e, ({
                    abrStatus: e
                }) => {
                    e.fragDownloadSlow = t.fragDownloadSlow, e.fragDownloadTooSlow = t.fragDownloadTooSlow
                })
            }
            pickMediaOptionTupleByPersistentId(e, t, i, r = !1, n = !1) {
                var s = e.enabledMediaOptionIdByType(gu.Variant),
                    s = e.variantMediaOptionById(s);
                let a, o;
                if (t === gu.AltAudio) {
                    const t = e.enabledAlternateMediaOptionByType(gu.Subtitle);
                    o = null == t ? void 0 : t.persistentID, a = i
                } else {
                    const t = e.enabledAlternateMediaOptionByType(gu.AltAudio);
                    a = null == t ? void 0 : t.persistentID, o = i
                }
                const l = e.getEnabledMediaOptionMask();
                return l[t] = !!(ne(i) && 0 <= i), s ? this.getBestMediaOptionTupleFromVariantAndPersistentId(e, s, a, o, l, void 0, r, n, !1) : [Lu, Lu, Lu]
            }
            getFallbackMediaOptionTupleFromMediaOptionId(e, t, i, r, n = !1, s = !1, a = !1) {
                var o = r ? [r] : [i],
                    l = e.enabledMediaOptionIdByType(gu.Variant),
                    r = e.variantMediaOptionById(l),
                    l = t === gu.AltAudio ? e.alternateMediaOptionById(gu.AltAudio, i) : e.enabledAlternateMediaOptionByType(gu.AltAudio),
                    l = null == l ? void 0 : l.persistentID,
                    i = t === gu.Subtitle ? e.alternateMediaOptionById(gu.Subtitle, i) : e.enabledAlternateMediaOptionByType(gu.Subtitle),
                    i = null == i ? void 0 : i.persistentID;
                return r ? this.getBestMediaOptionTupleFromVariantAndPersistentId(e, r, l, i, void 0, o, n, s, a) : [Lu, Lu, Lu]
            }
            hasFallbackMediaOptionTuple(e, t, i, r) {
                var n = e.mediaOptionListQueries[t].mediaOptionFromId(i);
                return e.isValidMediaOptionTuple(this.getFallbackMediaOptionTupleFromMediaOptionId(e, t, i, n.backingMediaOptionId, !1, r))
            }
            setLegacyAlternateMediaOption(e, t, i, r, n) {
                var s = e.enabledMediaOptionIdByType(gu.Variant),
                    s = e.variantMediaOptionById(s),
                    s = e.getLegacyMatchingAlternateWithPersistentId(i, r, s);
                s ? this.setEnabledMediaOptionByType(t, i, s, !0, n) : this.logger.warn(`${Nu[i]} can't find matching mediaOption for persistent id ${r}`)
            }
            setEnabledMediaOptionTupleWithMatchedGroups(t, i, e, r) {
                const n = Ky(t),
                    s = this.pickMediaOptionTupleByPersistentId(n, i, e);
                if (!n.isValidMediaOptionTuple(s)) return this.setLegacyAlternateMediaOption(n, t, i, e, r);
                al(() => {
                    this.setEnabledMediaOptionByType(t, i, s[i], !0, r), s[gu.Variant].mediaOptionId !== n.enabledMediaOptionIdByType(gu.Variant) && this.setPreferredHost(t, Eu(s[gu.Variant].url)), this.setEnabledMediaOptionByType(t, gu.Variant, s[gu.Variant]);
                    var e = i === gu.AltAudio ? gu.Subtitle : gu.AltAudio;
                    s[e].mediaOptionId !== n.enabledMediaOptionIdByType(e) && this.setEnabledMediaOptionByType(t, e, s[e], !1)
                })
            }
            canSwitchToSDR(e, t, i, r = !1) {
                var n = e.mediaOptionListQueries[gu.Variant].mediaOptionFromId(t),
                    r = this.getFallbackMediaOptionTupleFromMediaOptionId(e, gu.Variant, t, n.backingMediaOptionId, !0, i, r);
                return e.isValidMediaOptionTuple(r)
            }
            getBestMediaOptionTupleFromVariantAndPersistentId(t, e, i, r, n, s, a, o, l) {
                var d, u = t.mediaOptionListQueries[gu.Variant].listFallbackVariants(e.mediaOptionId, a, o, l, s);
                let c = [Lu, Lu, Lu];
                for (let e = 0; e < u.length; ++e) {
                    const a = u[e];
                    if (d = t.matchAlternates(a, i, r, s), t.isValidMediaOptionTuple([a, ...d], n)) {
                        c = [a, ...d];
                        break
                    }
                }
                return c
            }
        }
        const $y = new class extends fl {
            constructor() {
                super({}, {
                    name: "root-playlist-store",
                    idKey: "itemId",
                    producerFn: su
                })
            }
            akitaPreAddEntity(e) {
                return null == e.errorsByType ? Object.assign(Object.assign({}, e), {
                    errorsByType: [{
                        timeouts: {
                            load: 0,
                            append: 0,
                            key: 0
                        }
                    }, {
                        timeouts: {
                            load: 0,
                            append: 0,
                            key: 0
                        }
                    }, {
                        timeouts: {
                            load: 0,
                            append: 0,
                            key: 0
                        }
                    }]
                }) : e
            }
        };
        new kl($y);
        let Vy = null;

        function Ky(e) {
            return new Fy($y, e)
        }
        const qy = (n, e, t, s, i) => {
            const {
                rootMediaOptionsTuple: r,
                sessionKeys: a
            } = n, o = Array.from(r[gu.Variant]), l = Array.from(r[gu.AltAudio]);
            let d = !1,
                u = !1,
                c = o.map(e => (d = d || Boolean(e.videoCodec), u = u || Boolean(e.audioCodec) || Boolean(e.audioGroupId), e));
            return d && u && (c = c.filter(({
                videoCodec: e
            }) => Boolean(e))), Ly(o, l, a, e, t, i).pipe(hr(({
                hdrMediaOptions: e,
                sdrMediaOptions: t
            }) => {
                var i = e.concat(t),
                    r = 0 < e.length;
                return e.concat(t),
                    function(e, t, i, r) {
                        var {
                            itemId: n,
                            itemStartOffset: s,
                            rootMediaOptionsTuple: a,
                            audioMediaSelectionGroup: o,
                            subtitleMediaSelectionGroup: l
                        } = e, d = Array.from(a[gu.AltAudio]), u = Array.from(a[gu.Subtitle]), c = t.every(e => ne(e.score)), h = t.some(e => Wm(!0, e)), p = function(e, t) {
                            const i = [...e];
                            return t ? i.sort((e, t) => e.score - t.score || t.bitrate - e.bitrate) : i.sort((e, t) => e.bitrate - t.bitrate), i
                        }(t, c), f = e.baseUrl, t = null === (a = e.contentSteeringOption) || void 0 === a ? void 0 : a.initPathwayID, a = e.sessionData;
                        return {
                            itemId: n,
                            baseUrl: f,
                            mediaOptionListTuple: [{
                                mediaOptions: p,
                                hasHdrLevels: i,
                                hasIframeLevels: h,
                                hasScore: c,
                                preferHDR: r,
                                compatibleIds: null,
                                penaltyBoxQueue: [],
                                removed: [],
                                currentPathwayID: t
                            }, {
                                mediaOptions: d,
                                compatibleIds: null,
                                penaltyBoxQueue: [],
                                removed: []
                            }, {
                                mediaOptions: u,
                                penaltyBoxQueue: [],
                                removed: []
                            }],
                            audioMediaSelectionGroup: o,
                            subtitleMediaSelectionGroup: l,
                            enabledMediaOptionKeys: [Lu, Lu, Lu],
                            mediaOptionSwitchContexts: [null, null, null],
                            anchorTime: {
                                pos: 0
                            },
                            discoSeqNum: NaN,
                            pendingSeek: void 0,
                            itemStartOffset: s,
                            initPtsRecord: {},
                            contentSteeringOption: e.contentSteeringOption,
                            masterVariableList: e.masterVariableList,
                            loadStats: e.stats,
                            isMediaPlaylist: e.isMediaPlaylist,
                            abrStatus: {
                                fragDownloadSlow: !1,
                                fragDownloadTooSlow: !1,
                                nextMinAutoOptionId: Lu.mediaOptionId,
                                nextMaxAutoOptionId: Lu.mediaOptionId,
                                highBWTrigger: NaN
                            },
                            sessionData: a
                        }
                    }(n, i, r, s)
            }))
        };

        function Hy(e, t, i, r, n, s, a) {
            var o, l, d, u, c, h, p, f = e.mediaOptionListTuple[gu.Variant],
                m = Km(f.mediaOptions, Xm.kAllowFilters, Object.assign(Object.assign({}, f), {
                    compatibleIds: null
                })),
                g = qm(f.preferredHost, m);
            return {
                firstVariant: (o = g, e = Fg, f = f.hasScore, t = t, i = i, r = r, n = n, s = s, a = a, !o || o.length < 1 || o.every(e => e.iframes) ? void t.warn("no non-iframe media option found") : ((o = f ? Bg(o, i, r, n, s, a) : (l = e, d = i, u = r, c = n, h = s, p = a, o.reduce((e, t) => {
                    if (t.iframes) return e;
                    let i = e;
                    const r = function(e, t, i, r, n, s, a) {
                        var o, l, d = (o = e.bitrate, u = e.height, (l = (e, t, i) => (e - t) * (e - i) <= 0)(o, t.minValidBitrate, t.maxValidBitrate) && l(u, t.minValidHeight, t.maxValidHeight) ? mu.VALID : mu.INVALID),
                            o = "PQ" === (c = e.videoRange) ? pu.PQ : "HLG" === c ? pu.HLG : "SDR" === c ? pu.SDR : pu.UNKNOWN,
                            {
                                videoCodecRank: u,
                                audioCodecRank: c
                            } = {
                                videoCodecRank: qp((l = e).videoCodec),
                                audioCodecRank: jp(l.audioCodec)
                            },
                            l = e.bitrate < t.maxPreferredBitrate ? mu.VALID : mu.INVALID,
                            t = e.audioChannelCount || 1,
                            a = i && r && n && s && !Ug(e, i, r, n, s, a) ? mu.INVALID : mu.VALID;
                        return new Qp(d, o, u, t, c, a, l, e.height)
                    }(t, l, d, u, c, h, p);
                    return (!e || r.isGreaterThan(e.bestRank) || r.isEqualTo(e.bestRank) && t.bitrate > e.selected.bitrate) && (i = {
                        selected: t,
                        bestRank: r
                    }), i
                }, null).selected)) || t.warn("no valid first media option found"), o)),
                filteredVariants: m,
                preferredVariants: g
            }
        }

        function jy(e, t, i) {
            if ((null == t ? void 0 : t.mediaType) === Su.CLOSEDCAPTION) {
                const r = Ny.pairForcedSubtitleMediaOptionWithClosedCaptionInList(e.subtitleGroupId, t, i);
                if (r) return t = Object.assign(Object.assign({}, t), {
                    url: r.url,
                    backingMediaOptionId: r.mediaOptionId
                }), i.map(e => e.mediaOptionId === t.mediaOptionId ? t : e)
            }
            return i
        }

        function Qy(e, t, i, r, n, s, a, o) {
            var l;
            const d = e.itemId,
                u = e.mediaOptionListTuple[gu.Variant],
                c = e.mediaOptionListTuple[gu.AltAudio],
                h = e.mediaOptionListTuple[gu.Subtitle],
                p = Km(c.mediaOptions, Ny.kAllowFilters, c),
                f = Km(h.mediaOptions, Ny.kAllowFilters, h);
            let {
                firstVariant: m,
                filteredVariants: g
            } = Hy(e, i, r, n, s, a, o);
            if (!m) {
                const U = u.preferHDR;
                u.preferHDR = !U && u.hasHdrLevels, u.preferHDR !== U && (i.warn(`No valid first variant found, toggling hdr preference=${U}->${u.preferHDR}`), {
                    firstVariant: m,
                    filteredVariants: g
                } = Hy(e, i, r, n, s, a, o))
            }
            if (!m) throw new V(!0, "No valid first variant found", $.NoValidAlternates);
            const y = Eu(m.url),
                v = {
                    itemId: d,
                    mediaOptionId: null !== (o = null == m ? void 0 : m.mediaOptionId) && void 0 !== o ? o : null
                },
                S = null != p && p.length ? null === (o = ((i, r, e, n) => {
                    if (e) {
                        let t;
                        return t = ne(i) ? e.MediaSelectionGroupOptions.find(function(e) {
                            return e.MediaSelectionOptionsPersistentID === i
                        }) : e.MediaSelectionGroupOptions.find(function(e) {
                            return e.MediaSelectionOptionsIsDefault
                        }), t = t || e.MediaSelectionGroupOptions[0], n.find(e => (!r || e.groupId === r) && e.persistentID === (null == t ? void 0 : t.MediaSelectionOptionsPersistentID))
                    }
                })(null == t ? void 0 : t.audioPersistentId, m.audioGroupId, e.audioMediaSelectionGroup, p)) || void 0 === o ? void 0 : o.mediaOptionId : null,
                b = S ? {
                    itemId: d,
                    mediaOptionId: S
                } : Lu,
                T = ((i, r, n, s, a, o) => {
                    if (s) {
                        let t, e;
                        return t = ne(i) ? s.MediaSelectionGroupOptions.find(function(e) {
                            return e.MediaSelectionOptionsPersistentID === i
                        }) : s.MediaSelectionGroupOptions.find(function(e) {
                            return e.MediaSelectionOptionsIsDefault
                        }), t && (e = a.find(e => e.mediaType === Su.CLOSEDCAPTION ? (!r || e.groupId === r) && e.persistentID === t.MediaSelectionOptionsPersistentID : e.mediaType === Su.SUBTITLE ? (!n || e.groupId === n) && e.persistentID === t.MediaSelectionOptionsPersistentID : void o.warn(By, `subtitle media option has unknown type ${e.mediaType}`))), e
                    }
                })(null == t ? void 0 : t.subtitlePersistentId, m.closedcaption, m.subtitleGroupId, e.subtitleMediaSelectionGroup, f, i),
                E = null != f && f.length ? null == T ? void 0 : T.mediaOptionId : null,
                I = E ? {
                    itemId: d,
                    mediaOptionId: E,
                    mediaOptionType: gu.Subtitle
                } : Lu,
                {
                    mediaOptions: w,
                    audioGroups: A,
                    subtitleGroups: O
                } = (t = g, l = m, t.reduce((e, t) => {
                    if (((e, t) => {
                            let i = !0;
                            e.videoCodec && t.videoCodec && (i = be.isCompatibleVideoCodec(e.videoCodec, t.videoCodec));
                            let r = !1;
                            e.videoRange && t.videoRange ? r = e.videoRange == t.videoRange : e.videoRange || t.videoRange || (r = !0);
                            let n = !0;
                            return e.audioCodec && t.audioCodec && (n = be.isCompatibleAudioCodec(e.audioCodec, t.audioCodec)), i && r && n
                        })(l, t)) {
                        const l = t.audioGroupId;
                        l && e.audioGroups.add(l), e.mediaOptions.add(t)
                    }
                    var i = t.subtitleGroupId;
                    i && e.subtitleGroups.add(i);
                    t = t.closedcaption;
                    return t && e.closedCaptionGroups.add(t), e
                }, {
                    mediaOptions: new Set,
                    audioGroups: new Set,
                    subtitleGroups: new Set,
                    closedCaptionGroups: new Set
                })),
                k = Array.from(w).map(e => e.mediaOptionId),
                C = m.pathwayID,
                D = Object.assign(Object.assign({}, u), {
                    compatibleIds: k,
                    preferredHost: y,
                    currentPathwayID: C
                }),
                M = [],
                x = c.mediaOptions.reduce((e, t) => (A.has(t.groupId) && (e.persistentIds.add(t.persistentID), M.push(t.mediaOptionId), e.filteredAudioMediaOptions.push(t), e.altAudio || (e.altAudio = !!t.url)), e), {
                    filteredAudioMediaOptions: [],
                    persistentIds: new Set,
                    altAudio: !1
                }),
                P = Object.assign(Object.assign({}, c), {
                    compatibleIds: M
                });
            let R = e.audioMediaSelectionGroup;
            const L = null == R ? void 0 : R.MediaSelectionGroupOptions;
            if (L) {
                const e = L.reduce((e, t) => (x.persistentIds.has(t.MediaSelectionOptionsPersistentID) && e.push(t), e), new Array);
                R = Object.assign(Object.assign({}, R), {
                    MediaSelectionGroupOptions: e
                })
            }
            h.mediaOptions = jy(m, T, h.mediaOptions);
            const _ = h.mediaOptions.reduce((e, t) => (O.has(t.groupId) && (e.persistentIds.add(t.persistentID), e.filteredSubtitleMediaOptions.push(t)), e), {
                filteredSubtitleMediaOptions: [],
                persistentIds: new Set
            });
            let N = e.subtitleMediaSelectionGroup;
            const F = null == N ? void 0 : N.MediaSelectionGroupOptions;
            if (F) {
                const e = F.reduce((e, t) => (_.persistentIds.has(t.MediaSelectionOptionsPersistentID) && e.push(t), e), new Array);
                N = Object.assign(Object.assign({}, N), {
                    MediaSelectionGroupOptions: e
                })
            }
            i = [D, P, h];
            let B = new Map;
            mg().useHighestVideoCodecPrivate && (B = null == D ? void 0 : D.mediaOptions.reduce((e, t) => {
                const i = t.videoCodecList;
                if (i)
                    for (const t of i) {
                        const i = Hp(t),
                            r = e.get(i);
                        be.isHigherCodecByFamily(r, t) && e.set(i, t)
                    }
                return e
            }, B)), B.size && B.forEach((e, t) => {});
            t = {
                fragDownloadSlow: !1,
                fragDownloadTooSlow: !1,
                nextMinAutoOptionId: Lu.mediaOptionId,
                nextMaxAutoOptionId: Lu.mediaOptionId,
                highBWTrigger: Xg(v.mediaOptionId, D.mediaOptions)
            };
            return Object.assign(Object.assign({}, e), {
                enabledMediaOptionKeys: [v, b, I],
                mediaOptionListTuple: i,
                audioMediaSelectionGroup: R,
                abrStatus: t,
                highestVideoCodec: B
            })
        }
        const Wy = (o, l, d, u, c, h, p) => e => e.pipe(tc("retrieveRootMediaOptions.input"), La(t => {
            var e;
            if (!t) return Ii;
            const {
                itemId: i,
                platformInfo: r
            } = t, n = Ky(i), s = l["logger"];
            if (n.hasEntity(i)) return $i(n);
            $y.setLoading(!0);
            const a = performance.now();
            return function(e, t, u, c, i) {
                const {
                    itemId: h,
                    url: p,
                    itemStartOffset: f
                } = e, r = Lc(e, t);
                return Lm({
                    url: p,
                    onProgress: {
                        getData: !0,
                        cb: Iy
                    },
                    xhrSetup: c.xhrSetup
                }, r, i).pipe(hr(({
                    responseText: e,
                    responseURL: t,
                    stats: i
                }) => {
                    var r = c["keySystemPreference"];
                    if (t || (u.warn("Missing response url. Reusing request url as base url"), t = p), Rm.isMediaPlaylist(e)) {
                        const c = "media-pl-" + Zl(),
                            d = Rm.parseMediaOptionPlaylist(e, t, !0, r, {}, h, c, gu.Variant, u, f);
                        Nc(d.mediaOptionDetails);
                        var n = {
                            itemId: h,
                            mediaOptionId: c,
                            mediaOptionType: gu.Variant,
                            url: p,
                            bandwidth: 0,
                            bitrate: 0,
                            iframes: d.mediaOptionDetails.iframesOnly,
                            pathwayID: "."
                        };
                        return {
                            itemId: h,
                            itemStartOffset: f,
                            rootMediaOptionsTuple: [
                                [n],
                                [],
                                []
                            ],
                            stats: i,
                            baseUrl: t,
                            initialDetails: d.mediaOptionDetails,
                            isMediaPlaylist: !0
                        }
                    } {
                        const u = Rm.parseSessionData(e, t),
                            c = Rm.parseSessionKeys(e, t, r),
                            p = Rm.parseRootPlaylist(h, e, t, !0);
                        if (p.playlistParsingError) throw p.playlistParsingError;
                        var {
                            variantMediaOptions: s,
                            contentSteeringOption: a,
                            masterVariableList: o
                        } = p, l = Rm.parseRootPlaylistAlternateMediaOptions(h, e, t, p.variantMediaOptions, !0, o);
                        if (l.playlistParsingError) throw l.playlistParsingError;
                        var {
                            audioAlternateOptions: n,
                            subtitleAlternateOptions: r,
                            audioMediaSelectionGroup: e,
                            subtitleMediaSelectionGroup: l
                        } = l.alternateMediaInfo;
                        return {
                            itemId: h,
                            itemStartOffset: f,
                            rootMediaOptionsTuple: [s, n, r],
                            stats: i,
                            baseUrl: t,
                            audioMediaSelectionGroup: e,
                            subtitleMediaSelectionGroup: l,
                            contentSteeringOption: a,
                            sessionData: u,
                            sessionKeys: c,
                            masterVariableList: o
                        }
                    }
                }), e => e.pipe(Vn(e => {
                    if (e instanceof pc) throw new dc(!1, "Timeout", 0, $.ManifestTimeoutError, !0);
                    if (e instanceof oc) throw new dc(!1, e.message, e.code, {
                        code: e.code,
                        text: "Manifest network error"
                    }, !1);
                    throw e
                })))
            }(t, o, s, d, null === (e = null === (e = fg()) || void 0 === e ? void 0 : e.getQuery()) || void 0 === e ? void 0 : e.extendMaxTTFB).pipe(Za(e => p.triggerManifestLoaded(e)), Za(({
                initialDetails: e,
                stats: t
            }) => {
                e && (e = e, t = t, Cg().archiveMediaOptionDetails(e, t, !0))
            }), bo(u.displaySupportsHdr$), La(([e, t]) => qy(e, r, d, t, s)), hr(e => (l.rootPlaylistEntity = function(e, t, i, r, n, s) {
                const {
                    itemId: a,
                    initialSeekTime: o
                } = e, l = Zf(a), d = n.enableAdaptiveStartup ? l.getBandwidthEstimate(n, e.serviceName) : void 0, u = n.enableAdaptiveStartup ? l.getPlaylistEstimate(n, e.serviceName) : void 0, c = n.enableAdaptiveStartup ? l.getFragEstimate(n, e.serviceName) : void 0, h = n.enableAdaptiveStartup ? l.getBufferEstimate(n, e.serviceName) : void 0, p = performance.now() - r;
                let f;
                n.targetStartupMs > p ? f = n.targetStartupMs - p : (f = n.targetStartupMs, s.warn(`Manifest load took ${p}ms and exceeds targetStartupMs: ${n.targetStartupMs}; resetting targetStartupMs to ${n.targetStartupMs}`));
                const m = n.enableAdaptiveStartup ? {
                        targetDuration: c.maxDurationSec || n.defaultTargetDuration,
                        targetStartupMs: f
                    } : void 0,
                    g = Qy(t, i, s, d, m, u, c, h);
                return g.pendingSeek = o, g
            }(t, e, c, a, d, s), n)), lg(i, null, Lc(t, o), 0, !1, n, l, h), Vs(() => {
                $y.setLoading(!1)
            }))
        }), tc("retrieveRootMediaOptions.emit"));

        function Gy(t, o, l, d, u, c, h) {
            return e => e.pipe(Kp(), La(e => {
                return e ? Mr([$i(e).pipe(Wy(t.manifestLoadPolicy, l, t, d, null, u, c)), (n = t, s = o, a = h.mux, new $t(e => {
                    const t = new Ty(n, s, a);
                    return e.next(t), () => {
                        t.destroy()
                    }
                })), (i = t.trickPlaybackConfig, r = o, new $t(e => {
                    var t = new Zu(i, r);
                    return e.next(t), () => {}
                }))]).pipe(hr(([e, t, i]) => ({
                    rootPlaylistQuery: e,
                    mediaParser: t,
                    iframeMachine: i
                }))) : $i(null);
                var i, r, n, s, a
            }))
        }
        wc;
        return class zy extends wc {
            constructor(e = {}, t) {
                var i;
                if (super(), this.destroy$ = new Xt, this.mediaElement$ = new yi(null), this.publicQueriesInternal$ = new yi(null), this.mediaElementAdapter = null, this.rpcService = null, this.rpcClients = null, this.platformService = Af(), this.keySystemAdapter = null, this.legibleSystemAdapter = null, this.sessionID = Zl(), this.statsService = (Jf = Jf || new Xf(Yf), Jf), this.gaplessCapable = !0, this.teardownWG$ = new Xp, this.itemQueue = new ay, (e.liveSyncDurationCount || e.liveMaxLatencyDurationCount) && (e.liveSyncDuration || e.liveMaxLatencyDuration)) throw new Error("Illegal hls.js config: don't mix up liveSyncDurationCount/liveMaxLatencyDurationCount and liveSyncDuration/liveMaxLatencyDuration");
                const m = Object.assign(Object.assign({}, Ru), e);
                if (m.maxRequiredStartDuration < m.minRequiredStartDuration || m.minRequiredStartDuration < 0) throw new Error("Illegal config: bad maxRequiredStartDuration or minRequiredStartDuration");
                i = (this.hlsConfig = m).buildType, oe = "production" === i;
                const r = this.sessionID;
                let n = "silent";
                e.debug && (n = m.debugLevel), au(!0), this.logger = null !== (i = this.logger) && void 0 !== i ? i : ([M, h = {}] = [r, (c = {
                    sendLogs: m.sendLogs || null,
                    level: "log" === n ? "debug" : n,
                    consoleOverride: "boolean" != typeof e.debug ? e.debug : void 0,
                    buildType: m.buildType
                }, x = c.consoleOverride, Object.assign({
                    name: "hls",
                    timestamp: c.sendLogs ? Oe.stdTimeFunctions.epochTime : Oe.stdTimeFunctions.isoTime,
                    browser: {
                        asObject: !0,
                        serialize: !0,
                        transmit: {
                            send: (e, t) => {}
                        },
                        write: {
                            debug: qe.bind(null, Ke(x || console, "debug"), "debug"),
                            info: qe.bind(null, Ke(x || console, "info"), "info"),
                            warn: qe.bind(null, Ke(x || console, "warn"), "warn"),
                            error: qe.bind(null, Ke(x || console, "error"), "error"),
                            fatal: qe.bind(null, Ke(x || console, "error"), "fatal")
                        }
                    }
                }, c))], Ue && Ue.sessionId === M ? Ue.warn("Logger Singleton already setup, returning existing singleton") : (Ue = Oe($e(h)).child({
                    sessionId: M,
                    name: "hls"
                }), Ue.qe = e => Ue.info(e), Ue.sessionId = M), Ue), _o = !1, Lo && (delete window.$$stores, delete window.$$queries), this.hlsConfig.audioPrimingDelay = 0, this.rootPlaylistService = (x = this.logger, Vy = new Uy($y, x), Vy), this.customUrlLoader = Pc(), this.sessionDataLoader = new Fp(m, Cc, this.customUrlLoader.load, this.logger);
                var s, a, o, l, d, u, c = m.liveMaxLatencyDurationCount,
                    h = m.liveSyncDurationCount;
                if (ne(c) && ne(h) && c <= h) throw new Error('Illegal hls.js config: "liveMaxLatencyDurationCount" must be gt "liveSyncDurationCount"');
                if (ne(m.liveMaxLatencyDuration) && (m.liveMaxLatencyDuration <= m.liveSyncDuration || !ne(m.liveSyncDuration))) throw new Error('Illegal hls.js config: "liveMaxLatencyDuration" must be gt "liveSyncDuration"');
                const p = fg();
                p.setHlsEntity({
                    id: r,
                    config: m
                });
                const f = Cg(),
                    g = new Tf(If),
                    y = (Rh = Rh || new xh(Ph), Rh);
                this.accessLogInstance = new rm(this, r), this.rtcService = new Kf(this, m, this.accessLogInstance, this.logger), this.playerEvents = new Ng(this, this.logger, this.rtcService);
                const v = (M = this.platformService, u = M, (() => {
                        if ("function" == typeof matchMedia) {
                            var e = matchMedia("(dynamic-range: high)"),
                                t = matchMedia("bad query");
                            if (e.media !== t.media) return an($i(e), rn(e, "change")).pipe(hr(e => e.matches))
                        }
                        return $i(!0)
                    })().pipe(Za(e => {
                        u.updateSupportsHdr(e)
                    })).pipe($a(Ii))),
                    S = this.mediaElement$.pipe((s = m, o = (a = this).logger, l = this.teardownWG$, d = this.rtcService, e => e.pipe(tc("playback.mediaElementServiceEpic.in"), La(e => {
                        if (!e) return $i(null);
                        const t = new vf(e, bf, s, a, o, l, d);
                        return t.openMediaSource(new MediaSource), an($i(t), t)
                    }), tc("playback.mediaElementServiceEpic.emit"))), Aa()),
                    b = this.itemQueue.activeItemById$.pipe(La(e => e ? tm(m, this.statsService, e, this.logger) : Ii));
                this.rpcService = (() => {
                    let e = null;
                    return null != m.createRPCService && (e = Lf(m.createRPCService, xf)), m.enableWorker && null == e && (e = _f), null == e && (e = xf), e(this.logger)
                })(), this.rpcClients = (x = this.rpcService, {
                    crypto: new kf(x),
                    mux: new Cf(x)
                });
                var T, E, I, w, A, O, k, C, D, c = Mr([this.itemQueue.activeItemById$.pipe(Gy(m, this.logger, this.rootPlaylistService, g, this.statsService, this.playerEvents, this.rpcClients), Za(e => {
                        var t = null == e ? void 0 : e.rootPlaylistQuery;
                        this.publicQueriesInternal$.next([t, null]), this.iframeMachine = null == e ? void 0 : e.iframeMachine, t && this.playerEvents.triggerManifestParsed(t)
                    })), S.pipe((I = this.itemQueue.removedItems$, w = y, A = m, O = g, C = (k = this).rtcService, D = this.logger, e => Mr([((n, s, a, o, l, d, u) => e.pipe(tc("[Keys] playback.keySystemServiceEpic.in"), La(r => r ? new $t(e => {
                        let t = new Dh(n, r, a, o, l, d, u);
                        const i = an($i(t), s.pipe(jr(e => t.removeKeysForItems(e)), $a(Ii))).subscribe(e);
                        return function() {
                            u.warn("[Keys] playback.keySystemServiceEpic.unsubscribe"), i.unsubscribe(), t.destroy().subscribe(), t = void 0
                        }
                    }) : $i(null)), tc("[Keys] playback.keySystemServiceEpic.emit")))(w, I, A, O, k, C, D), ((t, i, r) => e.pipe(tc("playback.legibleServiceEpic.in"), La(e => e ? an($i(e = new _p(e, t, i, r)), e) : $i(null)), tc("playback.legibleServiceEpic.emit")))(A, k, D), e]).pipe(hr(([e, t, i]) => ({
                        keySystemAdapter: e,
                        legibleSystemAdapter: t,
                        mediaSink: i
                    })))), Za(({
                        keySystemAdapter: e,
                        legibleSystemAdapter: t,
                        mediaSink: i
                    }) => {
                        this.keySystemAdapter = e, this.legibleSystemAdapter = t, this.mediaElementAdapter = i
                    }))]).pipe(hr(([e, t]) => {
                        var {
                            keySystemAdapter: i,
                            legibleSystemAdapter: r,
                            mediaSink: n
                        } = t;
                        if (!(e && i && r && n)) return null;
                        var {
                            rootPlaylistQuery: s,
                            iframeMachine: t,
                            mediaParser: e
                        } = e;
                        return {
                            logger: this.logger,
                            config: m,
                            platformService: this.platformService,
                            statsService: this.statsService,
                            rtcService: this.rtcService,
                            rpcClients: this.rpcClients,
                            rootPlaylistService: this.rootPlaylistService,
                            rootPlaylistQuery: s,
                            mediaLibraryService: f,
                            keySystemAdapter: i,
                            legibleSystemAdapter: r,
                            mediaSink: n,
                            mediaParser: e,
                            iframeMachine: t,
                            customUrlLoader: this.customUrlLoader,
                            gaplessInstance: this
                        }
                    }), Aa()).pipe(La(u => {
                        if (!u) return Ii;
                        const {
                            rootPlaylistQuery: t,
                            mediaSink: e,
                            mediaLibraryService: i
                        } = u;
                        this.publicQueriesInternal$.next([t, e.mediaQuery]);
                        const n = e.mediaQuery,
                            r = $i(u).pipe(vy()),
                            s = t.rootPlaylistEntity$.pipe(Kp(), Ds(1), Za(() => {
                                this.commitEarlySelection(u.logger)
                            })),
                            a = Gu(Mr([n.haveEnough$, t.sessionData$]), ([e]) => !0 === e, 1).pipe(La(([, e]) => this.sessionDataLoader.loadSessionData(e)), Za(e => {
                                this.rootPlaylistService.setSessionData(t.itemId, e)
                            }), Vn(e => (this.logger.error(e.message), Ii))),
                            o = Zf(t.itemId),
                            l = function(d, r, u, n, s) {
                                const a = u.mediaQuery;
                                return Gu(a.combinedBuffer$, e => 0 < (null == e ? void 0 : e.length)).pipe(La(() => {
                                    var e = ed([a.seekTo$, a.bufferedSegmentsByType$(yu.Variant)]).pipe(hr(([e, t]) => {
                                            const i = ne(null == e ? void 0 : e.pos) ? e.pos : a.currentTime,
                                                r = t.find(e => e.startPTS <= i && e.endPTS > i),
                                                n = a.getBufferInfo(i, d.maxBufferHole),
                                                s = a.getCombinedBufferInfo(i, d.maxBufferHole);
                                            return {
                                                pos: i,
                                                sbTuple: n,
                                                combined: s,
                                                playingFrag: null !== (t = null == r ? void 0 : r.frag) && void 0 !== t ? t : null
                                            }
                                        })),
                                        t = ed([r.getInFlightFragByType$(gu.Variant), r.enabledMediaOptionByType$(gu.Variant)]).pipe(La(([e, t]) => {
                                            var i = n.getQueryForOption(t);
                                            return En($i(e), $i(t), i.mediaOptionDetails$)
                                        }), hr(([e, t, i]) => [e, {
                                            variant: t,
                                            details: i
                                        }])),
                                        i = ed([s.bandwidthEstimate$, s.fragEstimate$, s.bufferEstimate$]);
                                    return ed([a.readyState$, t, e, a.desiredRate$, i])
                                }), ao(100, tr, {
                                    leading: !0,
                                    trailing: !0
                                }), hr(([, e, t, i, r]) => {
                                    var [n, s] = e, [a, e, r] = r;
                                    let o = e,
                                        l = r;
                                    return e && (o = {
                                        maxDurationSec: ne(e.maxDurationSec) ? e.maxDurationSec : d.defaultTargetDuration,
                                        avgParseTimeMs: ne(e.avgParseTimeMs) ? e.avgParseTimeMs : d.statDefaults.fragParseTimeMs
                                    }), r && (l = {
                                        avgBufferCreateMs: ne(r.avgBufferCreateMs) ? r.avgBufferCreateMs : d.statDefaults.fragBufferCreationDelayMs,
                                        avgInitFragAppendMs: ne(r.avgInitFragAppendMs) ? r.avgInitFragAppendMs : d.statDefaults.initFragAppendMs,
                                        avgDataFragAppendMs: ne(r.avgDataFragAppendMs) ? r.avgDataFragAppendMs : d.statDefaults.dataFragAppendMs
                                    }), a = Ey(d, n, s, t, i, a, o, l), u.haveEnough = a
                                }), Is(), Za(e => {}), $a(Ii))
                            }(m, (this.logger, t), e, i, o),
                            d = function() {
                                const {
                                    config: e,
                                    mediaSink: t,
                                    rootPlaylistQuery: i,
                                    mediaLibraryService: r,
                                    gaplessInstance: n
                                } = u, s = t.mediaQuery, a = i.enabledAVOptions$.pipe(La(e => En(...e.map(e => _u(e) ? r.getQueryForOption(e).mediaOptionDetails$ : $i(null)))));
                                return Gu(s.combinedBuffer$, e => 0 < (null == e ? void 0 : e.length)).pipe($a(ed([a, s.msReadyState$, s.updating$, s.isIframeRate$, s.isBufferedToEnd$(e.maxBufferHole, !n.inGaplessMode)])), tc("checkForEndOfStream"), ln(([, e, t, i, r]) => "open" === e && !1 === t && !i && r), Za(([e]) => {
                                    null != e[0] && e.every(e => null == e || !1 === e.liveOrEvent && !1 === e.iframesOnly) && !n.inGaplessMode && t.endStream()
                                }), $a(Ii))
                            }(),
                            c = function() {
                                const {
                                    config: o,
                                    iframeMachine: l,
                                    mediaSink: i
                                } = u, d = i.mediaQuery;
                                return d.desiredRate$.pipe(La(a => Wp(a) ? bn(0, Math.abs(1e3 / a)).pipe(hr(() => {
                                    let e = null;
                                    const t = d.seekable;
                                    if (!l.isStarted || t.length < 1) return e;
                                    var i = l.iframeClockTimeSeconds,
                                        r = o.leftMediaTimeToAutoPause,
                                        n = t.start(0),
                                        s = t.end(t.length - 1);
                                    return 1 < a && s - i < r ? (e = {
                                        newRate: 0,
                                        postFlushSeek: s - r
                                    }, l.pause()) : a < 0 && i - n < a / -2 && (e = {
                                        newRate: 1,
                                        postFlushSeek: n
                                    }), e
                                }), Kp(), Za(({
                                    newRate: e,
                                    postFlushSeek: t
                                }) => {
                                    i.postFlushSeek = t, i.desiredRate = e
                                }), $a(Ii)) : Ii))
                            }(),
                            h = (f = u).config.enableIFramePreloading ? function(t) {
                                const {
                                    mediaSink: e,
                                    rootPlaylistQuery: r,
                                    mediaLibraryService: n
                                } = t, i = e.mediaQuery;
                                return ed([i.desiredRate$, i.waterLevelChangedForType$(yu.Variant)]).pipe(La(([e, t]) => Wp(e) || t !== Dp.AboveHighWater ? Ii : r.enabledMediaOptionByType$(gu.Variant).pipe(hr(e => {
                                    var t = r.mediaOptionListQueries[gu.Variant].hasIframes,
                                        i = null !== (i = null === (i = n.getQuery().getEntity(r.itemId)) || void 0 === i ? void 0 : i.liveOrEvent) && void 0 !== i && i;
                                    return !t || i ? xm.DISABLED : e
                                }))), Ds(1), _s(e => function(e, t) {
                                    const i = t.logger;
                                    return e === xm.DISABLED ? $i(e) : function(e, t) {
                                        const {
                                            rootPlaylistQuery: i,
                                            logger: r,
                                            config: n,
                                            mediaSink: s,
                                            statsService: a
                                        } = t, o = s.mediaQuery, l = a.getQueryForItem(i.itemId), d = Dg(e), u = jg(!0, n, i, d, o, l, r), c = i.variantMediaOptionById(u.variantMediaOption);
                                        return Mg(t, c, !0)
                                    }(e, t).pipe(_s(r => function(e) {
                                        var {
                                            mediaSink: t,
                                            rootPlaylistQuery: i
                                        } = e, t = Ig((t = t.mediaQuery).currentTime, i.discoSeqNum, 0, r, []);
                                        return null !== (i = null == t ? void 0 : t.foundFrag) && void 0 !== i && i.mediaFragment ? (t = t.foundFrag.mediaFragment, en([_g(e, t.keyTagInfo, {
                                            itemId: t.itemId,
                                            mediaOptionId: t.mediaOptionId
                                        }), xg(e, t)]).pipe(Za(() => {}), Zs(xm.SUCCESS))) : Vi("Unable to find fragment for iframe prefetch")
                                    }(t)), Zs(xm.SUCCESS), Vn(e => (i.error(ry, `got error ${e.message} in prefetch`), $i(xm.ERRORED))))
                                }(e, t)), Vs(() => {}))
                            }(f) : $i(xm.DISABLED),
                            p = [s, r, a, l, Gu(ed([n.gotPlaying$, n.gotLoadStart$, n.readyState$]), ([e, t, i]) => !0 === e || !0 === t || 1 <= i).pipe(La(() => n.ended$), La(e => bn(0, e ? void 0 : 1e3)), Za(() => {
                                this.playbackInfo(m, n)
                            })), c, h, n.timeupdate$.pipe(hr(e => {
                                if (this.inGaplessMode && this.isPreloading && ne(this.loadingItem.itemStartOffset) && e >= this.loadingItem.itemStartOffset) {
                                    const e = this.itemQueue.playingItem.itemId,
                                        t = this.itemQueue.loadingItem.itemId,
                                        i = {
                                            prevItemId: e,
                                            nextItemId: t,
                                            nextStartTime: this.loadingItem.itemStartOffset,
                                            nextDuration: n.msDuration - this.loadingItem.itemStartOffset
                                        };
                                    this.itemQueue.updatePlayingItemId(), this.trigger(P.ITEM_TRANSITIONED, i), this.rtcService.itemTransitioned(e, t)
                                }
                            })), this.updateLiveSeekableRange(t, e), d];
                        var f;
                        if (m.enablePerformanceLogging) {
                            this.logger.child({
                                name: "timing"
                            });
                            const u = En(...Bu.map(r => t.getInFlightFragByType$(r).pipe(Is((e, t) => (null == e ? void 0 : e.state) === (null == t ? void 0 : t.state)), Kp(), bo(n.bufferedRangeTuple$), Za(([e, t]) => {
                                    const i = Object.assign(Object.assign({}, e), {
                                        event: "fragment",
                                        name: Nu[r],
                                        buffered: void 0
                                    });
                                    "appended" === e.state && (i.buffered = t)
                                }), Vn(() => Ii)))),
                                e = En(...Fu.map(e => t.enabledMediaOptionByType$(e).pipe(La(t => null != (null == t ? void 0 : t.url) && _u(t) ? Dg(t).mediaOptionDetailsEntity$.pipe(Kp(), hr(e => ({
                                    entity: e,
                                    option: t
                                })), Is((e, t) => (null == e ? void 0 : e.entity.detailsLoading) === (null == t ? void 0 : t.entity.detailsLoading)), Za(({}) => {})) : Ii), Vn(() => Ii))));
                            p.push(u, e)
                        }
                        return an(...p)
                    })),
                    h = this.itemQueue.removedItems$.pipe(ll(e => {
                        var t;
                        t = e, Cg().remove(t), this.rootPlaylistService.removeItems(e)
                    })),
                    M = p.getQuery().userSeek$.pipe((T = this.itemQueue, E = this.rootPlaylistService, e => e.pipe(Kp(), La(e => en([$i(e), T.activeItemById$.pipe(Kp(), La(e => E.getQueryForId(e.itemId).rootPlaylistEntity$), Ds(1))])), hr(([e, t]) => (E.setPendingSeek(t.itemId, e), e))))),
                    x = p.getQuery().selectEntityAction(Eo.Add).pipe(Za(() => {
                        this.logger.warn(`new Hls instance added while old one still active sessionId:${r}`)
                    }));
                an(S.pipe(Vn(() => Ii)), an(v, M, b, h, c, this.teardownWG$).pipe(Vn(e => this._handleError(e)))).pipe(Vs(() => {
                    var e, t;
                    try {
                        this.detachMedia(), this.trigger(P.DESTROYING), this.playerEvents.destroy(), null === (e = this.accessLogInstance) || void 0 === e || e.destroy(), null === (t = this.rtcService) || void 0 === t || t.destroy(), Cg().clear(), this.rootPlaylistService.removeAll(), this.itemQueue.clearQueue(), p.removeEntity(this.sessionID)
                    } catch (e) {
                        this.logger.error(`Got error in finalize ${e.message}`)
                    }
                }), Va(fn(this.destroy$, x))).subscribe()
            }
            get publicQueries$() {
                return this.publicQueriesInternal$.pipe(ln(e => Boolean(e) && Boolean(e[0]) && Boolean(e[1])))
            }
            get _activeRootQuery() {
                var e = this.publicQueriesInternal$.value;
                return null !== (e = null == e ? void 0 : e[0]) && void 0 !== e ? e : null
            }
            get _mediaElementQuery() {
                var e = this.publicQueriesInternal$.value;
                return null !== (e = null == e ? void 0 : e[1]) && void 0 !== e ? e : null
            }
            static get version() {
                return "2.162.2"
            }
            static get Events() {
                return P
            }
            get Events() {
                return zy.Events
            }
            static get DefaultConfig() {
                return de(Ru)
            }
            get DefaultConfig() {
                return zy.DefaultConfig
            }
            static isSupported() {
                try {
                    const e = window.MediaSource || window.WebKitMediaSource,
                        t = window.SourceBuffer || window.WebKitSourceBuffer,
                        i = e && "function" == typeof e.isTypeSupported && e.isTypeSupported('video/mp4; codecs="avc1.42E01E,mp4a.40.2"'),
                        r = !t || t.prototype && "function" == typeof t.prototype.appendBuffer && "function" == typeof t.prototype.remove;
                    return !!i && !!r
                } catch (e) {
                    return !1
                }
            }
            commitEarlySelection(e) {
                var t = this.itemQueue.earlyAudioSelection;
                ne(t) && (this.audioSelectedPersistentID = t, this.itemQueue.earlyAudioSelection = null), ne(t = this.itemQueue.earlySubtitleSelection) && (this.subtitleSelectedPersistentID = t, this.itemQueue.earlySubtitleSelection = null)
            }
            _handleError(i) {
                var r;
                try {
                    let t, e = i.message;
                    if (this.logger.error(`Got unhandled or fatal error ${e}`, i), null === (r = this.rtcService) || void 0 === r || r.handleError(i), t = i instanceof p ? i : new V(!0, i.message, $.InternalError), t.fatal && this.isPreloading && (this.logger.warn("Fatal error seen while preloading, calling dequeueSource"), this.dequeueSource("FatalErrorWhileLoading")), t.fatal) {
                        let e = Wu;
                        if (this.mediaElementAdapter) {
                            const r = this.mediaElementAdapter.mediaQuery,
                                n = r.getCombinedBufferInfo(r.currentTime, 0);
                            0 < (null == n ? void 0 : n.len) && (e = Gu(this.mediaElementAdapter.mediaQuery.stallInfo$, e => null != e).pipe(hr(() => {})))
                        }
                        return e.pipe(La(() => (this.trigger(P.ERROR, t), Ii)))
                    }
                    this.trigger(P.ERROR, t)
                } catch (i) {
                    throw this.logger.error(`Error thrown inside _handleError ${i.message}`, i), i
                }
                return Ii
            }
            updateLiveSeekableRange(e, t) {
                return e.enabledMediaOptionByType$(gu.Variant).pipe(La(e => {
                    const t = Dg(e);
                    let i = 0;
                    return t.mediaOptionDetailsEntity$.pipe(Kp(), ln(e => {
                        var t = null !== e.stats && !1 === e.detailsLoading && e.lastUpdateMillis > i;
                        return i = null !== (e = e.lastUpdateMillis) && void 0 !== e ? e : 0, t
                    }))
                }), La(e => (0 === e.unchangedCount && (e.mediaOptionDetails.liveOrEvent ? t.updateLiveSeekableRange(e.mediaOptionDetails) : t.clearLiveSeekableRange()), Ii)))
            }
            playbackInfo(i, r) {
                const n = this.mediaElement$.getValue();
                if (n) {
                    const s = n.readyState >= n.HAVE_FUTURE_DATA,
                        a = {
                            readyToPlay: s,
                            playbackLikelyToKeepUp: r.haveEnough && s,
                            rate: n.playbackRate,
                            paused: n.paused,
                            position: n.currentTime,
                            duration: n.duration,
                            seekableTimeRanges: im.timeRangeToArray(n.seekable),
                            loadedTimeRanges: im.timeRangeToArray(n.buffered)
                        };
                    let e = 0,
                        t = 0;
                    if (im.isHtmlVideoElement(n)) {
                        const o = n.getVideoPlaybackQuality;
                        if (o && typeof o == typeof Function) {
                            const o = n.getVideoPlaybackQuality();
                            e = a.droppedVideoFrames = o.droppedVideoFrames, a.corruptedVideoFrames = o.corruptedVideoFrames, a.totalVideoFrames = o.totalVideoFrames, t = a.totalVideoFrames - e
                        }
                    } else im.isWebkitMediaElement(n) && (e = a.droppedVideoFrames = n.webkitDroppedFrameCount, t = a.decodedFrameCount = n.webkitDecodedFrameCount);
                    i.enablePerformanceLogging && r.getCombinedMediaSourceBufferInfo(i.maxBufferHole), null === (i = this.rtcService) || void 0 === i || i.handlePlaybackInfo(e, t)
                }
            }
            get currentItem() {
                return this.isPreloading ? this.playingItem : this.itemQueue.activeItem
            }
            get realCurrentTime() {
                var e, t = this._mediaElementQuery;
                if (!t) return NaN;
                if (null !== (e = this.iframeMachine) && void 0 !== e && e.isStarted) {
                    const r = t.mediaElementDuration,
                        e = this.iframeMachine.iframeClockTimeSeconds;
                    return e > r ? r : e
                }
                let i = ne(t.postFlushSeek) ? t.postFlushSeek : t.currentTime;
                return ne(i) && ne(null === (e = this.playingItem) || void 0 === e ? void 0 : e.itemStartOffset) && (i -= this.playingItem.itemStartOffset), i
            }
            set realCurrentTime(e) {
                var t;
                ne(null === (t = this.playingItem) || void 0 === t ? void 0 : t.itemStartOffset) && (e += this.playingItem.itemStartOffset), this.seekTo = e
            }
            get bufferedDuration() {
                var e;
                const t = this._mediaElementQuery;
                return null !== (e = null == t ? void 0 : t.getBufferedDuration()) && void 0 !== e ? e : 0
            }
            get sessionData() {
                var e = this._activeRootQuery;
                return null == e ? void 0 : e.sessionData
            }
            get supportedFrameRates() {
                const e = this.hlsConfig.trickPlaybackConfig.enabled,
                    t = [0, 1],
                    i = this._activeRootQuery,
                    r = Cg().getQuery();
                return e && i && r.getEntity(i.itemId) && !1 === r.getEntity(i.itemId).liveOrEvent && t.push(8, 24, 48, 96), t
            }
            loadSource(e, i, t) {
                var r, n, s, a, o, l;
                if ("playready" === this.config.keySystemPreference && !this.config.enablePlayReadyKeySystem) throw new V(!0, "Playready key system is not supported now", $.UnsupportedKeySystemError);
                if (!e || !e.trim().length) throw new V(!0, "Empty loadSource url", $.EmptyLoadSourceError);
                if (e = bu.buildAbsoluteURL(window.location.href, e, {
                        alwaysNormalize: !0
                    }), i && Object.keys(i).filter(e => 0 <= ["itemId", "streamID"].indexOf(e)).reduce((e, t) => t in i ? Object.assign(e, {
                        [t]: i[t]
                    }) : e, {}), null !== (l = null == i ? void 0 : i.appData) && void 0 !== l && l.reportingAgent && (this.reportingAgent = i.appData.reportingAgent), null != i && i.userInfo && (this.userInfo = i.userInfo), null === (a = this.accessLogInstance) || void 0 === a || a.setupReporter(i.appData), null != i && i.platformInfo && this.platformService.updatePlatformInfo(i.platformInfo), function(e, t) {
                        if (t) {
                            const t = Eu(e);
                            return void 0 !== Iu.find(e => new RegExp(e).exec(t))
                        }
                    }(e, this.config.enableQueryParamsForITunes)) {
                    const d = {
                        language: i.language,
                        dsid: i.dsid,
                        subs: i.subs
                    };
                    r = e, n = null == i ? void 0 : i.platformInfo, s = d, o = n.model, l = n.manufacturer, o && l || Qe().warn(`Missing model/manufacturer in platformInfo model ${o} manufacturer ${l}`), o && l && (a = r, o = n.model, l = n.manufacturer, n = -1 !== a.indexOf("?"), o = encodeURIComponent(o), l = encodeURIComponent(l), r = (a = n ? a : a + "?") + wu.deviceName + l + wu.deviceModel + o), e = function(e, t) {
                        let i;
                        e = -1 !== e.indexOf("?") ? e : e + "?";
                        const r = Qe();
                        for (i in t) t[i] ? e += wu[i] + ("subs" === i ? encodeURIComponent(t[i]) : t[i]) : r.warn(`Missing ${i} info`);
                        return e
                    }(r, s), i.inheritQuery = !1
                }
                this.itemQueue.setQueueItem(`item:${null!==(s=null==i?void 0:i.itemId)&&void 0!==s?s:Zl()}`, e, t, null == i ? void 0 : i.platformInfo, null === (t = null == i ? void 0 : i.appData) || void 0 === t ? void 0 : t.serviceName), fg().setStartTime(void 0)
            }
            queueSource(e, t, i) {
                var r;
                null != t && t.userInfo && (this.userInfo = t.userInfo);
                var n = null === (r = this._mediaElementQuery) || void 0 === r ? void 0 : r.getCombinedBufferInfo(null === (n = this._mediaElementQuery) || void 0 === n ? void 0 : n.currentTime, 0);
                let s = 0;
                n && (s = n.end), this.itemQueue.addQueueItem(`item:${null!==(n=null==t?void 0:t.itemId)&&void 0!==n?n:Zl()}`, e, i, null == t ? void 0 : t.platformInfo, s, null === (t = null == t ? void 0 : t.appData) || void 0 === t ? void 0 : t.serviceName)
            }
            dequeueSource(e = "ApplicationInitiated") {
                if (!this.isPreloading && "InvalidFormat" === e && this.isFirstItem) return this.logger.error("First item has invalid format for gapless. Probably video. Disabling gapless."), void(this.gaplessCapable = !1);
                var t, i;
                this.isPreloading ? (t = this.loadingItem.url, i = this.loadingItem.itemId, this.mediaElementAdapter.flushData(yu.Variant, this.loadingItem.itemStartOffset, 1 / 0), this.mediaElementAdapter.msDuration = this.loadingItem.itemStartOffset, this.itemQueue.resetLoadingItem(), "InvalidFormat" !== e && "FatalErrorWhileLoading" !== e || (this.gaplessCapable = !1), this.triggerItemEvicted({
                    url: t,
                    itemId: i
                }, e)) : this.logger.warn(`Nothing to dequeue, no item is preloading dequeue reason: ${e}`)
            }
            triggerItemEvicted(e, t) {
                null !== e ? (t = {
                    url: e.url,
                    evictedItemId: e.itemId,
                    reason: t
                }, Object.assign(Object.assign({}, t), {
                    url: le(e.url)
                }), this.trigger(P.ITEM_EVICTED, t)) : this.logger.error("dequeueSource called with no playing or loading item")
            }
            endSource() {
                this.gaplessCapable = !1, this.isPreloading && (this.logger.warn("EndSource called during preloading. Loading item will be removed"), this.mediaElementAdapter.flushData(yu.Variant, this.loadingItem.itemStartOffset, 1 / 0), this.mediaElementAdapter.msDuration = this.loadingItem.itemStartOffset, this.itemQueue.resetLoadingItem())
            }
            get inGaplessMode() {
                return mg().gapless && this.gaplessCapable
            }
            get isPreloading() {
                return this.itemQueue.isPreloading()
            }
            get isFirstItem() {
                return this.itemQueue.isFirstItem
            }
            get loadingItem() {
                return this.itemQueue.loadingItem
            }
            get playingItem() {
                return this.itemQueue.playingItem
            }
            get url() {
                return this.playingItem ? this.playingItem.url : this.loadingItem ? this.loadingItem.url : void 0
            }
            destroy() {
                const t = this.logger;
                return this.destroy$.next(), null != this.rpcService && (this.teardownWG$.add(), this.rpcService.teardown(e => {
                    e && t.error("RPCService teardown error:", e), this.teardownWG$.done()
                }), this.rpcService = null), null != this.iframeMachine && (this.iframeMachine.destroy(), this.iframeMachine = null), this.teardownWG$.toPromise()
            }
            attachMedia(e) {
                this.trigger(P.MEDIA_ATTACHING, {
                    media: e
                }), this.mediaElement$.next(e), this.trigger(P.MEDIA_ATTACHED, {
                    media: e
                })
            }
            detachMedia() {
                var e;
                this.mediaElement$.getValue() && (this.trigger(P.MEDIA_DETACHING), null === (e = this.rtcService) || void 0 === e || e.detachMedia(), null != this.iframeMachine && this.iframeMachine.stop(), this.mediaElement$.next(null), this.trigger(P.MEDIA_DETACHED))
            }
            handleResolvedUri(e, t) {
                this.customUrlLoader.setCustomUrlResponse(e, {
                    uri: t.uri,
                    response: t
                })
            }
            get variantOptions$() {
                return this.publicQueries$.pipe(La(e => {
                    const [t, i] = e;
                    return Mr([t.preferredMediaOptions$, i.desiredRate$]).pipe(hr(([e]) => {
                        const t = i.isIframeRate;
                        return e[gu.Variant].filter(e => (null !== (e = e.iframes) && void 0 !== e && e) === t).map(e => e.mediaOptionId)
                    }))
                }))
            }
            get altAudioOptions$() {
                return this.publicQueries$.pipe(La(e => {
                    var [e] = e;
                    return $i(e.audioMediaSelectionOptions)
                }))
            }
            get subtitleOptions$() {
                return this.publicQueries$.pipe(La(e => {
                    var [e] = e;
                    return $i([{
                        MediaSelectionOptionsName: "Disable subtitle",
                        MediaSelectionOptionsPersistentID: -1
                    }].concat(e.subtitleMediaSelectionOptions))
                }))
            }
            get levels() {
                var e;
                return null !== (e = null === (e = this._activeRootQuery) || void 0 === e ? void 0 : e.preferredMediaOptions[gu.Variant]) && void 0 !== e ? e : []
            }
            get audioTracks() {
                var e;
                return null !== (e = null === (e = this._activeRootQuery) || void 0 === e ? void 0 : e.preferredMediaOptions[gu.AltAudio]) && void 0 !== e ? e : []
            }
            get audioMediaOptions() {
                var e;
                return null !== (e = null === (e = this._activeRootQuery) || void 0 === e ? void 0 : e.audioMediaSelectionOptions) && void 0 !== e ? e : []
            }
            get subtitleMediaOptions() {
                var e;
                return null !== (e = null === (e = this._activeRootQuery) || void 0 === e ? void 0 : e.subtitleMediaSelectionOptions) && void 0 !== e ? e : []
            }
            get playbackLikelyToKeepUp() {
                var e;
                return null !== (e = null === (e = this._mediaElementQuery) || void 0 === e ? void 0 : e.playbackLikelyToKeepUp) && void 0 !== e && e
            }
            get duration$() {
                return this.publicQueries$.pipe(La(e => {
                    var [, e] = e;
                    return e.mediaElementDuration$
                }))
            }
            get timeupdate$() {
                return this.publicQueries$.pipe(La(e => {
                    var [, e] = e;
                    return e.timeupdate$
                }))
            }
            get playing$() {
                return this.publicQueries$.pipe(La(e => {
                    var [, e] = e;
                    return e.gotPlaying$
                }))
            }
            get desiredRate$() {
                return this.publicQueries$.pipe(La(e => {
                    var [, e] = e;
                    return e.desiredRate$
                }))
            }
            set desiredRate(e) {
                null != e && this.setRate(e)
            }
            get desiredRate() {
                var e;
                return null !== (e = null === (e = this._mediaElementQuery) || void 0 === e ? void 0 : e.desiredRate) && void 0 !== e ? e : 0
            }
            get effectiveRate() {
                var e;
                return null !== (e = null === (e = this._mediaElementQuery) || void 0 === e ? void 0 : e.effectiveRate) && void 0 !== e ? e : 0
            }
            get iframeMode() {
                var e;
                return null !== (e = null === (e = this._mediaElementQuery) || void 0 === e ? void 0 : e.isIframeRate) && void 0 !== e && e
            }
            get accessLog() {
                return this.accessLogInstance && this._activeRootQuery ? this.accessLogInstance.getAccessLog(this._activeRootQuery.itemId) : []
            }
            get errorLog() {
                return this.accessLogInstance ? this.accessLogInstance.errorLog : []
            }
            setRate(e) {
                var t;
                const i = this.logger.child({
                    name: "iframes"
                });
                if (e === this.desiredRate) return -2;
                const r = this.mediaElementAdapter;
                if (!r || isNaN(e)) return i.warn("unable to switch to rate, missing adapter or newRate isNaN"), -1;
                e = Number(e);
                const n = Math.abs(e);
                if (!this.supportedFrameRates.some(e => e === n)) return i.warn(`unsupported rate(${e})`), -3;
                const s = Wp(e),
                    a = this.iframeMachine;
                if (s) {
                    const e = this._activeRootQuery;
                    if (null == e || !e.mediaOptionListQueries[gu.Variant].hasIframes) return i.warn("no iframe variants available"), -1;
                    r.postFlushSeek = null
                } else null != a && a.isStarted && !ne(null === (t = r.mediaQuery) || void 0 === t ? void 0 : t.postFlushSeek) && (a.pause(), r.postFlushSeek = a.iframeClockTimeSeconds);
                return r.desiredRate = e, 0
            }
            get sessionData$() {
                return this.publicQueries$.pipe(La(([e]) => e.sessionData$))
            }
            set skip(e) {
                this._mediaElementQuery && (this.realCurrentTime = Math.max(0, this.realCurrentTime + e))
            }
            gaplessSeekTo(e) {
                e < this.playingItem.itemStartOffset && (this.logger.warn(`[Gapless] Seeking past track boundary oldSeek=${e}, adjustedSeek=${this.playingItem.itemStartOffset}`), e = this.playingItem.itemStartOffset), this.isPreloading && (e > this.loadingItem.itemStartOffset && (this.logger.warn(`[Gapless] Seeking past track boundary oldSeek=${e}, adjustedSeek=${this.loadingItem.itemStartOffset}`), e = this.loadingItem.itemStartOffset), e < this._mediaElementQuery.getBufferInfo(this._mediaElementQuery.currentTime, this.config.maxBufferHole)[0].buffered.start && this.dequeueSource("SeekToUnbufferedTimeRanges")), fg().setUserSeek(e)
            }
            isIframeInternalSeek(e) {
                return e === (null === (e = this.iframeMachine) || void 0 === e ? void 0 : e.mediaRootTime)
            }
            set seekTo(e) {
                var t, i = Number(e);
                if (ne(i))
                    if (this.inGaplessMode) this.gaplessSeekTo(i);
                    else {
                        const r = this.mediaElementAdapter;
                        !r || !ne(null === (t = r.mediaQuery) || void 0 === t ? void 0 : t.postFlushSeek) || r.mediaQuery.seekTo && !this.isIframeInternalSeek(r.mediaQuery.seekTo.pos) ? fg().setUserSeek(i) : r.schedulePostFlushSeek(i)
                    }
                else this.logger.error(`[seek] got invalid seek value ${e}`)
            }
            seekToDate(e) {
                fg().setUserSeek(e)
            }
            get availableProgramDateTime() {
                return new Map(this._currentDateToMediaTimeTuple)
            }
            get _currentDateToMediaTimeTuple() {
                if (!this._activeRootQuery) return [];
                var e = this._activeRootQuery.enabledMediaOptionKeys[gu.Variant];
                return _u(e) && null !== (e = null === (e = Cg().getQueryForOption(e).mediaOptionDetails) || void 0 === e ? void 0 : e.dateMediaTimePairs) && void 0 !== e ? e : []
            }
            get playingDate() {
                return function(e, t) {
                    if (e && 0 !== e.length) {
                        const i = [...e].sort((e, t) => t[1] - e[1]),
                            r = null !== (e = i.find(([, e]) => e <= t)) && void 0 !== e ? e : i[i.length - 1],
                            [n, s] = r;
                        return new Date(n + 1e3 * (t - s))
                    }
                }(this._currentDateToMediaTimeTuple, this.realCurrentTime)
            }
            set variantId(e) {}
            set audioSelectedPersistentID(e) {
                var t = this._activeRootQuery;
                null != t && t.preferredMediaOptions[gu.AltAudio] ? (t = t.itemId, e !== this.audioSelectedPersistentID && this.rootPlaylistService.setEnabledMediaOptionTupleWithMatchedGroups(t, gu.AltAudio, e, {
                    userInitiated: !0
                })) : !ne(e) || e < 0 || (this.logger.warn(`[audio] no active item, defer audio track selection: persistentId ${e}`), this.itemQueue.earlyAudioSelection = e)
            }
            get audioSelectedPersistentID() {
                var e;
                return this._activeRootQuery ? null === (e = this._activeRootQuery.enabledAlternateMediaOptionByType(gu.AltAudio)) || void 0 === e ? void 0 : e.persistentID : this.itemQueue.earlyAudioSelection
            }
            set subtitleSelectedPersistentID(e) {
                var t = this._activeRootQuery,
                    i = null == t ? void 0 : t.preferredMediaOptions[gu.Subtitle];
                i ? e !== this.subtitleSelectedPersistentID && (t = t.itemId, 0 === i.length && (!ne(e) || e < 0) || (ne(e) && -1 !== e ? this.rootPlaylistService.setEnabledMediaOptionTupleWithMatchedGroups(t, gu.Subtitle, e) : this.rootPlaylistService.setEnabledMediaOptionByType(t, gu.Subtitle, Lu))) : !ne(e) || e < 0 || (this.logger.warn(`[subtitle] no active item, defer subtitle track selection: persistentId ${e}`), this.itemQueue.earlySubtitleSelection = e)
            }
            get subtitleSelectedPersistentID() {
                var e;
                return this._activeRootQuery ? null === (e = this._activeRootQuery.enabledAlternateMediaOptionByType(gu.Subtitle)) || void 0 === e ? void 0 : e.persistentID : this.itemQueue.earlySubtitleSelection
            }
            get selectedMediaArray() {
                const e = this._activeRootQuery;
                if (!e) return [];
                const t = [],
                    i = e.enabledAlternateMediaOptionByType(gu.AltAudio),
                    r = e.enabledAlternateMediaOptionByType(gu.Subtitle),
                    n = i ? e.audioMediaSelectionOptions.find(e => e.MediaSelectionOptionsPersistentID === i.persistentID) : void 0,
                    s = r ? e.subtitleMediaSelectionOptions.find(e => e.MediaSelectionOptionsPersistentID === r.persistentID) : void 0;
                if (n) {
                    const e = {
                        MediaSelectionGroupMediaType: Su.AUDIO,
                        MediaSelectionOptionsPersistentID: n.MediaSelectionOptionsPersistentID
                    };
                    t.push(e)
                }
                if (s) {
                    let e = vu.NO;
                    s.MediaSelectionOptionsDisplaysNonForcedSubtitles && (e = s.MediaSelectionOptionsDisplaysNonForcedSubtitles);
                    const i = {
                        MediaSelectionGroupMediaType: Su.SUBTITLE,
                        MediaSelectionOptionsDisplaysNonForcedSubtitles: e,
                        MediaSelectionOptionsPersistentID: s.MediaSelectionOptionsPersistentID
                    };
                    t.push(i)
                }
                return t
            }
            set selectedMediaArray(e) {
                this._activeRootQuery ? e.forEach(e => {
                    e.MediaSelectionGroupMediaType === Su.AUDIO || e.MediaSelectionOptionsMediaType === Su.AUDIO ? this.audioSelectedPersistentID = e.MediaSelectionOptionsPersistentID : e.MediaSelectionGroupMediaType !== Su.SUBTITLE && e.MediaSelectionOptionsMediaType !== Su.SUBTITLE && e.MediaSelectionOptionsMediaType !== Su.CLOSEDCAPTION || (this.subtitleSelectedPersistentID = e.MediaSelectionOptionsPersistentID)
                }) : this.logger.warn("selectedMediaArray: no active item")
            }
            getHTMLTextTrack(e) {
                return this.legibleSystemAdapter.getExistingHTMLTextTrackWithSubtitleTrackId(e)
            }
            get keysystems() {
                return this.keySystemAdapter.availableKeySystems
            }
            setProtectionData(e) {
                this.keySystemAdapter.initialize(e)
            }
            generateKeyRequest(e, t) {
                this.keySystemAdapter.generateRequest(e, t), this.rtcService.licenseChallengeReceived({
                    keyuri: e
                })
            }
            setLicenseResponse(e, t) {
                this.keySystemAdapter.setLicenseResponse(e, t)
            }
            get bufferInfo$() {
                return this.publicQueries$.pipe(La(e => {
                    const [, t] = e, i = fg().getQuery().currentConfig;
                    return an(t.timeupdate$, t.bufferedRangeTuple$).pipe(ao(1e3), hr(() => {
                        var e = t.currentTime;
                        return {
                            combined: t.getCombinedBufferInfo(e, i.maxBufferHole),
                            sbTuple: t.getBufferInfo(e, i.maxBufferHole)
                        }
                    }))
                }))
            }
            bufferInfoByType$(t) {
                return this.bufferInfo$.pipe(hr(e => null === (e = null == e ? void 0 : e.sbTuple) || void 0 === e ? void 0 : e[t]))
            }
            levelWithPersistentId(e) {
                this.logger.warn("levelWithPersistentId is deprecated")
            }
            startLoad(e) {
                this.logger.warn("startLoad is deprecated"), ne(e) && (this.logger.warn(`[seek] Seeking to ${null==e?void 0:e.toFixed(3)} via deprecated "startLoad" method. Use loadSource(url, options, startTime) instead.`), this.seekTo = e)
            }
            stopLoad() {}
            get config() {
                return Object.assign(Object.assign({}, de(mg())), {
                    set startPosition(e) {
                        Qe().warn(`Setting start position ${null==e?void 0:e.toFixed(3)} using deprecated method`), fg().setStartTime(e)
                    }
                })
            }
            get media() {
                return null != this.mediaElement$.value
            }
            set subtitleDisplay(e) {
                this.logger.warn(`set subtitleDisplay ${e} is deprecated`)
            }
        }
    }, "object" == typeof exports && "undefined" != typeof module ? module.exports = t() : "function" == typeof define && define.amd ? define(t) : (e = "undefined" != typeof globalThis ? globalThis : e || Jy).Hls = t()
}(!1);
//# sourceMappingURL=hls.js.map